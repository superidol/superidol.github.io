<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  <p align="center"> - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1><p align="center"></h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/09/11</span>

          
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Tłumaczenia:</h2>

<ul>
<li><a href="media/15998025629610/README.md">English</a></li>
<li><a href="media/15998025629610/README-es.md">Español</a></li>
<li><a href="media/15998025629610/README-fr.md">Français</a></li>
<li><a href="media/15998025629610/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629610/README-cn.md">中文版</a></li>
<li><a href="media/15998025629610/README-ja.md">日本語</a></li>
<li><a href="media/15998025629610/README-ko.md">한국어</a></li>
<li><a href="media/15998025629610/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629610/README-gr.md">Greek</a></li>
<li><a href="media/15998025629610/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629610/README-pl.md">Polish</a></li>
<li><a href="media/15998025629610/README-ru.md">Русский</a></li>
<li><a href="media/15998025629610/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629610/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Co to jest wyrażenie regularne?</h2>

<blockquote>
<p>Wyrażenie regularne to grupa znaków lub symboli, które służą do odnalezienia określonego wzoru w tekście.</p>
</blockquote>

<p>Wyrażenie regularne to wzorzec, który jest dopasowywany do tekstu od lewej<br/>
do prawej strony. Termin &quot;wyrażenie regularne&quot; (ang. &quot;regular expression&quot;)<br/>
jest dość długie, więc zazwyczaj używa się skróconej formy &quot;regex&quot; lub &quot;regexp&quot;.<br/>
Wyrażenie regularne jest używane do zastępowania tekstu w łańcuchu znaków<br/>
(ang. string), walidacji formularzy, wyodrębniania wycinka z łańcucha<br/>
(ang. substring) według podanego wzorca, i wielu innych.</p>

<p>Wyobraź sobie, że piszesz aplikację i chcesz ustawić reguły dotyczące tego,<br/>
jak użytkownik wybiera swoją nazwę. Chcemy, aby nazwa użytkownika zawierała litery,<br/>
liczby, podkreślenia i myślniki. Chcemy również ograniczyć liczbę znaków w nazwie<br/>
użytkownika, aby nie wyglądała za brzydko. Stosujemy następujące wyrażenie<br/>
regularne, aby sprawdzić poprawność nazwy:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-pl.png" alt="Wyrażenie regularne"><br/>
</p></p>

<p>Powyższe wyrażenie akceptuje łańcuchy <code>john_doe</code>, <code>jo-hn_doe</code><br/>
i <code>john12_as</code>. Odrzuca <code>Jo</code> ponieważ łańcuch zawiera dużą literę<br/>
i jest za krótki.</p>

<h2 id="toc_2">Spis treści</h2>

<ul>
<li><a href="#1-najprostsze-wyra%C5%BCenie">Najprostsze wyrażenie</a></li>
<li><a href="#2-metaznaki">Metaznaki</a>
<ul>
<li><a href="#21-kropka">Kropka</a></li>
<li><a href="#22-zestaw-znak%C3%B3w">Zestaw znaków</a></li>
<li><a href="#221-odwr%C3%B3cony-zestaw-znak%C3%B3w">Odwrócony zestaw znaków</a></li>
<li><a href="#23-powt%C3%B3rzenia">Powtórzenia</a></li>
<li><a href="#231-gwiazdka">Gwiazdka</a></li>
<li><a href="#232-plus">Plus</a></li>
<li><a href="#233-znak-zapytania">Znak zapytania</a></li>
<li><a href="#24-klamry">Klamry</a></li>
<li><a href="#25-grupa-znak%C3%B3w">Grupa znaków</a></li>
<li><a href="#26-alternatywa">Alternatywa</a></li>
<li><a href="#27-znak-ucieczki">Znak ucieczki</a></li>
<li><a href="#28-kotwice">Kotwice</a></li>
<li><a href="#281-kareta">Kareta</a></li>
<li><a href="#282-dolar">Dolar</a></li>
</ul></li>
<li><a href="#3-skr%C3%B3ty">Skróty</a></li>
<li><a href="#4-lookaround">Lookaround</a>
<ul>
<li><a href="#41-lookahead">Lookahead</a></li>
<li><a href="#42-odwr%C3%B3cony-lookahead">Odwrócony lookahead</a></li>
<li><a href="#43-lookbehind">Lookbehind</a></li>
<li><a href="#44-odwr%C3%B3cony-lookbehind">Odwrócony lookbehind</a></li>
</ul></li>
<li><a href="#5-flagi">Flagi</a>
<ul>
<li><a href="#51-wielko%C5%9B%C4%87-znak%C3%B3w">Wielkość znaków</a></li>
<li><a href="#52-przeszukiwanie-globalne">Przeszukiwanie globalne</a></li>
<li><a href="#53-multilinia">Multilinia</a></li>
</ul></li>
</ul>

<h2 id="toc_3">1. Najprostsze wyrażenie</h2>

<p>Wyrażenie regularne to ciąg znaków, których używamy do przeszukania tekstu.<br/>
Na przykład, wyrażenie <code>the</code> oznacza: literę <code>t</code>, następującą<br/>
po niej literę <code>h</code>, następującą po niej literę <code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Przetestuj wyrażenie</a></p>

<p>Wyrażenie regularne <code>123</code> pasuje do łańcucha <code>123</code>. Wyrażenie regularne<br/>
jest dopasowywane do danego łańcucha poprzez porównanie każdego znaku,<br/>
jeden po drugim, w wyrażeniu i łańcuchu. Wyrażenia są zwykle wrażliwe<br/>
na wielkość znaków, więc wyrażenie <code>The</code> nie pasuje do łańcucha <code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_4">2. Metaznaki</h2>

<p>Metaznaki to składowe elementy wyrażeń regularnych. Znaki te, nie oznaczają<br/>
siebie samych, są natomiast interpretowane w specjalny sposób.<br/>
Niektóre znaki mają specjalne znaczenie i są zapisywane w kwadratowych nawiasach.<br/>
Metaznaki to:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Metaznaki</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Dowolny znak z wyjątkiem nowej linii.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Zakres. Każdy znak zapisany w kwadratowym nawiasie.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Odwrócony zakres. Każdy znak, który nie znajduje się w kwadratowym nawiasie.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>0 lub więcej poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>1 lub więcej poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>0 lub 1 poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Minimum &quot;n&quot; ale nie więcej niż &quot;m&quot; poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Grupowanie znaków. Znaki xyz dokładnie w tej kolejności.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Alternatywa. Znaki przed symbolem lub za symbolem.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Znak ucieczki. Umożliwia używanie zarezerwowanych znaków <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code>.</td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Oznacza początek wzorca.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Oznacza koniec wzorca.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Kropka</h2>

<p>Kropka <code>.</code> jest najprostszym przykładem metaznaku. Oznacza dowolny znak z wyłączeniem entera<br/>
i znaków nowej linii. Na przykład, wyrażenie regularne <code>.ar</code> oznacza: dowolny znak, następującą<br/>
po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_6">2.2 Zestaw znaków</h2>

<p>Zestawy znaków nazywane też klasami znaków. Nawiasy kwadratowe służą do określenia zestawów znaków.<br/>
Użycie myślnika wewnątrz zestawu, określa jego zakres. Kolejność znaków w nawiasach kwadratowych<br/>
nie ma znaczenia. Na przykład wyrażenie <code>[Tt]he</code> oznacza: dużą literę <code>T</code> lub małą <code>t</code>,<br/>
następującą po niej literę <code>h</code>, następującą po niej literę <code>e</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Przetestuj wyrażenie</a></p>

<p>Jednak kropka w zestawie znaków, oznacza dosłownie kropkę. Wyrażenie regularne<br/>
<code>ar[.]</code> oznacza: małą literę <code>a</code>, następującą po niej literę <code>r</code>,<br/>
następującą po niej <code>.</code> kropkę.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_7">2.2.1 Odwrócony zestaw znaków</h3>

<p>Generalnie znak karety oznacza początek wyrażenia, ale gdy zostanie użyty zaraz<br/>
za otwierającym nawiasem kwadratowym, odwraca zestaw znaków. Na przykład<br/>
wyrażenie <code>[^c]ar</code> oznacza: każdy znak z wyjątkiem <code>c</code>,<br/>
następującą po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_8">2.3 Powtórzenia</h2>

<p>Następujące metaznaki <code>+</code>, <code>*</code> czy <code>?</code> określają ile razy wzorzec może się powtórzyć.<br/>
Te metaznaki zachowują się różnie, w zależności od sytuacji.</p>

<h3 id="toc_9">2.3.1 Gwiazdka</h3>

<p>Symbol <code>*</code> oznacza zero lub więcej powtórzeń poprzedzających znaków. Wyrażenie<br/>
regularne <code>a*</code> oznacza: zero lub więcej powtórzeń poprzedzającej małej<br/>
litery <code>a</code>. Ale jeśli występuje po zestawie znaków lub klasie, to oznacza<br/>
powtórzenia całego zestawu lub klasy. Na przykład, wyrażenie regularne<br/>
<code>[a-z]*</code> oznacza: każdy ciąg znaków pisany małymi literami.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Przetestuj wyrażenie</a></p>

<p>Symbol <code>*</code> może być użyty z metaznakiem <code>.</code> by oznaczyć każdy łańcuch<br/>
znaków <code>.*</code>. Symbol <code>*</code> może być użyty ze znakiem <code>\s</code><br/>
by znaleźć łańcuch zawierający spacje. Na przykład, wyrażenie<br/>
<code>\s*cat\s*</code> oznacza: zero lub więcej spacji, następującą po niej małą literę <code>c</code>,<br/>
następującą po niej małą literę <code>a</code>, następującą po niej małą literę <code>t</code>,<br/>
następujące po niej zero lub więcej spacji.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_10">2.3.2 Plus</h3>

<p>Symbol <code>+</code> oznacza jeden lub więcej powtórzeń poprzedzających znaków. Na przykład,<br/>
wyrażenie <code>c.+t</code> oznacza: małą literę <code>c</code>, następujący po niej przynajmniej jeden<br/>
dowolny znak, następującą po nim małą literę <code>t</code>. W tym wypadku <code>t</code> jest ostatnim<br/>
<code>t</code> w zdaniu.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_11">2.3.3 Znak zapytania</h3>

<p>W wyrażeniach regularnych znak <code>?</code> sprawia, że poprzedzający znak jest opcjonalny.<br/>
Ten symbol oznacza zero lub jedno wystąpienie poprzedzającego znaku. Na przykład,<br/>
wyrażenie regularne <code>[T]?he</code> oznacza: opcjonalną dużą literę <code>T</code>, następującą<br/>
po niej małą literę <code>h</code>, następującą po niej małą literę <code>e</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Przetestuj wyrażenie</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_12">2.4 Klamry</h2>

<p>W wyrażeniach regularnych, klamry zwane również kwantyfikatorami, używane są<br/>
do określenia, ile razy znak lub grupa znaków może się powtórzyć.<br/>
Na przykład wyrażenie regularne <code>[0-9]{2,3}</code> oznacza: przynajmniej<br/>
2 znaki, ale nie więcej niż 3 (znaki z zakresu od 0 do 9).</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Przetestuj wyrażenie</a></p>

<p>Możemy opuścić drugą liczbę. Na przykład regularne wyrażenie <code>[0-9]{2,}</code><br/>
oznacza: 2 lub więcej znaków. Jeżeli dodatkowo usuniemy przecinek,<br/>
to wyrażenie <code>[0-9]{3}</code> oznacza: dokładnie 3 znaki z zakresu 0 do 9.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Przetestuj wyrażenie</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_13">2.5 Grupa znaków</h2>

<p>Grupa znaków to grupa podwzorców, które zapisywane są w nawiasach <code>(...)</code>.<br/>
Jak wspominaliśmy wyżej, jeśli w wyrażeniu regularnym wstawimy kwantyfikator po<br/>
znaku, wtedy powtórzy on ten znak. Ale gdy wstawimy kwantyfikator po grupie znaków,<br/>
wtedy cała grupa zostanie powtórzona. Na przykład wyrażenie regularne <code>(ab)*</code><br/>
oznacza zero lub więcej powtórzeń grupy &quot;ab&quot;. Możemy także użyć metaznaku<br/>
alternatywy <code>|</code> wewnątrz grupy. Na przykład wyrażenie <code>(c|g|p)ar</code> oznacza: małą literę <code>c</code>,<br/>
<code>g</code> lub <code>p</code>, następującą po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_14">2.6 Alternatywa</h2>

<p>W wyrażeniach regularnych pionowa kreska <code>|</code> oznacza alternatywę.<br/>
Działa jak warunek pomiędzy różnymi wyrażeniami. Teraz możesz pomyśleć, że<br/>
to działa tak samo jak zestaw znaków. Różnica polega na tym, że zestaw znaków<br/>
działa na poziomie znaków, natomiast alternatywa na poziomie wyrażenia. Na przykład<br/>
wyrażenie regularne <code>(T|t)he|car</code> oznacza: dużą literę <code>T</code> lub małą <code>t</code>,<br/>
następującą po niej literę <code>h</code>, następującą po niej literę <code>e</code> lub <code>c</code>, następującą<br/>
po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_15">2.7 Znak ucieczki</h2>

<p>Ukośnik <code>\</code> w wyrażeniach regularnych jest znakiem ucieczki. Pozwala on<br/>
używać w wyrażeniu zarezerwowanych znaków takich jak <code>{ } [ ] / \ + * . $ ^ | ?</code>.<br/>
Aby użyć znaku specjalnego w wyrażeniu, postaw <code>\</code> przed nim.</p>

<p>Na przykład wyrażenie <code>.</code> dopasowuje każdy znak z wyjątkiem nowej linii.<br/>
Żeby dopasować kropkę <code>.</code> w wyrażeniu regularnym, trzeba wstawić przed nią ukośnik.<br/>
Wyrażenie <code>(f|c|m)at\.?</code> oznacza: małe litery <code>f</code> lub <code>c</code> lub <code>m</code>, następującą po niej<br/>
literę <code>a</code>, następującą po niej literę <code>t</code>, następującą kropkę <code>.</code>, która jest opcjonalna.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_16">2.8 Kotwice</h2>

<p>W wyrażeniach regularnych używamy kotwic aby sprawdzić czy dopasowywany symbol<br/>
jest pierwszym lub ostatnim symbolem w łańcuchu. Są dwa typy: pierwszy to<br/>
kareta <code>^</code>, która sprawdza czy znak jest początkiem łańcucha, drugi to dolar <code>$</code>,<br/>
który sprawdza czy znak jest ostatnim elementem łańcucha.</p>

<h3 id="toc_17">2.8.1 Kareta</h3>

<p>Kareta <code>^</code> sprawdza czy znak jest początkiem łańcucha. Jeżeli użyjemy takiego<br/>
wyrażenia <code>^a</code> (jeśli a jest pierwszym znakiem) na łańcuchu <code>abc</code> to dopasuje<br/>
nam <code>a</code>. Ale jeśli użyjemy takiego wyrażenia <code>^b</code> na tym samym łańcuchu, to nie<br/>
zwróci nam nic. Ponieważ w łańcuchu <code>abc</code> &quot;b&quot; nie jest pierwszym symbolem.<br/>
Spójrzmy teraz na wyrażenie <code>^(T|t)he</code> które oznacza: dużą literę <code>T</code> lub małą<br/>
<code>t</code>, która jest początkiem łańcucha, następującą po niej literę <code>h</code>, następującą<br/>
po niej literę <code>e</code>.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Przetestuj wyrażenie</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_18">2.8.2 Dolar</h3>

<p>Symbol dolara <code>$</code> używany jest do sprawdzenia czy dopasowywany znak jest ostatni<br/>
w łańcuchu. Na przykład, wyrażenie regularne <code>(at\.)$</code> oznacza: małą literę <code>a</code>,<br/>
następującą po niej literę <code>t</code>, następującą po niej kropkę <code>.</code> i na dodatek<br/>
dopasowanie musi być końcem łańcucha.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Przetestuj wyrażenie</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_19">3. Skróty</h2>

<p>W wyrażeniach regularnych znajdziemy także skróty dla popularnych zestawów znaków,<br/>
które ułatwiają pracę z wyrażeniami regularnymi. Skróty wyglądają następująco:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Skrót</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Każdy znak z wyjątkiem nowej linii</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Znaki alfanumeryczne: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Znaki nie alfanumeryczne: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Cyfry: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Nie cyfry: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Dowolny biały znak: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Każdy znak oprócz białych: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. Lookaround</h2>

<p>Lookbehind i lookahead (nazywane również lookaround) to specyficzne typy<br/>
<strong><em>niezwracających grup</em></strong> (dopasowują wzorzec, ale nie zwracają wartości).<br/>
Lookaround używane są w sytuacji, gdy mamy wzorzec i jest on poprzedzony innym wzorcem,<br/>
lub następuje po nim kolejny wzorzec. Na przykład, chcemy mieć wszystkie<br/>
numery, które są poprzedzone znakiem <code>$</code> w takim łańcuchu <code>$4.44 and $10.88</code>.<br/>
Użyjemy takiego wyrażenia regularnego <code>(?&lt;=\$)[0-9\.]*</code> które oznacza: znajdź<br/>
wszystkie liczby ze znakiem <code>.</code> poprzedzone znakiem <code>$</code>. W wyrażeniach regularnych<br/>
wyróżniamy:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Symbol</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Odwrócony lookahead</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Lookbehind</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Odwrócony lookbehind</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 Lookahead</h3>

<p>Lookahead stwierdza, że po pierwszej części wyrażenia musi następować<br/>
następne wyrażenie. Zwracane dopasowanie zawiera tylko tekst, który został<br/>
dopasowany przez pierwszą część wyrażenia. Stosuje się je w nawiasach wraz<br/>
ze znakami zapytania i równości: <code>(?=...)</code>. Wyrażenie lookahead<br/>
wpisuje się po znaku równości. Na przykład wyrażenie <code>(T|t)he(?=\sfat)</code><br/>
oznacza: opcjonalną małą literę <code>t</code> lub dużą <code>T</code>, następującą po niej<br/>
literę <code>h</code>, następującą po niej literę <code>e</code>. W nawiasach definiujemy<br/>
wyrażenie lookahead, które mówi aby dopasować <code>The</code> lub <code>the</code> i następujące<br/>
po nich <code>fat</code>.</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_22">4.2 Odwrócony lookahead</h3>

<p>Używany jest, gdy potrzebujemy dopasowania z łańcucha, po których nie następują<br/>
żadne wzorce. Odwrócony lookahead definiujemy w nawiasach, stosując znak negacji<br/>
<code>!</code> po znaku zapytania, na przykład: <code>(?!...)</code>. Popatrzmy na następujące wyrażenie<br/>
<code>(T|t)he(?!\sfat)</code> które oznacza: znajdź wszystkie słowa <code>The</code> lub <code>the</code> w łańcuchu,<br/>
po których nie następuje słowo <code>fat</code>, poprzedzone spacją.</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_23">4.3 Lookbehind</h3>

<p>Lookbehind używany jest do odnalezienia wszystkich dopasowań poprzedzonych konkretnym<br/>
wzorcem. Wyrażenie lookbehind zapisujemy tak: <code>(?&lt;=...)</code>. Na przykład, wyrażenie<br/>
<code>(?&lt;=(T|t)he\s)(fat|mat)</code> oznacza: znajdź wszystkie słowa <code>fat</code> lub <code>mat</code> w łańcuchu,<br/>
które znajdują się po słowach <code>The</code> lub <code>the</code>.</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_24">4.4 Odwrócony lookbehind</h3>

<p>Odwrócony używany jest do odnalezienia wszystkich dopasowań niepoprzedzonych konkretnym<br/>
wzorcem. Odwrócony lookbehind zapisujemy tak: <code>(?&lt;!...)</code>. Na przykład, wyrażenie<br/>
<code>(?&lt;!(T|t)he\s)(cat)</code> oznacza: znajdź wszystkie słowa <code>cat</code> w stringu, które nie następują<br/>
po słowach <code>The</code> lub <code>the</code>.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_25">5. Flagi</h2>

<p>Flagi nazywane są także modyfikatorami, ponieważ zmieniają wynik wyrażenia regularnego.<br/>
Flagi mogą być używane w każdej kombinacji i są integralną częścią wyrażeń regularnych.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Flaga</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Wielkość znaków: Sprawia, że dopasowanie nie jest wrażliwe na wielkość znaków.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Przeszukanie globalne: Wyszukiwanie wzorca w całym łańcuchu.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Multilinia: Sprawia, że kotwice działają na każdej linii.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 Wielkość znaków</h3>

<p>Modyfikator <code>i</code> używany jest, gdy wielkość liter nie ma znaczenia. Na przykład<br/>
wyrażenie <code>/The/gi</code> oznacza: dużą literę <code>T</code>, następującą po niej literę <code>h</code>,<br/>
następującą po niej literę <code>e</code>. A na końcu wyrażenia, flaga <code>i</code> żeby ignorować<br/>
wielkość znaków. Jak widać, została też użyta flaga <code>g</code> ponieważ chcemy przeszukać<br/>
cały łańcuch.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Przetestuj wyrażenie</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_27">5.2 Przeszukiwanie globalne</h3>

<p>Modyfikator <code>g</code> używany jest do przeszukiwania całego łańcucha (znajdź wszystko,<br/>
a nie tylko zatrzymuj się na pierwszym). Na przykład wyrażenie <code>/.(at)/g</code><br/>
oznacza: każdy znak z wyjątkiem nowej linii, następującą po nim literę <code>a</code>,<br/>
następującą po niej literę <code>t</code>. Ponieważ użyliśmy na końcu wyrażenia flagi <code>g</code>,<br/>
wyszukane zostaną wszystkie dopasowania w łańcuchu, a nie tylko pierwszy (domyślne zachowanie).</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Przetestuj wyrażenie</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_28">5.3 Multilinia</h3>

<p>Modyfikator <code>m</code> używany jest do dopasowywania w wielu liniach. Jak wspominaliśmy<br/>
wcześniej, kotwice <code>(^, $)</code> używane są do sprawdzania czy wzorzec jest początkiem<br/>
lub końcem łańcucha. Jeśli chcemy, żeby kotwice zadziałały w każdej linii, używamy<br/>
wtedy flagi <code>m</code>. Na przykład wyrażenie <code>/at(.)?$/gm</code> oznacza: małą literę <code>a</code>,<br/>
następującą po niej małą literę <code>t</code>, opcjonalnie dowolny znak z wyjątkiem nowej linii.<br/>
I ponieważ użyliśmy flagi <code>m</code> dopasowywane będą wzorce na końcu każdej linii w łańcuchu.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Przetestuj wyrażenie</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_29">Kontrybucja</h2>

<ul>
<li>Zgłaszanie błędów</li>
<li>Otwieranie pull request z poprawkami</li>
<li>Dzielenie się poradnikiem</li>
<li>Skontaktuj się ze mną <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> lub <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">Licencja</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15998025629523.html" 
          title="Previous Post: <p align="center">">&laquo; <p align="center"></a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15998025629703.html" 
          title="Next Post: <p align="center">"><p align="center"> &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15998025630555.html">高效 PyCharm 使用技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630642.html">群晖NAS安装配置typecho博客教程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630684.html">Linux vim 编辑器的神级配置 vimrc</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630725.html">正则表达式工具 RegexBuddy 使用指南</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630768.html">使用Docker搭建MySQL服务</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
