<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15998025628955.html">
                
                  <h1>1000行MySQL学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824230300" alt="1000行MySQL学习笔记，不怕你不会，就怕你不学"/></p>

<h3 id="toc_0">/ Windows服务 /</h3>

<pre class="line-numbers"><code class="language-text">-- 启动MySQL
    net start mysql
-- 创建Windows服务
    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)
</code></pre>

<h3 id="toc_1">/ 连接与断开服务器 /</h3>

<pre class="line-numbers"><code class="language-text">mysql -h 地址 -P 端口 -u 用户名 -p 密码

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 显示系统变量信息
</code></pre>

<h3 id="toc_2">/ 数据库操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 库名 选项信息
-- 删除库
    DROP DATABASE[ IF EXISTS] 数据库名
        同时删除该数据库相关的目录及其目录内容
</code></pre>

<h3 id="toc_3">/ 表的操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 创建表
    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        TEMPORARY 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
        InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 自增起始数
        AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 表名
-- 查看表机构
    SHOW CREATE TABLE 表名 （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]
    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        eg: ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）
        -- RENAME可以交换两个表名
    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段定义       -- 增加字段
                AFTER 字段名          -- 表示增加在该字段名后面
                FIRST               -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)   -- 创建主键
            ADD UNIQUE [索引名](字段名)-- 创建唯一索引
            ADD INDEX [索引名](字段名) -- 创建普通索引
            DROP[ COLUMN] 字段名      -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
            DROP INDEX 索引名 -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键

-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>

<h3 id="toc_4">/ 数据操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]
</code></pre>

<h3 id="toc_5">/ 字符集编码 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results       服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES GBK;  -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集
    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集
    CHARSET 字符集编码     设置字符集编码
    COLLATE 校对集编码     设置校对集编码
</code></pre>

<h3 id="toc_6">/ 数据类型（列类型） / ------------------</h3>

<pre class="line-numbers"><code class="language-text">1. 数值类型
-- a. 整型 ----------
    类型         字节     范围（有符号位）
    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255
    smallint    2字节    -32768 ~ 32767
    mediumint   3字节    -8388608 ~ 8388607
    int         4字节
    bigint      8字节

    int(M)  M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好。
    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。

-- b. 浮点型 ----------
    类型             字节     范围
    float(单精度)     4字节
    double(双精度)    8字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)     double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c. 定点数 ----------
    decimal -- 可变长度
    decimal(M, D)   M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar 变长字符串，速度慢，但节省空间
    M表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535字符，与编码有关。
    一条有效记录最大不能超过65535个字节。
        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给default值

-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期         1000-01-01 到 9999-12-31
    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间         -838:59:59 到 838:59:59
    year        1字节    年份         1901 - 2155

datetime    YYYY-MM-DD hh:mm:ss
timestamp   YY-MM-DD hh:mm:ss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        YYYY-MM-DD
            YY-MM-DD
            YYYYMMDD
            YYMMDD
            YYYYMMDD
            YYMMDD
time        hh:mm:ss
            hhmmss
            hhmmss
year        YYYY
            YY
            YYYY
            YY

4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。

-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );
    insert into tab values (&#39;男, 女&#39;);
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。
</code></pre>

<h3 id="toc_7">/ 选择类型 /</h3>

<pre class="line-numbers"><code class="language-text">-- PHP角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned
    1) PHP函数转换
        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
        利用sprintf函数格式化字符串
        sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;));
        然后用long2ip将整型转回IP字符串
    2) MySQL函数转换(无符号整型，UNSIGNED)
        INET_ATON(&#39;127.0.0.1&#39;) 将IP转为整型
        INET_NTOA(2130706433) 将整型转为IP
</code></pre>

<h3 id="toc_8">/ 列属性（列约束） / ------------------</h3>

<pre class="line-numbers"><code class="language-text">1. PRIMARY 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

2. UNIQUE 唯一索引（唯一约束）
    使得某字段的值也不能重复。

3. NULL 约束
    null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, &#39;val&#39;);
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null

4. DEFAULT 默认值属性
    当前字段的默认值。
    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time

5. AUTO_INCREMENT 自动增长约束
    自动增长必须为索引（主键或unique）
    只能存在一个字段为自动增长。
    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;

6. COMMENT 注释
    例：create table tab ( id int ) comment &#39;注释内容&#39;;

7. FOREIGN KEY 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表t1的t1_id外键关联到表t2的id字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定

    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。

    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。

    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。

    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。
</code></pre>

<h3 id="toc_9">/ 建表规范 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">   -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除符合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。
</code></pre>

<h3 id="toc_10">/ SELECT / ------------------</h3>

<pre class="line-numbers"><code class="language-text">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT

a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;

b. FROM 子句
    用于标识查询来源。
    -- 可以为表起别名。使用as关键字。
        SELECT * FROM tb1 AS tt, tb2 AS bb;
    -- from子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        SELECT * FROM tb1, tb2;
    -- 向优化符提示如何选择索引
        USE INDEX、IGNORE INDEX、FORCE INDEX
        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;
        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;

c. WHERE 子句
    -- 从from获得的数据源中进行筛选。
    -- 整型1表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较

d. GROUP BY 子句, 分组子句
    GROUP BY 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC

    以下[合计函数]需配合 GROUP BY 使用：
    count 返回不同的非NULL值数目  count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。

e. HAVING 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。

f. ORDER BY 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

g. LIMIT 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数

h. DISTINCT, ALL 选项
    distinct 去除重复记录
    默认为 all, 全部记录
</code></pre>

<h3 id="toc_11">/ UNION / ------------------</h3>

<pre class="line-numbers"><code class="language-text">   将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。
</code></pre>

<h3 id="toc_12">/ 子查询 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。

    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()   不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。
</code></pre>

<h3 id="toc_13">/ 连接查询(join) / ------------------</h3>

<pre class="line-numbers"><code class="language-text">    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)

    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;
</code></pre>

<h3 id="toc_14">/ 导入导出 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据
load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据
    生成的数据默认的分隔符是制表符
    local未指定，则数据文件必须在服务器上
    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields  控制字段格式
默认：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;
    terminated by &#39;string&#39;  -- 终止
    enclosed by &#39;char&#39;      -- 包裹
    escaped by &#39;char&#39;       -- 转义
    -- 示例：
        SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;
        FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;
        LINES TERMINATED BY &#39;\n&#39;
        FROM test_table;
lines   控制行格式
默认：lines terminated by &#39;\n&#39;
    terminated by &#39;string&#39;  -- 终止
</code></pre>

<h3 id="toc_15">/ INSERT / ------------------</h3>

<pre class="line-numbers"><code class="language-text">select语句获得的数据可以用insert插入。

可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
    或者使用set语法。
    INSERT INTO tbl_name SET field=value,...；

可以一次性使用多个值，采用(), (), ();的形式。
    INSERT INTO tbl_name VALUES (), (), ();

可以在列值指定时，使用表达式。
    INSERT INTO tbl_name VALUES (field_value, 10+10, now());
可以使用一个特殊值 DEFAULT，表示该列使用默认值。
    INSERT INTO tbl_name VALUES (field_value, DEFAULT);

可以通过一个查询的结果，作为需要插入的值。
    INSERT INTO tbl_name SELECT ...;

可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
    INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;
</code></pre>

<h3 id="toc_16">/ DELETE / ------------------</h3>

<pre class="line-numbers"><code class="language-text">DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]

按照条件删除。where

指定删除的最多记录数。limit

可以通过排序条件删除。order by + limit

支持多表删除，使用类似连接语法。
delete from 需要删除数据多表1，表2 using 表连接操作 条件。
</code></pre>

<h3 id="toc_17">/ TRUNCATE / ------------------</h3>

<pre class="line-numbers"><code class="language-text">TRUNCATE [TABLE] tbl_name
清空数据
删除重建表

区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区
</code></pre>

<h3 id="toc_18">/ 备份与还原 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。

-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database


1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库
　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)

可以-w携带WHERE条件

-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 &lt; 备份文件
</code></pre>

<h3 id="toc_19">/ 视图 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数

-- 查看结构
    SHOW CREATE VIEW view_name

-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...

-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement

-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构

-- 视图算法(ALGORITHM)
    MERGE       合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE   临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。
</code></pre>

<h3 id="toc_20">/ 事务(transaction) / ------------------</h3>

<pre class="line-numbers"><code class="language-text">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。
    - 支持连续SQL的集体成功或集体撤销。
    - 事务是数据库在数据晚自习方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB被称为事务安全型引擎。

-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。

-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。

-- 事务的原理
    利用InnoDB的自动提交(autocommit)特性完成。
    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。

-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套

-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点

-- InnoDB自动提交特性设置
    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)
</code></pre>

<h3 id="toc_21">/ 锁表 /</h3>

<pre class="line-numbers"><code class="language-text">表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES
</code></pre>

<h3 id="toc_22">/ 触发器 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">  触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
  监听：记录的增加、修改、删除。

-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
  参数：
  trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
  trigger_event指明了激活触发程序的语句的类型
      INSERT：将新行插入表时激活触发程序
      UPDATE：更改某一行时激活触发程序
      DELETE：从表中删除某一行时激活触发程序
  tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
  trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构

-- 删除
DROP TRIGGER [schema_name.]trigger_name

可以使用old和new代替旧的和新的数据
  更新操作，更新前是old，更新后是new.
  删除操作，只有old.
  增加操作，只有new.

-- 注意
  1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。


-- 字符连接函数
concat(str1,str2,...])
concat_ws(separator,str1,str2,...)

-- 分支语句
if 条件 then
  执行语句
elseif 条件 then
  执行语句
else
  执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
  SQL语句
自定义结束符号

delimiter ;     -- 修改回原来的分号

-- 语句块包裹
begin
  语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
  如果没有重复记录，会触发 before insert, after insert;
  如果有重复记录并更新，会触发 before insert, before update, after update;
  如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert
</code></pre>

<h3 id="toc_23">/ SQL编程 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value]
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。

-- 赋值
    使用 set 和 select into 语句为变量赋值。

    - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;

select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;

    - 变量被定义后，在整个会话周期都有效（登录到退出）


--// 控制结构 ----------
-- if语句
if search_condition then
    statement_list   
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;

-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END


-- while循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];

- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。

    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环


--// 内置函数 ----------
-- 数值函数
abs(x)          -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)         -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)       -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)       -- m^n
sqrt(x)         -- 算术平方根
rand()          -- 随机数
truncate(x, d)  -- 截取d位小数

-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                 -- 当前日期
current_time();                 -- 当前时间
date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分
time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分
date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间
unix_timestamp();               -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间

-- 字符串函数
length(string)          -- string长度，字节
char_length(string)     -- string的字符个数
substring(str, position [,length])      -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])   -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)           -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position]) -- 同instr,但可指定开始位置
lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)           -- 去除前端空格
repeat(string, count)   -- 重复count次
rpad(string, length, pad)   --在str后用pad补充,直到长度为length
rtrim(string)           -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小

-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。

-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()

-- 其他常用函数
md5();
default();


--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体

    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。

-- 删除
    DROP FUNCTION [IF EXISTS] function_name;

-- 查看
    SHOW FUNCTION STATUS LIKE &#39;partten&#39;
    SHOW CREATE FUNCTION function_name;

-- 修改
    ALTER FUNCTION function_name 函数选项


--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。

-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体

参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型

注意，没有返回值。
</code></pre>

<h3 id="toc_24">/ 存储过程 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中

-- 参数
IN|OUT|INOUT 参数名 数据类型
IN      输入：在调用过程中，将数据输入到过程体内部的参数
OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT   输入输出：既可输入，也可输出

-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END
</code></pre>

<h3 id="toc_25">/ 用户和权限管理 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- root密码重置
1. 停止MySQL服务
2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;
    [Windows] mysqld --skip-grant-tables
3. use mysql;
4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;
5. FLUSH PRIVILEGES;

用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES;
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
    GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER   -- 允许使用ALTER TABLE
ALTER ROUTINE   -- 更改或取消已存储的子程序
CREATE  -- 允许使用CREATE TABLE
CREATE ROUTINE  -- 创建已存储的子程序
CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE
CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW     -- 允许使用CREATE VIEW
DELETE  -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE     -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX   -- 允许使用CREATE INDEX和DROP INDEX
INSERT  -- 允许使用INSERT
LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES  -- 未被实施
RELOAD  -- 允许使用FLUSH
REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT  -- 允许使用SELECT
SHOW DATABASES  -- 显示所有数据库
SHOW VIEW   -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE  -- 允许使用UPDATE
USAGE   -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限
</code></pre>

<h3 id="toc_26">/ 表维护 /-----------------------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>

<h3 id="toc_27">/ 杂项 /-------------------------------------</h3>

<pre class="line-numbers"><code class="language-text">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _   任意单个字符
    %   任意多个字符，甚至包括零字符
    单引号需要进行转义 \&#39;
5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628475.html">
                
                  <h1>Anaconda + VSCode 最详细教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，同时也是为了让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<p>现在 Python 的广告可谓铺天盖地，文章、朋友圈、各种网页基本都能看到，虽然有些广告确实夸大了 Python 的作用，标题很雷人，但是无论如何也反映了一种趋势，未来编程思维很重要。而我们看待 Python 等编程语言应保持客观，能够帮到自己那就值得花点时间学习，入门之后才知道是不是自己的菜。</p>

<h2 id="toc_1">「戏」说 Python</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225635.png" alt="img"/></p>

<h2 id="toc_2">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，因为封装成 EXE 不方便调试和更新，同时也是让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<h2 id="toc_3">一、Anaconda 下载</h2>

<p>Anaconda 可以看做Python的一个集成安装，安装它后就默认安装了python、IPython、集成开发环境Spyder和众多的包和模块，让你在管理环境和包时更加方便。</p>

<p>可以选择从官网或清华源下载 Anaconda 安装包，<strong>清华源</strong>下载速度相对较快。</p>

<p>安装的位数推荐32位，兼容性最强，也可以根据自己的系统位数选择安装。</p>

<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anaconda.com%2Fproducts%2Findividual">https://www.anaconda.com/products/individual</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225643.png" alt="img"/></p>

<p>清华源：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fanaconda%2Farchive%2F">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225646.png" alt="img"/></p>

<h2 id="toc_4">二、Anaconda 安装</h2>

<p>安装过程中三个注意的地方：</p>

<ul>
<li>勾选 <code>Alls Users</code></li>
<li>勾选 <code>Add Anaconda to the system PATH environment variable</code></li>
<li>如果之前没有安装 VSCode，可以在 Anaconda 安装过程中选择安装</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225654.gif" alt="img"/></p>

<h2 id="toc_5">三、VSCode 下载安装</h2>

<p>Anaconda 安装过程中 VSCode 有时候可能会出错，导致安装失败，这种情况下可以选择从 VSCode 官网下载安装。</p>

<p>VSCode官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com%2FDownload%23">https://code.visualstudio.com/Download#</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225658.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225700.gif" alt="img"/></p>

<h2 id="toc_6">四、管理 conda</h2>

<h3 id="toc_7">1. 查看 conda 版本</h3>

<p>安装完成后按<code>Win+R</code>打开<code>cmd</code>终端，输入<code>conda --version</code></p>

<p>如果正常输出了 conda 的版本，说明 Anaconda 成功安装了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225704.gif" alt="img"/></p>

<h3 id="toc_8">2. 添加国内源</h3>

<ul>
<li>查看现有源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --show-sources
</code></pre>

<ul>
<li>添加国内清华源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</code></pre>

<ul>
<li>删除默认源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --remove channels defaults
</code></pre>

<ul>
<li>设置搜索时显示通道地址</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --set show_channel_urls yes
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225707.gif" alt="img"/></p>

<h3 id="toc_9">3. 升级 conda</h3>

<p>设置完国内源后，升级 conda 的速度会快很多，之后安装包时也会从国内源下载。</p>

<pre class="line-numbers"><code class="language-text">conda update conda
</code></pre>

<p>升级时弹出<code>Proceed ([y]/n)?</code>时，选择<code>y</code>，确认升级。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225711.gif" alt="img"/></p>

<h2 id="toc_10">五、环境管理</h2>

<p><strong>可跳过，直接用默认环境</strong></p>

<h3 id="toc_11">1. 查看 Python 版本</h3>

<pre class="line-numbers"><code class="language-text">python --version
</code></pre>

<h3 id="toc_12">2. 创建环境</h3>

<p>上一步查到我电脑上的 Python 版本为 3.7.0 ，我想在这个版本基础上创建一个名为 [虚拟环境名] 的虚拟环境。</p>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] python=3.7.0
</code></pre>

<p>新的开发环境会被默认安装在你 conda 目录下的 envs 文件目录下。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225714.gif" alt="img"/></p>

<h3 id="toc_13">3. 激活环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_14">4. 列出所有的环境</h3>

<pre class="line-numbers"><code class="language-text">conda info -e
</code></pre>

<p>当前激活的环境会标<code>*</code>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225718.png" alt="img"/></p>

<h3 id="toc_15">5. 切换到另一个环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_16">6. 注销当前环境（默认的环境是base）</h3>

<pre class="line-numbers"><code class="language-text">deactivate
虚拟环境激活后，在cmd中输入python，显示的就是一个新的环境。
</code></pre>

<h3 id="toc_17">7. 复制环境</h3>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] --clone [参考环境名]

---常用 
conda env --help    #查看帮助
conda env list  #列出所有的虚拟环境
conda list --name [虚拟环境名]   #查看指定虚拟环境下的package

#创建
conda create --name [虚拟环境名] [python的版本] [需要的包]
conda create --name myenv
conda create --name myenv python=2.7
conda create --name myenv pytohon=2.7 numpy scipy

#克隆
conda create --name [虚拟环境名] -- clone [clone的环境]

#创建一个和原python环境一样的虚拟环境
conda create --name mybase --clone base



</code></pre>

<h3 id="toc_18">8. 删除环境</h3>

<pre class="line-numbers"><code class="language-text">conda remove --name [虚拟环境名] -all
</code></pre>

<h2 id="toc_19">六、包管理</h2>

<h3 id="toc_20">1. 查看已安装包</h3>

<pre class="line-numbers"><code class="language-text">conda list
</code></pre>

<h3 id="toc_21">2. 使用 Conda 命令安装包</h3>

<pre class="line-numbers"><code class="language-text">conda install beautifulsoup4
</code></pre>

<h3 id="toc_22">3. 通过 pip 命令来安装包</h3>

<p>如果无法通过conda安装，可以用pip命令来安装包。</p>

<pre class="line-numbers"><code class="language-text">pip install beautifulsoup4
</code></pre>

<h3 id="toc_23">4. 移除包</h3>

<pre class="line-numbers"><code class="language-text">conda remove beautifulsoup4
</code></pre>

<h2 id="toc_24">七、VSCode 配置</h2>

<h3 id="toc_25">1. 安装 Python 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225724.png" alt="img"/></p>

<h3 id="toc_26">2. 安装 Code Runner 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225727.png" alt="img"/></p>

<h3 id="toc_27">3. 安装中文插件（可选）</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225729.png" alt="img"/></p>

<h3 id="toc_28">4. 指定路径（可跳过）</h3>

<p>确定当前激活环境所在路径</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225732.png" alt="img"/></p>

<p>然后在<code>File--&gt;Preferences--&gt;Settings--&gt;Extensions--&gt;Python--&gt;setting.json</code>添加下面的 Python 路径，这个路径和你设置的环境名称有关。</p>

<pre class="line-numbers"><code class="language-text">&quot;python.pythonPath&quot; :&quot;D:\\anaconda3\\envs\\xiaolvshijie\\python.exe&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225734.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225741.png" alt="img"/></p>

<h2 id="toc_29">八、开始运行 Py 文件</h2>

<p>运行代码前一定要按<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>或者用快捷键<code>Ctrl + Alt + N</code>执行代码。</p>

<h3 id="toc_30">1. 运行简单代码测试</h3>

<pre class="line-numbers"><code class="language-text">print(&#39;hello xiaolvshijie&#39;)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225744.gif" alt="img"/></p>

<h3 id="toc_31">2. 运行 Py 文件</h3>

<p>复制下面这段代码到编辑器中，<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>执行代码。</p>

<pre class="line-numbers"><code class="language-python">import prettytable as pt

tb = pt.PrettyTable()
tb.field_names = [&#39;Author&#39;, &#39;wwcheng&#39;]
tb.add_row([&#39;ID&#39;, &#39;xiaolvshijie&#39;])

print(tb)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225753.gif" alt="img"/></p>

<p>会出现报错提示：<code>ModuleNotFoundError: No module named &#39;prettytable&#39;</code></p>

<p>意思是当前环境中缺少<code>prettytable</code>的包，你需要安装这个包。。</p>

<p>我们可以用<code>conda install prettytable</code>或者<code>pip install prettytable</code>来安装这个包。</p>

<p>如果不知道报错提示的意思，可以利用<strong>搜索引擎</strong>，百度一下你就知道，Python编程相关的问题网络上基本都能搜索到。</p>

<h2 id="toc_32">结语</h2>

<p>成功安装 Anaconda 和 VSCode 并运行上面测试代码后，你可以正常加入码农行业。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15838967255194.html">
                
                  <h1>Docker 必备可视化工具 Portainer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>​   推荐使用 Portainer 作为 docker 容器的 GUI 管理方案。</p>

<blockquote>
<p>Portainer 是一个开源、轻量级 Docker 管理用户界面，基于 Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm 集群和服务等集中管理和操作、登录用户管理和控制等功能。</p>
</blockquote>

<p>​   官方地址：<a href="https://portainer.io/install.html">https://portainer.io/install.html</a></p>

<h3 id="toc_0"><strong>安装命令：</strong></h3>

<pre class="line-numbers"><code class="language-text">docker volume create portainer_data
docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>

<p>访问你的 IP:9000 即可进入容器管理页面。如果是本机的话访问地址就是: http:localhost:9000</p>

<h3 id="toc_1"><strong>运行效果:</strong></h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200311114555.jpg" alt="Docker 必备可视化工具"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200311114738.jpg" alt="Docker 必备可视化工具"/></p>

<h3 id="toc_2">参考资料：</h3>

<p>docker：轻量级图形页面管理之 Portainer: <a href="https://blog.51cto.com/ganbing/2083051">https://blog.51cto.com/ganbing/2083051</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631446.html">
                
                  <h1>Git 常用技巧 （高级用法）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><strong>git 的一些「高级」用法</strong></h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312211952.jpg" alt=""/></p>

<h2 id="toc_1"><strong>导航 —— 跳到之前的分支</strong></h2>

<pre class="line-numbers"><code class="language-text">git checkout -
</code></pre>

<h2 id="toc_2"><strong>查看历史</strong></h2>

<pre class="line-numbers"><code class="language-text"># 每个提交在一行内显示
git log --oneline

# 在所有提交日志中搜索包含「homepage」的提交
git log --all --grep=&#39;homepage&#39;

# 获取某人的提交日志
git log --author=&quot;Maxence&quot;
</code></pre>

<h2 id="toc_3"><strong>之前重置了一个不想保留的提交，但是现在又想要回滚？</strong></h2>

<pre class="line-numbers"><code class="language-text"># 获取所有操作历史
git reflog

# 重置到相应提交
git reset HEAD@{4}
# ……或者……
git reset --hard &lt;提交的哈希值&gt;
</code></pre>

<h2 id="toc_4"><strong>我把本地仓库搞得一团糟，应该怎么清理？</strong></h2>

<pre class="line-numbers"><code class="language-text">git fetch origin
git checkout master
git reset --hard origin/master
</code></pre>

<h2 id="toc_5"><strong>查看我的分支和 master 的不同</strong></h2>

<pre class="line-numbers"><code class="language-text">git diff master..my-branch
</code></pre>

<h2 id="toc_6"><strong>定制提交</strong></h2>

<pre class="line-numbers"><code class="language-text"># 编辑上次提交
git commit --amend -m &quot;更好的提交日志&quot;

# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit

# 空提交 —— 可以用来重新触发 CI 构建
git commit --allow-empty -m &quot;chore: re-trigger build&quot;
</code></pre>

<p>​   <strong>squash 提交</strong></p>

<p>​   比方说我想要 rebase 最近 3 个提交：</p>

<p>​   - git rebase -i HEAD~3<br/>
​   - 保留第一行的 pick，剩余提交替换为 squash 或 s<br/>
​   - 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）</p>

<pre class="line-numbers"><code class="language-text">pick 64d26a1 feat: add index.js
s 45f0259 fix: update index.js
s 8b15b0a fix: typo in index.js
</code></pre>

<h2 id="toc_7"><strong>修正</strong></h2>

<p>比方说想在提交 fed14a4c 加上一些内容。</p>

<p><img src="Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7(%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95).assets/4a407484dfb44ea0ad31738ddf673099.jpg" alt=""/></p>

<p><strong>git 提交分支</strong></p>

<pre class="line-numbers"><code class="language-text">git add .
git commit --fixup HEAD~1
# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1

git rebase -i HEAD~3 --autosquash
# 保存并退出文件（VI 中输入 `:wq`）
</code></pre>

<h2 id="toc_8"><strong>rebase 的时候在每个提交上执行命令</strong></h2>

<p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase --exec 命令在每个提交上执行命令。</p>

<pre class="line-numbers"><code class="language-text"># 在最近 3 个提交上运行 `npm test` 命令
git rebase HEAD~3 --exec &quot;npm test&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212414.jpg" alt=""/></p>

<h2 id="toc_9"><strong>暂存</strong></h2>

<p>​   暂存不止是 git stash 和 git stash pop ;)</p>

<pre class="line-numbers"><code class="language-text"># 保存所有正在追踪的文件
git stash save &quot;日志信息&quot;

# 列出所有的暂存项
git stash list

# 获取并删除暂存项
git stash apply stash@{1}
git stash drop stash@{1}
# ……或使用一条命令……
git stash pop stash@{1}
</code></pre>

<h2 id="toc_10"><strong>清理</strong></h2>

<pre class="line-numbers"><code class="language-text"># 移除远程仓库上不存在的分支
git fetch -p

# 移除所有包含 `greenkeeper` 的分支
git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &#39;s/^.\{9\}//&#39; | xargs git push origin --delete
</code></pre>

<h2 id="toc_11"><strong>GitHub = Git + Hub</strong></h2>

<p>我把 Hub 当成 git 的一个封装来用。你如果也想这么做，可以设置一个别名：alias git=&#39;hub&#39;</p>

<pre class="line-numbers"><code class="language-text"># 打开浏览器访问仓库 url（仅限 GitHub 仓库）git browse
</code></pre>

<hr/>

<h2 id="toc_12"><strong>额外福利：我最喜爱的 git 别名</strong></h2>

<pre class="line-numbers"><code class="language-text">alias g=&#39;git&#39;
alias glog=&#39;git log --oneline --decorate --graph&#39;
alias gst=&#39;git status&#39;
alias gp=&#39;git push&#39;
alias ga=&#39;git add&#39;alias gc=&#39;git commit -v&#39;

# 
alias yolo=&#39;git push --force&#39;

# 每周站会汇报工作时用
git-standup() {
    AUTHOR=${AUTHOR:=&quot;`git config user.name`&quot;}

    since=yesterday
    if [[ $(date +%u) == 1 ]] ; then
        since=&quot;2 days ago&quot;
    fi

    git log --all --since &quot;$since&quot; --oneline --author=&quot;$AUTHOR&quot;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629044.html">
                
                  <h1>Git版本管理完全指南（包含常见头疼错误解决方案）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">第一部分 命令行</h1>

<p><strong>1、分支操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git branch 创建分支
2. git checkout -b 创建并切换到新建的分支上
3. git checkout 切换分支
4. git branch 查看分支列表
5. git branch -v 查看所有分支的最后一次操作
6. git branch -vv 查看当前分支
7. git brabch -b 分支名 origin/分支名 创建远程分支到本地
8. git branch --merged 查看别的分支和当前分支合并过的分支
9. git branch --no-merged 查看未与当前分支合并的分支
10. git branch -d 分支名 删除本地分支
11. git branch -D 分支名 强行删除分支
12. git branch origin :分支名 删除远处仓库分支
13. git merge 分支名 合并分支到当前分支上
</code></pre>

<p><strong>2、暂存操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git stash 暂存当前修改
2. git stash apply 恢复最近的一次暂存
3. git stash pop 恢复暂存并删除暂存记录
4. git stash list 查看暂存列表
5. git stash drop 暂存名(例：stash@{0}) 移除某次暂存
6. git stash clear 清除暂存
</code></pre>

<p><strong>3、回退操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git reset --hard HEAD^ 回退到上一个版本
2. git reset --hard ahdhs1(commit_id) 回退到某个版本
3. git checkout -- file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)
4. git reset HEAD file 撤回暂存区的文件修改到工作区
</code></pre>

<p><strong>4、标签操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git tag 标签名 添加标签(默认对当前版本)
2. git tag 标签名 commit_id 对某一提交记录打标签
3. git tag -a 标签名 -m &#39;描述&#39; 创建新标签并增加备注
4. git tag 列出所有标签列表
5. git show 标签名 查看标签信息
6. git tag -d 标签名 删除本地标签
7. git push origin 标签名 推送标签到远程仓库
8. git push origin --tags 推送所有标签到远程仓库
9. git push origin :refs/tags/标签名 从远程仓库中删除标签
</code></pre>

<p><strong>5、其它操作</strong></p>

<p>常规操作</p>

<pre class="line-numbers"><code class="language-text">1. git push origin test 推送本地分支到远程仓库
2. git rm -r --cached 文件/文件夹名字 取消文件被版本控制
3. git reflog 获取执行过的命令
4. git log --graph 查看分支合并图
5. git merge --no-ff -m &#39;合并描述&#39; 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录
6. git check-ignore -v 文件名 查看忽略规则
7. git add -f 文件名 强制将文件提交
8. git reflog 打印所有的日志,假如：ABC三个节点，回退到B后，仍旧打印所有日志
</code></pre>

<p>git创建项目仓库</p>

<pre class="line-numbers"><code class="language-text">1、git init 初始化
2、git remote add origin url 关联远程仓库
3、git pull
4、git fetch 获取远程仓库中所有的分支到本地
</code></pre>

<p>忽略已加入到版本库中的文件</p>

<pre class="line-numbers"><code class="language-text">1、git update-index --assume-unchanged file 忽略单个文件
2、git rm -r --cached 文件/文件夹名字 (. 忽略全部文件)
</code></pre>

<p>取消忽略文件</p>

<pre class="line-numbers"><code class="language-text">git update-index --no-assume-unchanged file
</code></pre>

<p>拉取、上传免密码</p>

<pre class="line-numbers"><code class="language-text">git config --global credential.helper store
</code></pre>

<h1 id="toc_1">第二部分 版本管理</h1>

<p>GitFlow 是由 Vincent Driessen 提出的一个 git操作流程标准。包含如下几个关键分支：</p>

<pre class="line-numbers"><code class="language-text">1. master：主分支develop：主开发分支，包含确定即将发布的代码；
2. feature：新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突；
3. release：发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复；
4. hotfix：热修复分支，紧急修 bug 的时候用。
</code></pre>

<p>GitFlow 的优势有如下几点：</p>

<pre class="line-numbers"><code class="language-text">1. 并行开发：GitFlow可以很方便的实现并行开发。每个新功能都会建立一个新的 feature分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature分支才会合并到主开发分支上（也就是我们经常说的develop分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个feature 分支并完成新功能开发。然后再切回之前的 feature 分支即可继续完成之前功能的开发。
2. 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。
3. 发布阶段：当一个新 feature 开发完成的时候，它会被合并到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature 。
4. 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的 tag，而不会影响到你正在开发的新 feature。
</code></pre>

<blockquote>
<p>然后就是 GitFlow 最经典的几张流程图，一定要理解:</p>
</blockquote>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223014" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p><strong>feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上，等待发布</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223020" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>当需要发布时，我们从 develop 分支创建一个 release 分支</p>

<p>然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会<strong>不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223022" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>发布结束后，这个<strong>release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223025" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。</p>

<p>hotfix 分支的作用是紧急修复一些 Bug。它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分支上。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223027" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<h1 id="toc_2">第三部分 Git常见错误汇总</h1>

<p><strong>常见错误1、windows使用git时出现：warning:LF will be replaced by CRLF</strong></p>

<p>windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</p>

<ol>
<li>$ rm -rf .git // 删除.git</li>
<li>$ git config --global core.autocrlf false //禁用自动转换</li>
</ol>

<p>然后重新执行：</p>

<ol>
<li>$ git init</li>
<li>$ git add .</li>
</ol>

<p><strong>常见错误2、git push origin master出错：error:failed to push sonme refs to...</strong></p>

<p>很明显是：</p>

<p>本地没有update到最新版本的项目（git上有README.md文件没下载下来）</p>

<p>本地直接push所以会出错。</p>

<p>【解决过程】</p>

<blockquote>
<p>看到提示里面，感觉是本地的代码不是最新的。</p>

<p>所以觉得应该是类似于svn中的，先update一下，再去commit，估计就可以了。</p>

<p>所以先去pull试试：</p>

<p>git pull --rebase origin master</p>
</blockquote>

<p>解决！</p>

<p><strong>常见错误3、fatal: remote origin already exists.</strong></p>

<p>解决办法如下：</p>

<blockquote>
<p>1、先输入$ git remote rm origin</p>

<p>2、再输入$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:djqiang/gitdemo.git 就不会报错了！</p>

<p>3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section &#39;remote.origin&#39;. 我们需要修改gitconfig文件的内容</p>

<p>4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc</p>

<p>5、找到一个名为gitconfig的文件，打开它把里面的[remote &quot;origin&quot;]那一行删掉就好了！</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15838967255217.html">
                
                  <h1>Linux vim 编辑器的神级配置 vimrc</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">使用的配置</h2>

<pre class="line-numbers"><code class="language-linux">https://github.com/amix/vimrc
</code></pre>

<h2 id="toc_1">安装很简单</h2>

<pre class="line-numbers"><code class="language-linux">git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime
sh ~/.vim_runtime/install_awesome_vimrc.sh
</code></pre>

<h2 id="toc_2">ack 插件</h2>

<p>常用命令</p>

<pre class="line-numbers"><code class="language-linux">系统需要安装 ack-grep, ubuntu安装命令：sudo apt-get install ack-grep
</code></pre>

<ol>
<li>全局查找文件(ctrlp插件)<br/>
  <code>ctrl + f</code>  --打开全局文件搜索面板<br/>
  <code>Esc</code> --退出全局文件搜索面板</li>
<li>tab(标签)相关<br/>
  <code>gt</code> --后一个标签<br/>
  <code>gT</code> --前一个标签<br/>
  <code>num</code> + gt --跳转至第num个标签<br/>
  <code>,tl</code> --上一次的标签<br/>
  <code>:q</code> --关闭标签<br/>
  <code>:Te</code> --新建标签，并打开当前文件目录<br/>
  <code>,tn</code> --新建空白标签</li>
<li>目录树(NERD_tree插件)<br/>
  <code>,nn</code> --打开目录树<br/>
  <code>,nn</code> --关闭目录树</li>
<li>窗口相关<br/>
  <code>ctrl + w + q</code> --关闭窗口<br/>
  <code>:q</code> --关闭窗口，窗口只有一个tab的情况<br/>
  <code>ctrl + w + w</code> --切换窗口<br/>
  <code>:sp</code> --竖直方向上拆分当前窗口<br/>
  <code>:vsp</code> --水平方向上拆分当前窗口</li>
<li>如何打开一个工程<br/>
  在某个工程的根目录下输入打开vim，则该vim窗口的文件操作默认为整个工程，比如全局搜索文件或字段</li>
<li>全局搜索字段(ack插件)<br/>
  <code>,g</code> --打开全局字段搜索面板，默认大小写敏感，-i 不区分大小写，-w 全词匹配<br/>
  <code>q</code> --退出全局字段搜索面板</li>
<li>当前文件所在的目录<br/>
  <code>:E</code> --打开当前目录，一般用于切换当前目录的文件<br/>
  <code>:Te</code> --新建标签并打开当前目录，一般用于打开当前目录下的其它文件<br/></li>
<li>查看最近打开的文件列表<br/>
  <code>,f</code> --打开面板<br/>
  <code>q</code> --退出面板</li>
<li>当前文件下搜索<br/>
  <code>*</code>--按下即可搜索光标所在的单词或当前选中的内容，不区分大小写<br/>
  <code>gd</code> --光标移动至单词，按下即可搜索该单词，区分大小写<br/>
  <code>/</code> --输入单词向下搜索<br/>
  <code>?</code> --输入单词向上搜索，一般用于查log，配合G跳转至文件底部使</li>
<li>显示行修改标志<br/>
  <code>,d</code> --显示与不显示逐一切换</li>
<li>光标停留的位置记录<br/>
  <code>ctrl + o</code> --上一个时间点光标停留的位置<br/>
  <code>ctrl + i</code> --下一个时间点光标停留的位置</li>
<li>文件刷新，即重新载入<br/>
  <code>:e</code> --重新载入<br/>
  <code>:e!</code> --放弃当前修改，强制重新载入<br/>
  <code>:e file_dir</code> --载入 file_dir 路径下的某个文件</li>
<li>粘贴0号寄存器的内容<br/>
  <code>ctrl + r + 0</code> --比如y复制选中的内容后粘贴到命令输入框</li>
<li>折叠命令<br/>
  <code>za</code> --打开或关闭当前折叠<br/>
  <code>zM</code> --关闭所有折叠<br/>
  <code>zR</code> --打开所有折叠</li>
<li>跳出双引号继续编辑<br/>
  有些时候输入完字符串需要移动光标至双引号外继续输入<br/>
  <code>&quot;</code> --在 &quot; 处输入 &quot; ，即可将光标跳转至当前双引号之外</li>
<li>文件路径<br/>
  <code>:f</code> --查看当前文件路径</li>
<li>变量名补全<br/>
  <code>ctrl + n</code> --自动补全变量名，再次输入匹配下一个</li>
<li>代码块补全，只需输入部分代码，然后按tab键<br/>
  lua为例：<br/>
  <code>if + tab</code> --if代码块<br/>
  <code>forp + tab</code> --for i,v in pairs() do end 代码块<br/>
  <code>fori + tab</code> --for i,v in ipairs() do end 代码块<br/>
  <code>fun + tab</code> --函数模板代码块</li>
<li>代码检错<br/>
  <code>:ALEToggle</code> --启动检错</li>
<li>代码注释<br/>
  <code>gcc</code> --注释当前行，再次输入则撤销注释<br/>
  <code>num + gcc</code> --注释num行<br/>
  <code>gc</code> --注释选中部分</li>
<li>取消搜索高亮<br/>
  <code>:nohl</code></li>
<li>多窗口显示<br/>
  <code>:sp</code> --水平切分窗口<br/>
  <code>:vsp</code> --垂直切分窗口<br/>
## vim 编辑相关</li>
<li>范围命令
<code>w</code> --光标所在的位置至单词末尾的部分或一个单词，包括单词后的空格
<code>iw</code> --光标所在位置的一个单词，不包括单词后的空格
<code>aw</code> --光标所在位置的一个单词，包括单词后的空格
<code>b</code> --与 w 相反
<code>e</code> --end of word，至单词结尾
<code>$</code> --至当前行结尾
<code>0</code> --至当前行开头</li>
<li>操作命令
<code>d</code>: delete
<code>dd</code> --删除当前行
<code>diw</code> --删除光标所在单词
<code>dw</code> --正向删除一个单词（光标后的部分）
<code>db</code> --逆向删除一个单词（光标前的部分）
<code>d$</code> --删除光标所在的位置至本行末尾
<code>d0</code> --删除光标所在的位置至本行首部
<code>c</code>: change, 与 d 的区别只在于操作后进入插入状态
<code>y</code>: yank, 与 d 的区别在于跟范围命令组合后全部为复制操作</li>
<li>操作命令（少与范围命令组合）
<code>~</code> --大小写字母转换
<code>s</code> --删除一个字母，删除后进入插入模式
<code>x</code> --删除一个字母，删除后处于命令模式
<code>r</code> --即replace，修改替换一个字母，并且替换过后仍然处于命令模式
<code>R</code> --修改替换无限多个在字母</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628522.html">
                
                  <h1>Linux系统/etc目录和文件的介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Linux目录结构特点</strong></p>

<ol>
<li>linux系统的所有目录是一个有层次的倒着的梳妆目录结构。根是所有目录的顶点，linux目录一切从根开始。</li>
<li>不听目录下的数据可以跨越不同的磁盘分区火不同的磁盘设备，设备可以随意挂载到任意目录上使用。</li>
<li>所有的目录的是安装一定类型有龟裂的组织和命名的。</li>
<li>没有挂载到目录上的磁盘，相当于没有门和串户的监狱，不能被使用。磁盘等设备de需要挂载菜能正常使用。</li>
<li>盖章点是磁盘访问的人口，是一个目录</li>
<li>相对路径与绝对路径</li>
</ol>

<p><strong>Linux目录结构</strong></p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# tree -L 1 /
/
├── bin             #普通用户的二进制命令
├── boot            #系统内核及引导程序目录
├── dev             #设备文件目录
├── etc             #软件配置和启动程序目录
├── home            #普通用户家目录
├── lib             #库文件目录(命令、软件)
├── lib64           #64位库文件目录(命令、软件)
├── lost+found      #系统崩溃数据存放的目录
├── media
├── mnt             #设备临时挂载目录
├── opt             #第三方程序
├── proc            #操作系统进程和内核信息目录
├── root            #root家目录
├── sbin            #系统管理员命令
├── selinux         
├── srv
├── sys
├── tmp             #文件临时存放目录(回收站)
├── usr             #应用程序目录
└── var             #日志目录
#查看命令的路径
[root@test ~]# which ls
alias ls=&#39;ls --color=auto&#39;
    /bin/ls
</code></pre>

<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>/bin</td>
<td>该目录为binaries,是常用二进制命令所在的目录。列入：ls、cp、mkdir、rm等命令；/bin目录和/usr/bin类似</td>
</tr>
<tr>
<td>/boot</td>
<td>Linux的内核级系统引导程序所需的文件目录，安装系统分区的时候一般单独分一个boot分区。</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件目录，比如声卡、磁盘、光驱等等外接设备。</td>
</tr>
<tr>
<td>/etc</td>
<td>(1)二进制软件安装包(yum,rpm)等的配置文件默认路径，例如:/etc/exports、/etc/fstab、/etc/resolv.conf (2)服务启动命令存放的目录，主要在/etc/init.d/下。例如：/etc/init.d/sshd、/etc/init.d/iptables</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录默认数据库存放目录</td>
</tr>
<tr>
<td>/lib</td>
<td>启动系统和运行命令所需要的共享库文件和内核模块存放目录，分为/lib和/lib64两种。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题，可能会有文件被移到这个目录中，可能需要手工方式修复，移到文件到原来的位置上。</td>
</tr>
<tr>
<td>/mnt</td>
<td>一般是用于临时挂载存储设备的挂载点，比如有cdrom，u盘等目录。直接插入光驱无法使用，需要先挂载后使用。</td>
</tr>
<tr>
<td>/opt</td>
<td>表示的是可选择的意思，有邪软件包会被安装在这里，也就是自定义软件包。我们自己编译的软件包，就可以安装在这个目录；通过源码包安装的软件，可以通过./configure --prefix=/opt/指定目录。</td>
</tr>
<tr>
<td>/proc</td>
<td>操作系统运行时，进程信息及内核信息(cpu、硬盘信息、内存信息)存放在这里。/proc目录是虚拟文件系统的挂载点，proc并不是真正的文件系统，它的定义可以参见/etc/fstab。系统运行很多信息都在这个目录下。 /proc/loadavg #系统负载信息 /proc/meminfo #系统内存信息 /proc/cpuinfo #系统CPU信息 /proc/mounts #系统挂载信息</td>
</tr>
<tr>
<td>/root</td>
<td>Linux超级权限用户root的加目录:root类似win32管理员admininstrator</td>
</tr>
<tr>
<td>/sbin</td>
<td>大多是涉及系统管理的命令存放，是超级权限用户root的可执行命令存放地，这个目录和/usr/X11R6/sbin或/usr/loacl/sbin目录是相似的;系统级命令，一般最好要通过sudo让普通用户执行这些命令，常见命令有fdisk、reboot、fsck、halt</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录，有时用户运行程序时候，会产生临时文件。/tmp就用来存放临时文件的，权限比较特殊。/var/tmp目录和这个目录相似，这个目录可以被用作Linux系统的回收站使用。</td>
</tr>
<tr>
<td>/usr</td>
<td>这是系统存放程序的目录，比如命令，帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux官方提供的软件包时，安装在这里。 /user/local：默认软件安装目录 /usr/src:长袖源码目录</td>
</tr>
<tr>
<td>/var</td>
<td>日志目录</td>
</tr>
</tbody>
</table>

<hr/>

<p><strong>Linux系统重要文件</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align: center">网卡配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0 #第一块网卡逻辑设备名，第二块为eth1
HWADDR=00:0c:29:6a:a3:b4 #以太网硬件地址MAC地址
TYPE=Ethernet #上网类型，目前基本上是以太网
UUID=282f8f61-2b18-4cdb-8ba5-62c8131abd20 #通用唯一识别码
ONBOOT=yes  #开机启动激活网卡设备yes(启动) no(不启动)
NM_CONTROLLED=yes #是否通过networkmanager管理网卡设备
BOOTPROTO=none  #启动协议，获取配置方式，有none|bootp|dhcp 三个选项
IPADDR=10.0.0.7 #IP地址
NETMASK=255.255.255.0 #子网掩码
DNS2=202.106.0.20   #DNS2
GATEWAY=10.0.0.2    #网关
DNS1=10.0.0.2       #DNS1
USERCTL=no          #是否支持用户控制
PEERDNS=yes         #网卡配置DNS 会覆盖/etc/resolv.conf文件的DNS
IPV6INIT=no         #是否支持IPv6
</code></pre>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/resolv.conf</td>
<td style="text-align: center">系统DNS客户端配置文件</td>
</tr>
</tbody>
</table>

<p>DNS,全称Domain Name System，一个网站运行中起到至关重要的作用，它的主要作用是负责吧网站域名解析为对应的IP地址。</p>

<p>DNS系统解析功能：</p>

<ul>
<li> (1)DNS 系统负责A记录解析，就是域名到IP。</li>
<li> (2)设置CNAME别名记录，这别名解析功能常被CDN加速服务商应用</li>
<li> (3)设置MX邮件记录，这个记录功能，在购买或搭建邮件服务时会经常被用到</li>
<li> (4)设置PTR 记录，反向解析，即吧IP地址解析为对应域名和A记录的解析相反，邮寄服务等业务会用到</li>
</ul>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/resolv.conf

nameserver 10.0.0.2
nameserver 202.106.0.20
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network</td>
<td style="text-align: center">主机名配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test
</code></pre>

<p>修改方法：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test1 #永久修改
[root@test ~]# hostname test1 临时修改
#企业环境永久修改生效需要重启服务器基本的是永久加上临时二个方法配合使用需要操作两次，为了不重启
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.local</td>
<td style="text-align: center">存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>/etc/rc.local是用于存放开机自启动程序命令的文件(chkconfig常用来管理yum/rpm安装的程序服务的开机自启动)如果是开发的自己程序需要开机启动命令放入/etc/rc.local来实现开机自启动，Linux开机会吧/etc/rc.local里面的内容全部执行一遍。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/hosts</td>
<td style="text-align: center">局域网或者本地DNS解析工具</td>
</tr>
</tbody>
</table>

<p>应用场景：</p>

<ol>
<li>域名对应服务所在的服务器出现IP变化时候</li>
<li>进行本地测试</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/fstab</td>
<td>配置开机实现设备自动挂载程序命令的文件</td>
</tr>
</tbody>
</table>

<p>添加新的磁盘后实现开机自动挂载设备：cat /etc/fstab共六列如下：</p>

<p>例：sysfs /sys sysfs defaults 0 0</p>

<ol>
<li>第一列sysfs (挂载的设备名称)</li>
<li>第二列/sys(挂载的目录)</li>
<li>第三列sysfs(挂载的文件系统格式)</li>
<li>第四列defaults(挂载参数)</li>
<li>第五列0(是否备份:0为不备份，1为备份)</li>
<li>第六列0(是否开机做磁盘检测，0为不检测数字1,2的为检测磁盘)，工作场景通常的设为了，为了避免重启无法启动。</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.loacl</td>
<td>存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>企业中主要应用：脚本和自主开发程序启动命令存放处，实现开机程序自动启动和运行。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/inittab</td>
<td>系统运行级别的配置文件</td>
</tr>
</tbody>
</table>

<p>0 - halt (Do NOT set initdefault to this)： (<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%85%B3%E6%9C%BA%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{关机模式}"/>)</p>

<p>1 - Single user mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{单用户模式}"/>)</p>

<p>2 - Multiuser, without NFS (The same as 3, if you do not have networking):(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FNFS%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{没有网络文件系统NFS的多用户模式}"/>)</p>

<p>3 - Full multiuser mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{完整的多用户模式}"/>)</p>

<p>4 - unused：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%9C%AA%E4%BD%BF%E7%94%A8%7D" alt="\color{green}{未使用}"/>)</p>

<p>5 - X11：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{桌面模式}"/>)</p>

<p>6 - reboot (Do NOT set initdefault to this)：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E9%87%8D%E5%90%AF%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{重启模式}"/>)</p>

<p>查看当前的运行级别：runlevel</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# runlevel 
N 3
#N是上一次运行级别，3是当前运行级别
</code></pre>

<p>切换运行级别：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# init 5
[root@test ~]# runlevel 
3 5
#init 命令接后面的数字级别
</code></pre>

<p>开机启动流程图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234025.png" alt="img"/></p>

<p>Linux系统启动配置文件：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/grub.conf 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda3
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.32-754.30.2.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-754.30.2.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-754.30.2.el6.x86_64.img
title CentOS 6 (2.6.32-696.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-696.el6.x86_64.img
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile及/etc/bashrc(~/.bashrc)</td>
<td>配置系统的环境变量/别名文件</td>
</tr>
</tbody>
</table>

<p>企业环境设置案例：</p>

<pre class="line-numbers"><code class="language-shell">#环境变量设置：
vim /etc/profile

#set java environment
JAVA_HOME=/usr/local/java/jdk1.8.0_161
JRE_HOME=$JAVA_HOME/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
#重新加载/etc/profile文件，让配置生效
source /etc/profile
#测试安装是否成功
java -version

#系统别名设置:
# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
#让系统别名永久生效，需要配置到的文件
</code></pre>

<p>环境变量文件生效顺序图：/etc/bashrc &gt; ~/.bashrc &gt; ~/bash_profile &gt; /etc/profile</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234032.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile.d</td>
<td>用户登录后执行的脚本所在目录</td>
</tr>
</tbody>
</table>

<ol>
<li>在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，而这些脚本文件是用来设置一些变量和运行一些初始化过程的。其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</li>
<li>/etc/profile.d 下的脚本之所以能自动执行，是因为在/etc/profile 中有一个for循环语句来调用这些脚本。</li>
</ol>

<pre class="line-numbers"><code class="language-shell">vi /etc/profile
# /etc/profile
 
for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r &quot;$i&quot; ]; then
        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then
            . &quot;$i&quot;
        else
            . &quot;$i&quot; &gt;/dev/null
        fi
    fi
done
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/issue和/etc/issue.net</td>
<td>配置在用户登录终端前显示信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
.............................................................................
[root@test ~]# cat /etc/issue.net 
CentOS release 6.10 (Final)
Kernel \r on an \m
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/init.d</td>
<td>软件启动和程序所在的目录</td>
</tr>
</tbody>
</table>

<p>/etc/init.d目录在Linux系统中可是大名鼎鼎。它只负责一件事情，但却涉及到全系统。它包含系统中各种服务的start/stop脚本，从acpid到x11-common，其重要性可见一斑。在/etc/init.d的可执行程序的优先级会高于/etc/systemd/system/下的service文件，如果同时存在的话。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/motd</td>
<td>配置用户登录系统之后显示提示内容的文件</td>
</tr>
</tbody>
</table>

<p>配置案例：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/motd 
[root@test ~]# vim /etc/motd
test computer
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234041.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/redhat-release</td>
<td>声明Red Hat版本和名称信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/redhat-release 
CentOS release 6.10 (Final)
</code></pre>

<p>禁止转载，如需转载请通过简信或评论联系作者。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15839100648693.html">
                
                  <h1>MAC 安装好后的一些配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">改变vim配色：安装colorscheme</h1>

<blockquote>
<ol>
<li>在当前用户目录 ~/ 下的 .vim 目录(如果没有，mkdir ~/.vim进行新建该目录)。在 ~/.vim/ 下新建一个叫 colors 的目录，将配色方案.vim文件便放到该目录下。</li>
<li>编辑vim的配置文件.vimrc  (vi .vimrc)在其中添加下面2行</li>
</ol>
</blockquote>

<pre class="line-numbers"><code class="language-text">set t_Co=256 
colorscheme desert
</code></pre>

<h1 id="toc_1">使用 Solarized 配色方案的方法</h1>

<pre class="line-numbers"><code class="language-text">$ git clone git://github.com/altercation/solarized.git
</code></pre>

<blockquote>
<ul>
<li>Terminal 的话，在 solarized/osx-terminal.app-colors-solarized 下双击 Solarized Dark ansi.terminal 和 Solarized Light ansi.terminal 就会自动导入两种配色方案 Dark 和 Light 到 Terminal.app 里。</li>
<li>iTerm2 的话，到 solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm 里。</li>
<li>vim </li>
</ul>
</blockquote>

<pre class="line-numbers"><code class="language-text">    $ cd solarized
    $ cd vim-colors-solarized/colors
    $ mkdir -p ~/.vim/colors
    $ cp solarized.vim ~/.vim/colors/
    $ vi ~/.vimrc
    syntax on
    set background=dark
    colorscheme solarized
</code></pre>

<h1 id="toc_2">Mac 访达标题栏显示详细目录</h1>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
killall Finder
</code></pre>

<h1 id="toc_3">禁止.DS_Store生成</h1>

<p>打开 “终端”，执行下列命令，重启Mac生效：</p>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE
</code></pre>

<h1 id="toc_4">恢复.DS_Store生成</h1>

<pre class="line-numbers"><code class="language-text">defaults delete com.apple.desktopservices DSDontWriteNetworkStores
</code></pre>

<h1 id="toc_5">删除现有的.DS_Store</h1>

<blockquote>
<p>对已经生成的文件还需要你手动删除：</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">sudo find / -name &quot;.DS_Store&quot; -depth -exec rm {} \;
</code></pre>

<h1 id="toc_6">Mac Launchpad(启动台）图标大小调整</h1>

<blockquote>
<p>1 、调整每一列显示图标数量，10表示每一列显示10个，比较不错，可根据个人喜好进行设置。 <br/>
<code>defaults write com.apple.dock springboard-rows -int 10</code><br/>
2、调整多少行显示图标数量 <br/>
<code>defaults write com.apple.dock springboard-rows -int 8</code><br/>
3、重置Launchpad<br/>
<code>defaults write com.apple.dock ResetLaunchPad -bool TRUE</code><br/>
4、重启Dock<br/>
<code>killall Dock</code><br/>
恢复默认设置的方法。<br/>
 以下是恢复默认大小的命令（在Terminal执行即可）：</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.dock springboard-rows Default
defaults write com.apple.dock springboard-columns Default
defaults write com.apple.dock ResetLaunchPad -bool TRUE
killall Dock
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631366.html">
                
                  <h1>MWeb + Github Pages 搭建个人博客/静态网站</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1、打开GitHub Pages</h2>

<p>链接<a href="https://pages.github.com/">https://pages.github.com/</a> ，可以直接按照上面的操作指引来操作</p>

<p>(1)创建 github repository</p>

<p>官网说明如下图，需要先注册登录GitHub，然后创建repository，命名方式为<a href="http://username.github.io/">http://username.github.io</a>，注意用户名(前后两个输入框)保持一致。</p>

<p><img src="media/15998025631366/v2-2a7bdd7a71db76912f5c70db4b8e042e_720w.jpg" alt="img"/></p>

<p>（2）git client</p>

<p>我使用了桌面客户端（下载链接 <a href="https://desktop.github.com/">https://desktop.github.com</a> ）</p>

<p><img src="media/15998025631366/v2-9029512a20bea6a74ff6e661b1ed554c_720w.jpg" alt="img"/></p>

<p>（3）下载 GitHub desktop 并登录，选择你创建的repository，并点击clone按钮。然后就可以看到本地的克隆文件的路径。</p>

<p><img src="media/15998025631366/v2-416a3d6414b387d21ea3dcc584960298_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-02f99763a4d07e5120d6b16e0943756b_720w.jpg" alt="img"/></p>

<h2 id="toc_1">2、下面先转到MWeb这里，下载并使用MWeb创建静态网页</h2>

<p>MWeb是一个简单易用的markdown工具，还可以生成静态网站，不过要付费。</p>

<p>（1）首先左下角新增静态网站分类</p>

<p><img src="media/15998025631366/v2-f0d346f5cce89cfc883f55608ce7d9e5_720w.jpg" alt="img"/></p>

<p>（2）对这个站点的名称、模版等进行设置</p>

<p><img src="media/15998025631366/v2-f802de2a62db871c817d2e8206ff095e_720w.jpg" alt="img"/></p>

<p>（3）在里面写一篇文章，然后选择生成网站</p>

<p><img src="media/15998025631366/v2-47cbf01ada99ca1f078774154bef5dc5_720w.jpg" alt="img"/></p>

<p>(4)生成网站后，还是在这个下拉菜单中选择“在finder中显示网站生成位置”，就会定位到本地文稿所在位置。</p>

<p><img src="media/15998025631366/v2-186318f6b291d3874d16b8da45b575a1_720w.jpg" alt="img"/></p>

<p>(5)将这里的所有文件复制到 github在本地的克隆文件中</p>

<h2 id="toc_2">3、最后一步，文件上传与同步</h2>

<p>打开GitHub desktop，左边栏中就是我们要同步的新增文件。点击左下的commit，然后点击右上角的push按钮。这样就OK了，你可以访问一下你的网站（<a href="http://username.github.io/">http://username.github.io</a>）看看效果了～</p>

<p><img src="media/15998025631366/v2-89721201dd82fec5937c581099a43303_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-d2dede1032356af70fa032dd52076aa3_720w.jpg" alt="img"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15845003776446.html">
                
                  <h1>Mac下find命令常用语法总结</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Mac的文件管理是很难用，所以有些时候搜索东西我宁愿用命令的方式，便在此总结一下常用的。<br/>
首先，可以用</p>

<pre class="line-numbers"><code class="language-text">man find
</code></pre>

<p>查看find命令的种种选项和用法。全英文的，我知道绝大多数人肯定不爱看。于是我看了这个之后，结合自己的一些实践，总结了一些常用的方法。并且把全文附在了本文末尾。</p>

<h4 id="toc_0">概述：</h4>

<p>find命令递归地为列出的每个路径下拉目录树，根据树中的每个文件计算表达式(由下面列出的&#39;&#39; primary &#39;和&#39;&#39; operands&#39;组成)。</p>

<h4 id="toc_1">基本操作：</h4>

<pre class="line-numbers"><code class="language-text">find 文件路径 参数
</code></pre>

<h4 id="toc_2">例子：</h4>

<ol>
<li> 在当前目录下(包含子目录)搜索文件名包含cynthia的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -name &quot;cynthia&quot;
</code></pre>

<ol>
<li> 搜索文件后缀不是.py的文件并打印出来。注意这里!的用法，用了转义符\</li>
</ol>

<pre class="line-numbers"><code class="language-text">find ~/Cynthia/ \! -name &quot;*.py&quot; -print
</code></pre>

<ol>
<li> 类似的，上面是搜索文件后缀是.py的文件</li>
</ol>

<pre class="line-numbers"><code class="language-text">find ~/Cynthia/ -name &quot;*.py&quot; -print
</code></pre>

<ol>
<li> 在当前目录下，搜索属于用户cynthia，且比文件190505demo的时间新的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -newer 190505demo -user cynthia -print
</code></pre>

<ol>
<li> 类似的，下面这个命令就是搜索既不属于用户cynthia也不比文件190505demo的时间新的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . \! \( -newer 190505demo -user cynthia \) -print
</code></pre>

<ol>
<li> 打印出当前目录下的所有文件</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -type f -exec echo {} \;
</code></pre>

<h4 id="toc_3">附录</h4>

<p>man find命令给出的全文。</p>

<pre class="line-numbers"><code class="language-text">Cynthias-MacBook-Pro:/ cynthia$ man find
NAME
     find -- walk a file hierarchy

SYNOPSIS
     find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]
     find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]

DESCRIPTION
     The find utility recursively descends the directory tree for each path listed, evaluating an expression (composed of the ``primaries&#39;&#39; and ``operands&#39;&#39; listed below) in terms of each file in the tree.

     The options are as follows:

     -E      Interpret regular expressions followed by -regex and -iregex primaries as extended (modern) regular expressions rather than basic regular expressions (BRE&#39;s).  The re_format(7) manual page fully describes both formats.

     -H      Cause the file information and file type (see stat(2)) returned for each symbolic link specified on the command line to be those of the file referenced by the link, not the link itself.  If the referenced file does not exist, the file information and type will be for the link itself.  File information of all symbolic links not on the command line is that of the link itself.

     -L      Cause the file information and file type (see stat(2)) returned for each symbolic link to be those of the file referenced by the link, not the link itself.  If the referenced ile does not exist, the file information and type will be for the link itself.

             This option is equivalent to the deprecated -follow primary.

     -P      Cause the file information and file type (see stat(2)) returned for each symbolic link to be those of the link itself.  This is the default.

     -X      Permit find to be safely used in conjunction with xargs(1).  If a file name contains any of the delimiting characters used by xargs(1), a diagnostic message is displayed on standard error, and the file is skipped.  The delimiting characters include single (`` &#39; &#39;&#39;) and double (`` &quot; &#39;&#39;) quotes, backslash (``\&#39;&#39;), space, tab and newline characters.

             However, you may wish to consider the -print0 primary in conjunction with ``xargs -0&#39;&#39; as an effective alternative.

     -d      Cause find to perform a depth-first traversal, i.e., directories are visited in postorder and all entries in a directory will be acted on before the directory itself.  By default, find visits directories in pre-order, i.e., before their contents.  Note, the default is not a breadth-first traversal.

             This option is equivalent to the -depth primary of IEEE Std 1003.1-2001 (``POSIX.1&#39;&#39;).
             The -d option can be useful when find is used with cpio(1) to process files that are contained in directories with unusual permissions.  It ensures that you have write permission while you are placing files in a directory, then sets the directory&#39;s permissions as the last thing.

     -f      Specify a file hierarchy for find to traverse.  File hierarchies may also be specified as the operands immediately following the options.

     -s      Cause find to traverse the file hierarchies in lexicographical order, i.e., alphabetical order within each directory.  Note: `find -s&#39; and `find | sort&#39; may give different results.

     -x      Prevent find from descending into directories that have a device number different than that of the file from which the descent began.

             This option is equivalent to the deprecated -xdev primary.

PRIMARIES
     All primaries which take a numeric argument allow the number to be preceded by a plus sign (``+&#39;&#39;) or a minus sign (``-&#39;&#39;).  A preceding plus sign means ``more than n&#39;&#39;, a preceding minus sign means ``less than n&#39;&#39; and neither means ``exactly n&#39;&#39;.

     -Bmin n
             True if the difference between the time of a file&#39;s inode creation and the time find was started, rounded up to the next full minute, is n minutes.

     -Bnewer file
             Same as -newerBm.

     -Btime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the time of a file&#39;s inode creation and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the time of a file&#39;s inode creation and the time find was started is exactly n units.
             Please refer to the -atime primary description for information on supported time units.

     -acl    May be used in conjunction with other primaries to locate files with extended ACLs.
             See acl(3) for more information.

     -amin n
             True if the difference between the file last access time and the time find was started, rounded up to the next full minute, is n minutes.

     -anewer file
             Same as -neweram.

     -atime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the file last access time and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the file last access time and the time find was started is exactly n units.  Possible time units are as follows:

             s       second
             m       minute (60 seconds)
             h       hour (60 minutes)
             d       day (24 hours)
             w       week (7 days)

             Any number of units may be combined in one -atime argument, for example, ``-atime -1h30m&#39;&#39;.  Units are probably only useful when used in conjunction with the + or - modfier.

     -cmin n
             True if the difference between the time of last change of file status information and the time find was started, rounded up to the next full minute, is n minutes.

     -cnewer file
             Same as -newercm.

     -ctime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the ime of last change of file status information and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the time of last change of file status information and the time find was started is exactly n units.  Please refer to the -atime primary description for information on supported time units.

     -d      Same as depth.  GNU find implements this as a primary in mistaken emulation of FreeBSD
             find(1).

     -delete
             Delete found files and/or directories.  Always returns true.  This executes from the current working directory as find recurses down the tree.  It will not attempt to delete a filename with a ``/&#39;&#39; character in its pathname relative to ``.&#39;&#39; for security reasons.  Depth-first traversal processing is implied by this option.  Following syminks is incompatible with this option.

     -depth  Always true; same as the -d option.

     -depth n
             True if the depth of the file relative to the starting point of the traversal is n.

     -empty  True if the current file or directory is empty.

     -exec utility [argument ...] ;
             True if the program named utility returns a zero value as its exit status.  Optional arguments may be passed to the utility.  The expression must be terminated by a semicolon (``;&#39;&#39;).  If you invoke find from a shell you may need to quote the semicolon if
             the shell would otherwise treat it as a control operator.  If the string ``{}&#39;&#39; appears anywhere in the utility name or the arguments it is replaced by the pathname of the current file.  Utility will be executed from the directory from which find was executed.  Utility and arguments are not subject to the further expansion of shell patterns and constructs.

     -exec utility [argument ...] {} +
             Same as -exec, except that ``{}&#39;&#39; is replaced with as many pathnames as possible for each invocation of utility.  This behaviour is similar to that of xargs(1).

     -execdir utility [argument ...] ;
             The -execdir primary is identical to the -exec primary with the exception that utility will be executed from the directory that holds the current file.  The filename substituted for the string ``{}&#39;&#39; is not qualified.

     -execdir utility [argument ...] {} +
             Same as -execdir, except that ``{}&#39;&#39; is replaced with as many pathnames as possible for each invocation of utility.  This behaviour is similar to that of xargs(1).

     -flags [-|+]flags,notflags
             The flags are specified using symbolic names (see chflags(1)).  Those with the &quot;no&quot; refix (except &quot;nodump&quot;) are said to be notflags.  Flags in flags are checked to be set, and flags in notflags are checked to be not set.  Note that this is different from
             -perm, which only allows the user to specify mode bits that are set.

             If flags are preceded by a dash (``-&#39;&#39;), this primary evaluates to true if at least all of the bits in flags and none of the bits in notflags are set in the file&#39;s flags bits.
             If flags are preceded by a plus (``+&#39;&#39;), this primary evaluates to true if any of the bits in flags is set in the file&#39;s flags bits, or any of the bits in notflags is not set in the file&#39;s flags bits.  Otherwise, this primary evaluates to true if the bits in flags exactly match the file&#39;s flags bits, and none of the flags bits match those of
             notflags.

     -fstype type
             True if the file is contained in a file system of type type.  The lsvfs(1) command can
             be used to find out the types of file systems that are available on the system.  In
             addition, there are two pseudo-types, ``local&#39;&#39; and ``rdonly&#39;&#39;.  The former matches any
             file system physically mounted on the system where the find is being executed and the
             latter matches any file system which is mounted read-only.

     -gid gname
             The same thing as -group gname for compatibility with GNU find.  GNU find imposes a
             restriction that gname is numeric, while find(1) does not.

     -group gname
             True if the file belongs to the group gname.  If gname is numeric and there is no such
             group name, then gname is treated as a group ID.

     -ignore_readdir_race
             This option is for GNU find compatibility and is ignored.

     -ilname pattern
             Like -lname, but the match is case insensitive.  This is a GNU find extension.

     -iname pattern
             Like -name, but the match is case insensitive.

     -inum n
             True if the file has inode number n.

     -ipath pattern
             Like -path, but the match is case insensitive.

     -iregex pattern
             Like -regex, but the match is case insensitive.

     -iwholename pattern
             The same thing as -ipath, for GNU find compatibility.

     -links n
             True if the file has n links.

     -lname pattern
             Like -name, but the contents of the symbolic link are matched instead of the file name.
             Note that this only matches broken symbolic links if symbolic links are being followed.
             This is a GNU find extension.

     -ls     This primary always evaluates to true.  The following information for the current file
             is written to standard output: its inode number, size in 512-byte blocks, file permis-
             sions, number of hard links, owner, group, size in bytes, last modification time, and
             pathname.  If the file is a block or character special file, the device number will be
             displayed instead of the size in bytes.  If the file is a symbolic link, the pathname
             of the linked-to file will be displayed preceded by ``-&gt;&#39;&#39;.  The format is identical to
             that produced by ``ls -dgils&#39;&#39;.

     -maxdepth n
             Always true; descend at most n directory levels below the command line arguments.  If
             any -maxdepth primary is specified, it applies to the entire expression even if it
             would not normally be evaluated.  ``-maxdepth 0&#39;&#39; limits the whole search to the com-
             mand line arguments.

     -mindepth n
             Always true; do not apply any tests or actions at levels less than n.  If any -mindepth
             primary is specified, it applies to the entire expression even if it would not normally
             be evaluated.  ``-mindepth 1&#39;&#39; processes all but the command line arguments.

     -mmin n
             True if the difference between the file last modification time and the time find was
             started, rounded up to the next full minute, is n minutes.

     -mnewer file
             Same as -newer.

     -mount  The same thing as -xdev, for GNU find compatibility.

     -mtime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the
             file last modification time and the time find was started, rounded up to the next full
             24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the
             file last modification time and the time find was started is exactly n units.  Please
             refer to the -atime primary description for information on supported time units.

     -name pattern
             True if the last component of the pathname being examined matches pattern.  Special
             shell pattern matching characters (``[&#39;&#39;, ``]&#39;&#39;, ``*&#39;&#39;, and ``?&#39;&#39;) may be used as part
             of pattern.  These characters may be matched explicitly by escaping them with a back-
             slash (``\&#39;&#39;).

     -newer file
             True if the current file has a more recent last modification time than file.

     -newerXY file
             True if the current file has a more recent last access time (X=a), inode creation time
             (X=B), change time (X=c), or modification time (X=m) than the last access time (Y=a),
             inode creation time (Y=B), change time (Y=c), or modification time (Y=m) of file.  In
             addition, if Y=t, then file is instead interpreted as a direct date specification of
             the form understood by cvs(1).  Note that -newermm is equivalent to -newer.

     -nogroup
             True if the file belongs to an unknown group.

     -noignore_readdir_race
             This option is for GNU find compatibility and is ignored.

     -noleaf
             This option is for GNU find compatibility.  In GNU find it disables an optimization not
             relevant to find(1), so it is ignored.

     -nouser
             True if the file belongs to an unknown user.

     -ok utility [argument ...] ;
             The -ok primary is identical to the -exec primary with the exception that find requests
             user affirmation for the execution of the utility by printing a message to the terminal
             and reading a response.  If the response is not affirmative (`y&#39; in the ``POSIX&#39;&#39;
             locale), the command is not executed and the value of the -ok expression is false.

     -okdir utility [argument ...] ;
             The -okdir primary is identical to the -execdir primary with the same exception as
             described for the -ok primary.

     -path pattern
             True if the pathname being examined matches pattern.  Special shell pattern matching
             characters (``[&#39;&#39;, ``]&#39;&#39;, ``*&#39;&#39;, and ``?&#39;&#39;) may be used as part of pattern.  These
             characters may be matched explicitly by escaping them with a backslash (``\&#39;&#39;).
             Slashes (``/&#39;&#39;) are treated as normal characters and do not have to be matched explic-
             itly.

     -perm [-|+]mode
             The mode may be either symbolic (see chmod(1)) or an octal number.  If the mode is sym-
             bolic, a starting value of zero is assumed and the mode sets or clears permissions
             without regard to the process&#39; file mode creation mask.  If the mode is octal, only
             bits 07777 (S_ISUID | S_ISGID | S_ISTXT | S_IRWXU | S_IRWXG | S_IRWXO) of the file&#39;s
             mode bits participate in the comparison.  If the mode is preceded by a dash (``-&#39;&#39;),
             this primary evaluates to true if at least all of the bits in the mode are set in the
             file&#39;s mode bits.  If the mode is preceded by a plus (``+&#39;&#39;), this primary evaluates to
             true if any of the bits in the mode are set in the file&#39;s mode bits.  Otherwise, this
             primary evaluates to true if the bits in the mode exactly match the file&#39;s mode bits.
             Note, the first character of a symbolic mode may not be a dash (``-&#39;&#39;).

     -print  This primary always evaluates to true.  It prints the pathname of the current file to
             standard output.  If none of -exec, -ls, -print, -print0, or -ok is specified, the
             given expression shall be effectively replaced by ( given expression ) -print.

     -print0
             This primary always evaluates to true.  It prints the pathname of the current file to
             standard output, followed by an ASCII NUL character (character code 0).

     -prune  This primary always evaluates to true.  It causes find to not descend into the current
             file.  Note, the -prune primary has no effect if the -d option was specified.

     -regex pattern
             True if the whole path of the file matches pattern using regular expression.  To match
             a file named ``./foo/xyzzy&#39;&#39;, you can use the regular expression ``.*/[xyz]*&#39;&#39; or
             ``.*/foo/.*&#39;&#39;, but not ``xyzzy&#39;&#39; or ``/foo/&#39;&#39;.

     -samefile name
             True if the file is a hard link to name.  If the command option -L is specified, it is
             also true if the file is a symbolic link and points to name.

     -size n[ckMGTP]
             True if the file&#39;s size, rounded up, in 512-byte blocks is n.  If n is followed by a c,
             then the primary is true if the file&#39;s size is n bytes (characters).  Similarly if n is
             followed by a scale indicator then the file&#39;s size is compared to n scaled as:

             k       kilobytes (1024 bytes)
             M       megabytes (1024 kilobytes)
             G       gigabytes (1024 megabytes)
             T       terabytes (1024 gigabytes)
             P       petabytes (1024 terabytes)

     -type t
             True if the file is of the specified type.  Possible file types are as follows:

             b       block special
             c       character special
             d       directory
             f       regular file
             l       symbolic link
             p       FIFO
             s       socket

     -uid uname
             The same thing as -user uname for compatibility with GNU find.  GNU find imposes a
             restriction that uname is numeric, while find(1) does not.

     -user uname
             True if the file belongs to the user uname.  If uname is numeric and there is no such
             user name, then uname is treated as a user ID.

     -wholename pattern
             The same thing as -path, for GNU find compatibility.

     -xattr  True if the file has any extended attributes.

     -xattrname name
             True if the file has an extended attribute with the specified name.

OPERATORS
     The primaries may be combined using the following operators.  The operators are listed in order
     of decreasing precedence.

     ( expression )
             This evaluates to true if the parenthesized expression evaluates to true.

     ! expression
     -not expression
             This is the unary NOT operator.  It evaluates to true if the expression is false.

     -false  Always false.
     -true   Always true.

     expression -and expression
     expression expression
             The -and operator is the logical AND operator.  As it is implied by the juxtaposition
             of two expressions it does not have to be specified.  The expression evaluates to true
             if both expressions are true.  The second expression is not evaluated if the first
             expression is false.

     expression -or expression
             The -or operator is the logical OR operator.  The expression evaluates to true if
             either the first or the second expression is true.  The second expression is not evalu-
             ated if the first expression is true.

     All operands and primaries must be separate arguments to find.  Primaries which themselves take
     arguments expect each argument to be a separate argument to find.

ENVIRONMENT
     The LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES and LC_TIME environment variables affect
     the execution of the find utility as described in environ(7).

EXAMPLES
     The following examples are shown as given to the shell:

     find / \! -name &quot;*.c&quot; -print
             Print out a list of all the files whose names do not end in .c.

     find / -newer ttt -user wnj -print
             Print out a list of all the files owned by user ``wnj&#39;&#39; that are newer than the file
             ttt.
     find / \! \( -newer ttt -user wnj \) -print
             Print out a list of all the files which are not both newer than ttt and owned by
             ``wnj&#39;&#39;.

     find / \( -newer ttt -or -user wnj \) -print
             Print out a list of all the files that are either owned by ``wnj&#39;&#39; or that are newer
             than ttt.

     find / -newerct &#39;1 minute ago&#39; -print
             Print out a list of all the files whose inode change time is more recent than the cur-
             rent time minus one minute.

     find / -type f -exec echo {} \;
             Use the echo(1) command to print out a list of all the files.

     find -L /usr/ports/packages -type l -exec rm -- {} +
             Delete all broken symbolic links in /usr/ports/packages.

     find /usr/src -name CVS -prune -o -depth +6 -print
             Find files and directories that are at least seven levels deep in the working directory
             /usr/src.

     find /usr/src -name CVS -prune -o -mindepth 7 -print
             Is not equivalent to the previous example, since -prune is not evaluated below level
             seven.

COMPATIBILITY
     The -follow primary is deprecated; the -L option should be used instead.  See the STANDARDS
     section below for details.

SEE ALSO
     chflags(1), chmod(1), cvs(1), locate(1), lsvfs(1), whereis(1), which(1), xargs(1), stat(2),
     acl(3), fts(3), getgrent(3), getpwent(3), strmode(3), re_format(7), symlink(7)

STANDARDS
     The find utility syntax is a superset of the syntax specified by the IEEE Std 1003.1-2001
     (``POSIX.1&#39;&#39;) standard.

     All the single character options except -H and -L as well as -amin, -anewer, -cmin, -cnewer, -delete, -empty, -fstype, -iname, -inum, -iregex, -ls, -maxdepth, -mindepth, -mmin, -path,
     -print0, -regex and all of the -B* birthtime related primaries are extensions to IEEE Std
     1003.1-2001 (``POSIX.1&#39;&#39;).

     Historically, the -d, -L and -x options were implemented using the primaries -depth, -follow,
     and -xdev.  These primaries always evaluated to true.  As they were really global variables
     that took effect before the traversal began, some legal expressions could have unexpected
     results.  An example is the expression -print -o -depth.  As -print always evaluates to true,
     the standard order of evaluation implies that -depth would never be evaluated.  This is not the
     case.

     The operator -or was implemented as -o, and the operator -and was implemented as -a.

     Historic implementations of the -exec and -ok primaries did not replace the string ``{}&#39;&#39; in
     the utility name or the utility arguments if it had preceding or following non-whitespace char-
     acters.  This version replaces it no matter where in the utility name or arguments it appears.

     The -E option was inspired by the equivalent grep(1) and sed(1) options.

HISTORY
     A find command appeared in Version 1 AT&amp;T UNIX.

BUGS
     The special characters used by find are also special characters to many shell programs.  In
     particular, the characters ``*&#39;&#39;, ``[&#39;&#39;, ``]&#39;&#39;, ``?&#39;&#39;, ``(&#39;&#39;, ``)&#39;&#39;, ``!&#39;&#39;, ``\&#39;&#39; and ``;&#39;&#39; may
     have to be escaped from the shell.

     As there is no delimiter separating options and file names or file names and the expression, it
     is difficult to specify files named -xdev or !.  These problems are handled by the -f option
     and the getopt(3) ``--&#39;&#39; construct.

     The -delete primary does not interact well with other options that cause the file system tree
     traversal options to be changed.

     The -mindepth and -maxdepth primaries are actually global options (as documented above).  They
     should probably be replaced by options which look like options.
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/18</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15998025628955.html">1000行MySQL学习笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025628475.html">Anaconda + VSCode 最详细教程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15838967255194.html">Docker 必备可视化工具 Portainer</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025631446.html">Git 常用技巧 （高级用法）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025629044.html">Git版本管理完全指南（包含常见头疼错误解决方案）</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
