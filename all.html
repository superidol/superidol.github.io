<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16177589969532.html">
                
                  <h1>**用好VSCode这13款插件和8个快捷键**</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>VsCode 远程开发环境相对其他 IDE 的远程开发环境，实现了真正的远程开发，在本地主机（一般是Windows或MAC）上的操作的对象直接就是远程机（Linux），所有本地主机上的修改直接基于远端文件，摆脱了传统开发流程在本地编辑文件，利用FTP工具上传到远程编译机调试编译，这一套繁琐的操作，因此非常的方便。</p>

<p><strong>接着上篇VsCode教程，这篇文章我会结合日常工作使用经验，教你打造一个体验流畅的 C/C++ 开发环境</strong>，这份配置指南可能不是面面俱到，也不会详细的教你一步步怎么配置插件，这些太细节的工作留给你自己去完成，实际上插件下载页都会有详细的说明。</p>

<p>不少新手可能会觉得 VsCode 编辑文本还好，看代码和写代码太难用，那是没有掌握正确的打开方式，<strong>VsCode 精髓是丰富的插件体系支持，相信看完这篇文章配置好环境之后，就只剩一句「真香」能形容</strong>。<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200322" alt="img"/></p>

<p>为了有个直观的印象，先来看下我的 VsCode 插件列表，因为我用VsCode 开发 C/C++/Go/Python 程序，插件比较多，有些可能和本文无关的插件可以忽略掉。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200340" alt="img"/></p>

<h2 id="toc_0"><strong>基础开发插件</strong></h2>

<p>既然是配置支持C/C++环境下开发，<strong>那首先推荐的基础 C/C++ 开发插件</strong>，以下两个是必须要装的插件，主要提供一些基础的代码调试和查看功能，安装以后 VsCode 就能支持智能化代码补全、类型填充和联想、符号和函数定义跳转、引用查找等 C/C++ 程序开发和源码管理必备能力，让你的 VsCode 从编辑器进化成 IDE 的基础插件。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200049" alt="img"/><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200100" alt="img"/></p>

<h2 id="toc_1"><strong>源码阅读</strong></h2>

<p>程序员日常工作有两大内容，一个是写自己的代码，一个是阅读别人写的代码，下面这两个插件让你在 VsCode 优雅看代码。</p>

<p><strong>首先推荐的是下面的这个懒人神器 TODO Tree，自己写的 TODO 哭着也要补充实现。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200118" alt="img"/>TODO Tree</p>

<p>这个插件的使用场景是，你看完代码加了下面这个注释 ：<code>// TODO 以后会扩展这部分功能</code> 当然，不知道这个「以后」是什么时候，一不小心以后变成遥遥无期，一部分原因是不想改，另一部分原因是写下这段注释的人时间久了就忘记了，这时候你需要「 TODO Tree 插件」，我们可以更方便的管理代码中的此类注释。</p>

<p>这个插件能帮你组织和管理TODO 注释，你在代码中注释的带 TODO 的标签会统一在侧边栏显示出来，当然不限于 TODO 注释，可以自定义管理标签比如 <code>FIXME</code> 等，可以基于标签过滤和筛选。</p>

<p><strong>另一个推荐的源码阅读插件是 Bookmarks</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200127" alt="img"/>「书签」这个插件的功能就和它名字一样直接，没错它就是一个你的源码书签，当我们看大工程源码的时候，往往需要在成千上万个源文件之间跳转，<strong>此外， Bookmarks 能帮你方便的创建和管理书签</strong>，看到哪个位置想加个书签就按快捷键 <code>Ctrl + Alt + K</code> ，多按一次就是删除，不仅如此他还提供了在书签之前跳跃和查看管理的功能，更多功能可以自己体验，反正我看大工程源码用这个很爽。<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200134" alt="img"/></p>

<h2 id="toc_2"><strong>代码管理</strong></h2>

<p><strong>下面介绍两个 Git 版本控制相关的插件</strong>，项目中我们用的最多的版本控制工具是 Git ，当然 VsCode 自身提供了比较丰富的 Git 版本控制功能，基本上可以通过在界面点点点完成一些了Git 操作，但我今天要介绍的这两个插件能让你的 Git 更惊艳，算是对功能的增强，让你的 Git 操作更直观好用，好看的东西谁不喜欢呢？</p>

<p><strong>第一个出场的是Git Graph 插件，可视化Git仓库，让你的提交记录看起来美观大方，并且基于图中提交点提供了丰富的Git 操作。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200140" alt="img"/>GitGraph</p>

<p>如图中你所见到的样子，提交记录变成一条条时间线，分支也能清晰的用不同颜色时间线区分出来，并且点开提交线上的提交点可以查看当时的提交动作，可以在提交动作上查看做了哪些改动，也可以方便的跳转到改动文件，更多功能自行体验，这个插件 lemon 强烈推荐！</p>

<p><strong>下面介绍的这个GitLens 插件也是Git功能增强工具。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200147" alt="img"/>GitLens</p>

<p>我最喜欢它的一个功能是，它可以在文件中改动的位置后面直接显示出本次改动的提交信息，然后你可以直接通过显示的提交信息跳转到提交文件对比，其实还有其他丰富的功能，不过这个功能我用的最多。</p>

<h2 id="toc_3"><strong>小而美的工具</strong></h2>

<p>下面这几个插件是我在日常使用中积累的工具插件，非必须，但是拥有了之后编码幸福感倍增，下面一一介绍给大家。</p>

<p><strong>第一个是下面这个Bracket Pair Colorizer插件，我管它叫彩虹括号插件。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200151" alt="img"/>彩虹括号</p>

<p>你是否为经常为写的大括号、花括号、小括号没有匹配而烦恼？是否经常找匹配括号看瞎了眼？现在不要 888 也不要 998，只需一键下载安装这个插件就再也不用担心啦。这个插件让你写的每一个括号都能找到他自己的颜色，成双成对，点一下其中一半括号自动匹配另一半，拯救了广大程序员的近视眼睛度数。</p>

<p><strong>再来介绍下面这个koroFileHeader插件，这个插件主要用于自动的插入头文件开头的说明和函数的说明。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200156" alt="img"/>koroFileHHeader</p>

<p>比如我们经常看到别人的头文件开头是这样的模板：</p>

<pre class="line-numbers"><code class="language-text">/******************************************************************************
*  FILENAME:    niu_bi_head_file.h
*  DESCRIPTION: 非常厉害的头文件
*  HISTORY:     Date        Author      Comment
*               2020/09/05  lemon
*******************************************************************************/
</code></pre>

<p>这个可不是别人一个个字打出来的，安装插件之后你只需要简单配置想要的格式，然后按下快捷键<code>Ctrl + Alt +i</code> 即可自动即可自动生成这样一个模板。</p>

<p>类似的对函数的说明注释模板，只需按下快捷键<code>Ctrl + Alt +t</code> 即可完成，非常的方便。</p>

<p><strong>下面这个插件Switcher，这个插件能在头文件和 C/C++ 文件之间跳转。</strong><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200202" alt="img"/></p>

<p>这个插件完全是因为我太懒想省力，才找的一个辅助工具，我们经常需要通过头文件跳到对应的源文件，或者从源文件跳转到对应的头文件，当然可以在侧边栏的文件管理器中选择打开，但是多了一个步骤有点繁琐，所以我找了这个插件，其实按插件的说明文档，它是能在不同的文件类型之间跳转，不仅仅局限于头文件和源文件，懒人福音，你值得拥有。</p>

<h2 id="toc_4"><strong>实用工具</strong></h2>

<p>下面这几个插件是比较实用的工具插件，各取所需。</p>

<p><strong>第一个是官方提供的 VsCode 中文汉化包</strong>。虽然lemon提倡并鼓励大家多多实用英语，但若你不想折腾，那咱们家汉语博大精深，好优美的中国话，那就让VsCode也来说汉语吧，Microsoft 官方直供，兼容性好，放心食用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200207" alt="img"/>中文语言包</p>

<p><strong>下面这个是 Markdown 预览增强插件</strong>。对于经常写博客或文章的人来说，Markdown 肯定是少不了的，这个插件支持分屏预览，各种丰富的Markdwon 增强功能。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200215" alt="img"/>markdown增强</p>

<p>最后这个 shellman 插件是 Linux shell 脚本辅助工具。在 Linux 下工作难免随手写一个脚本，这个插件能提供了便捷的shell script 自动补全和联想等功能，提高你的脚本编写速度和准确性。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200225" alt="img"/></p>

<p>shellman</p>

<p><strong>以上就是我开发环境中配置的常用插件，快来抄作业，跟着配置起来你就拥有了一个流畅的C/C++开发环境</strong>。搭配下面讲的插件部分内容服用，效果更佳。</p>

<h2 id="toc_5"><strong>最常用快捷键</strong></h2>

<p><strong>快捷键太多，没必要完全记下来，只需记住一些常用的快捷键即可，一些不常用的快捷键在使用的时候加强记忆就好</strong>。列举出我自己常用的快捷键，不多，但够用！应付日常开发工作绰绰有余。</p>

<p><code>Ctrl + Shift + P</code> 这个必须要放在第一位，这个命令是所有「命令之母」。这么说一点也不过分，它会打开 VsCode 命令窗口，在这个窗口下输入上述的插件名称就能知道这个插件支持哪些特性了，顺带还会说明特性快捷键。</p>

<p>下面举个例子，先输入<code>Ctrl + Shift + P</code> 打开命令查找输入框，然后输入 <code>bookmarks</code> 就能知道这个插件的支持的所有特性，顺便记下快捷键。<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200231" alt="img"/></p>

<p><code>Ctrl + P</code> 文件查找。快速打开文件列表，输入关键字匹配文件，优先显示最新打开过的文件，方便的在指定文件之间跳转。</p>

<p><code>F12</code> 跳转到定义，这个没啥好说的，跳转到函数或符号的定义，这是高频操作。</p>

<p><code>Alt + F12</code> 以预览方式在当前页面显示定义，都是查看定义，相对 <code>F12</code> 的优点是不会跳出当前文件到定义文件，而是在当前文件打开一个小窗口预览，如下图：<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200236" alt="img"/></p>

<p><code>Shift + F12</code> 查看光标所在函数或变量的引用，就像 <code>Alt +F12</code> 一样以预览方式在当前文件打开引用的文件列表。如下图：<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200243" alt="img"/></p>

<p><code>Alt + 左/右箭头</code> 前进或者后退到光标所在源码的上一个位置。</p>

<p><code>Ctrl + Shift + O</code> 查看当前文件的符号，可以用关键字过滤符号，当然你也可以在左侧的大纲视图中查找符号，不过大纲视图不能查找匹配符号，所以我更习惯用快捷键方式查找符号。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200248" alt="img"/>符号和函数查找</p>

<p>快捷键讲完了吗？没有，太多快捷键了；其他的快捷键不重要吗？因人而异吧，高频使用的快捷键就是重要的，而上面我说的这几个是超高频使用，记住这几个差不多就行了，剩下快捷键你如果用的多了自然就记住了，<strong>但是我上面说的这几个快捷键请务必先记在脑子里，这会大大降低你的使用成本，尽早享受 VsCode Coding 的乐趣</strong>！</p>

<h2 id="toc_6"><strong>最后说几句</strong></h2>

<p>想起我上大学的时候，大一学习C语言课必须安装VC++ 6.0才行，那时候也有 Visual studio 这样的 IDE，不过老师没推荐其他 IDE，都是凭借自己对编程的兴趣发现了更多比VC++ 6.0 更加 &#39;现代化&#39; 的 IDE，比如Jetbrain 系列和Visual studio系列，爱不释手各种尝试。<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200911200254" alt="img"/></p>

<p>现在主流的 IDE 已经非常丰富，其实编辑器或者 IDE 只是一个工具，没有最好自己用的顺手就行，就像 Vim 党和 Emacs 党谁也说服不了谁一样，自己喜欢就好。</p>

<p><strong>大家更应该关注编程这件事本身，提高自身硬实力才是最紧要的，不过好的工具能让你事半功倍</strong>，这点我也是完全赞成的，希望这篇文章也能够让你事半功倍。</p>

<p><strong>如果文章对你有帮助，请不吝点击「在看、分享」激励我持续创作。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628955.html">
                
                  <h1>1000行MySQL学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824230300" alt="1000行MySQL学习笔记，不怕你不会，就怕你不学"/></p>

<h3 id="toc_0">/ Windows服务 /</h3>

<pre class="line-numbers"><code class="language-text">-- 启动MySQL
    net start mysql
-- 创建Windows服务
    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)
</code></pre>

<h3 id="toc_1">/ 连接与断开服务器 /</h3>

<pre class="line-numbers"><code class="language-text">mysql -h 地址 -P 端口 -u 用户名 -p 密码

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 显示系统变量信息
</code></pre>

<h3 id="toc_2">/ 数据库操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 库名 选项信息
-- 删除库
    DROP DATABASE[ IF EXISTS] 数据库名
        同时删除该数据库相关的目录及其目录内容
</code></pre>

<h3 id="toc_3">/ 表的操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 创建表
    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        TEMPORARY 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
        InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 自增起始数
        AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 表名
-- 查看表机构
    SHOW CREATE TABLE 表名 （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]
    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        eg: ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）
        -- RENAME可以交换两个表名
    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段定义       -- 增加字段
                AFTER 字段名          -- 表示增加在该字段名后面
                FIRST               -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)   -- 创建主键
            ADD UNIQUE [索引名](字段名)-- 创建唯一索引
            ADD INDEX [索引名](字段名) -- 创建普通索引
            DROP[ COLUMN] 字段名      -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
            DROP INDEX 索引名 -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键

-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>

<h3 id="toc_4">/ 数据操作 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]
</code></pre>

<h3 id="toc_5">/ 字符集编码 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results       服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES GBK;  -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集
    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集
    CHARSET 字符集编码     设置字符集编码
    COLLATE 校对集编码     设置校对集编码
</code></pre>

<h3 id="toc_6">/ 数据类型（列类型） / ------------------</h3>

<pre class="line-numbers"><code class="language-text">1. 数值类型
-- a. 整型 ----------
    类型         字节     范围（有符号位）
    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255
    smallint    2字节    -32768 ~ 32767
    mediumint   3字节    -8388608 ~ 8388607
    int         4字节
    bigint      8字节

    int(M)  M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好。
    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。

-- b. 浮点型 ----------
    类型             字节     范围
    float(单精度)     4字节
    double(双精度)    8字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)     double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c. 定点数 ----------
    decimal -- 可变长度
    decimal(M, D)   M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar 变长字符串，速度慢，但节省空间
    M表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535字符，与编码有关。
    一条有效记录最大不能超过65535个字节。
        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给default值

-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期         1000-01-01 到 9999-12-31
    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间         -838:59:59 到 838:59:59
    year        1字节    年份         1901 - 2155

datetime    YYYY-MM-DD hh:mm:ss
timestamp   YY-MM-DD hh:mm:ss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        YYYY-MM-DD
            YY-MM-DD
            YYYYMMDD
            YYMMDD
            YYYYMMDD
            YYMMDD
time        hh:mm:ss
            hhmmss
            hhmmss
year        YYYY
            YY
            YYYY
            YY

4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。

-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );
    insert into tab values (&#39;男, 女&#39;);
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。
</code></pre>

<h3 id="toc_7">/ 选择类型 /</h3>

<pre class="line-numbers"><code class="language-text">-- PHP角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned
    1) PHP函数转换
        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
        利用sprintf函数格式化字符串
        sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;));
        然后用long2ip将整型转回IP字符串
    2) MySQL函数转换(无符号整型，UNSIGNED)
        INET_ATON(&#39;127.0.0.1&#39;) 将IP转为整型
        INET_NTOA(2130706433) 将整型转为IP
</code></pre>

<h3 id="toc_8">/ 列属性（列约束） / ------------------</h3>

<pre class="line-numbers"><code class="language-text">1. PRIMARY 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

2. UNIQUE 唯一索引（唯一约束）
    使得某字段的值也不能重复。

3. NULL 约束
    null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, &#39;val&#39;);
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null

4. DEFAULT 默认值属性
    当前字段的默认值。
    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time

5. AUTO_INCREMENT 自动增长约束
    自动增长必须为索引（主键或unique）
    只能存在一个字段为自动增长。
    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;

6. COMMENT 注释
    例：create table tab ( id int ) comment &#39;注释内容&#39;;

7. FOREIGN KEY 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表t1的t1_id外键关联到表t2的id字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定

    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。

    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。

    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。

    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。
</code></pre>

<h3 id="toc_9">/ 建表规范 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">   -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除符合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。
</code></pre>

<h3 id="toc_10">/ SELECT / ------------------</h3>

<pre class="line-numbers"><code class="language-text">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT

a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;

b. FROM 子句
    用于标识查询来源。
    -- 可以为表起别名。使用as关键字。
        SELECT * FROM tb1 AS tt, tb2 AS bb;
    -- from子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        SELECT * FROM tb1, tb2;
    -- 向优化符提示如何选择索引
        USE INDEX、IGNORE INDEX、FORCE INDEX
        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;
        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;

c. WHERE 子句
    -- 从from获得的数据源中进行筛选。
    -- 整型1表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较

d. GROUP BY 子句, 分组子句
    GROUP BY 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC

    以下[合计函数]需配合 GROUP BY 使用：
    count 返回不同的非NULL值数目  count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。

e. HAVING 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。

f. ORDER BY 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

g. LIMIT 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数

h. DISTINCT, ALL 选项
    distinct 去除重复记录
    默认为 all, 全部记录
</code></pre>

<h3 id="toc_11">/ UNION / ------------------</h3>

<pre class="line-numbers"><code class="language-text">   将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。
</code></pre>

<h3 id="toc_12">/ 子查询 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。

    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()   不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。
</code></pre>

<h3 id="toc_13">/ 连接查询(join) / ------------------</h3>

<pre class="line-numbers"><code class="language-text">    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)

    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;
</code></pre>

<h3 id="toc_14">/ 导入导出 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据
load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据
    生成的数据默认的分隔符是制表符
    local未指定，则数据文件必须在服务器上
    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields  控制字段格式
默认：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;
    terminated by &#39;string&#39;  -- 终止
    enclosed by &#39;char&#39;      -- 包裹
    escaped by &#39;char&#39;       -- 转义
    -- 示例：
        SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;
        FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;
        LINES TERMINATED BY &#39;\n&#39;
        FROM test_table;
lines   控制行格式
默认：lines terminated by &#39;\n&#39;
    terminated by &#39;string&#39;  -- 终止
</code></pre>

<h3 id="toc_15">/ INSERT / ------------------</h3>

<pre class="line-numbers"><code class="language-text">select语句获得的数据可以用insert插入。

可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
    或者使用set语法。
    INSERT INTO tbl_name SET field=value,...；

可以一次性使用多个值，采用(), (), ();的形式。
    INSERT INTO tbl_name VALUES (), (), ();

可以在列值指定时，使用表达式。
    INSERT INTO tbl_name VALUES (field_value, 10+10, now());
可以使用一个特殊值 DEFAULT，表示该列使用默认值。
    INSERT INTO tbl_name VALUES (field_value, DEFAULT);

可以通过一个查询的结果，作为需要插入的值。
    INSERT INTO tbl_name SELECT ...;

可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
    INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;
</code></pre>

<h3 id="toc_16">/ DELETE / ------------------</h3>

<pre class="line-numbers"><code class="language-text">DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]

按照条件删除。where

指定删除的最多记录数。limit

可以通过排序条件删除。order by + limit

支持多表删除，使用类似连接语法。
delete from 需要删除数据多表1，表2 using 表连接操作 条件。
</code></pre>

<h3 id="toc_17">/ TRUNCATE / ------------------</h3>

<pre class="line-numbers"><code class="language-text">TRUNCATE [TABLE] tbl_name
清空数据
删除重建表

区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区
</code></pre>

<h3 id="toc_18">/ 备份与还原 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。

-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database


1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库
　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)

可以-w携带WHERE条件

-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 &lt; 备份文件
</code></pre>

<h3 id="toc_19">/ 视图 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数

-- 查看结构
    SHOW CREATE VIEW view_name

-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...

-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement

-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构

-- 视图算法(ALGORITHM)
    MERGE       合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE   临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。
</code></pre>

<h3 id="toc_20">/ 事务(transaction) / ------------------</h3>

<pre class="line-numbers"><code class="language-text">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。
    - 支持连续SQL的集体成功或集体撤销。
    - 事务是数据库在数据晚自习方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB被称为事务安全型引擎。

-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。

-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。

-- 事务的原理
    利用InnoDB的自动提交(autocommit)特性完成。
    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。

-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套

-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点

-- InnoDB自动提交特性设置
    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)
</code></pre>

<h3 id="toc_21">/ 锁表 /</h3>

<pre class="line-numbers"><code class="language-text">表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES
</code></pre>

<h3 id="toc_22">/ 触发器 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">  触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
  监听：记录的增加、修改、删除。

-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
  参数：
  trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
  trigger_event指明了激活触发程序的语句的类型
      INSERT：将新行插入表时激活触发程序
      UPDATE：更改某一行时激活触发程序
      DELETE：从表中删除某一行时激活触发程序
  tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
  trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构

-- 删除
DROP TRIGGER [schema_name.]trigger_name

可以使用old和new代替旧的和新的数据
  更新操作，更新前是old，更新后是new.
  删除操作，只有old.
  增加操作，只有new.

-- 注意
  1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。


-- 字符连接函数
concat(str1,str2,...])
concat_ws(separator,str1,str2,...)

-- 分支语句
if 条件 then
  执行语句
elseif 条件 then
  执行语句
else
  执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
  SQL语句
自定义结束符号

delimiter ;     -- 修改回原来的分号

-- 语句块包裹
begin
  语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
  如果没有重复记录，会触发 before insert, after insert;
  如果有重复记录并更新，会触发 before insert, before update, after update;
  如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert
</code></pre>

<h3 id="toc_23">/ SQL编程 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value]
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。

-- 赋值
    使用 set 和 select into 语句为变量赋值。

    - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;

select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;

    - 变量被定义后，在整个会话周期都有效（登录到退出）


--// 控制结构 ----------
-- if语句
if search_condition then
    statement_list   
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;

-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END


-- while循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];

- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。

    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环


--// 内置函数 ----------
-- 数值函数
abs(x)          -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)         -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)       -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)       -- m^n
sqrt(x)         -- 算术平方根
rand()          -- 随机数
truncate(x, d)  -- 截取d位小数

-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                 -- 当前日期
current_time();                 -- 当前时间
date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分
time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分
date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间
unix_timestamp();               -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间

-- 字符串函数
length(string)          -- string长度，字节
char_length(string)     -- string的字符个数
substring(str, position [,length])      -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])   -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)           -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position]) -- 同instr,但可指定开始位置
lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)           -- 去除前端空格
repeat(string, count)   -- 重复count次
rpad(string, length, pad)   --在str后用pad补充,直到长度为length
rtrim(string)           -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小

-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。

-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()

-- 其他常用函数
md5();
default();


--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体

    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。

-- 删除
    DROP FUNCTION [IF EXISTS] function_name;

-- 查看
    SHOW FUNCTION STATUS LIKE &#39;partten&#39;
    SHOW CREATE FUNCTION function_name;

-- 修改
    ALTER FUNCTION function_name 函数选项


--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。

-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体

参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型

注意，没有返回值。
</code></pre>

<h3 id="toc_24">/ 存储过程 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中

-- 参数
IN|OUT|INOUT 参数名 数据类型
IN      输入：在调用过程中，将数据输入到过程体内部的参数
OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT   输入输出：既可输入，也可输出

-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END
</code></pre>

<h3 id="toc_25">/ 用户和权限管理 / ------------------</h3>

<pre class="line-numbers"><code class="language-text">-- root密码重置
1. 停止MySQL服务
2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;
    [Windows] mysqld --skip-grant-tables
3. use mysql;
4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;
5. FLUSH PRIVILEGES;

用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES;
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
    GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER   -- 允许使用ALTER TABLE
ALTER ROUTINE   -- 更改或取消已存储的子程序
CREATE  -- 允许使用CREATE TABLE
CREATE ROUTINE  -- 创建已存储的子程序
CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE
CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW     -- 允许使用CREATE VIEW
DELETE  -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE     -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX   -- 允许使用CREATE INDEX和DROP INDEX
INSERT  -- 允许使用INSERT
LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES  -- 未被实施
RELOAD  -- 允许使用FLUSH
REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT  -- 允许使用SELECT
SHOW DATABASES  -- 显示所有数据库
SHOW VIEW   -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE  -- 允许使用UPDATE
USAGE   -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限
</code></pre>

<h3 id="toc_26">/ 表维护 /-----------------------------------</h3>

<pre class="line-numbers"><code class="language-text">-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>

<h3 id="toc_27">/ 杂项 /-------------------------------------</h3>

<pre class="line-numbers"><code class="language-text">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _   任意单个字符
    %   任意多个字符，甚至包括零字符
    单引号需要进行转义 \&#39;
5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144586.html">
                
                  <h1>[Chrome浏览器F12开发者工具简单使用]</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1.如何调出开发者工具</h2>

<ul>
<li>按F12调出</li>
<li>右键检查（或快捷键Ctrl+Shift+i）调出 </li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000830.png" alt="img"/></p>

<h2 id="toc_1">2.开发者工具初步介绍</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000841.png" alt="img"/></p>

<p>chrome开发者工具最常用的四个功能模块：元素（ELements）、控制台（Console）、源代码（Sources），网络（Network）。</p>

<ul>
<li>元素（Elements）：用于查看或修改HTML元素的属性、CSS属性、监听事件、断点等。css可以即时修改，即时显示。大大方便了开发者调试页面</li>
<li>控制台（Console）：控制台一般用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。还可以当作Javascript API查看用。例如我想查看console都有哪些方法和属性，我可以直接在Console中输入&quot;console&quot;并执行~</li>
<li>源代码（Sources）：该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。</li>
<li>网络（Network）：网络页面主要用于查看header等与网络连接相关的信息。</li>
</ul>

<h3 id="toc_2">2.1元素（Elements）</h3>

<ul>
<li><p>查看元素的代码：点击左上角的箭头图标（或按快捷键Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置</p></li>
<li><p>查看元素的属性：定位到元素的源代码之后，可以从源代码中读出改元素的属性。如下图中的class、src、width等属性的值。</p></li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000850.png" alt="img"/></p>

<ul>
<li>当然从源代码中读到的只是一部分显式声明的属性，要查看该元素的所有属性，可以在右边的侧栏中查看：</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000905.png" alt="img"/></p>

<ul>
<li>修改元素的代码与属性：点击元素，然查看右键菜单，可以看到chrome提供的可对元素进行的操作：包括编辑元素代码（Edit as HTML）、修改属性（Add attribute、Edit attribute）等。选择Edit as HTML选项时，元素进入编辑模式，可以对元素的代码进行任意的修改。当然，这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000915.png" alt="img"/></p>

<ul>
<li>查看元素的CSS属性：在元素的右边栏中的styles页面可以查看该元素的CSS属性，这个页面展示该元素原始定义的CSS属性以及从父级元素继承的CSS属性。从这个页面还可以查到该元素的某个CSS特性来自于那个CSS文件，使编码调试时修改代码变得非常方便。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000920.png" alt="img"/></p>

<ul>
<li>在Styles页旁边，有一个Computed页面，这个页面展示该元素经过计算之后的所有CSS属性，即最后浏览器渲染页面时使用的属性。属性的计算由浏览器自动进行，是浏览器渲染页面的一个必不可少的过程。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000942.png" alt="img"/></p>

<ul>
<li><p>修改元素的CSS属性：在元素的Styles页面，可以对元素的CSS属性进行修改，甚至删除原有、添加新属性。不过，这些修改，仅对当前浏览器的页面展示生效，不会修改CSS源代码。所以在这里进行CSS属性的修改一般用来调整和完善元素的渲染效果。 </p></li>
<li><p>给元素添加断点：在元素的右键菜单中选择断点选项（Break on…），选中之后，当元素被修改（通常是被JS代码修改）时，页面加载会暂停，然后可以查看该元素的属性。</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000951.png" alt="img"/></p></li>
<li><p>元素断点添加之后，可以在右侧栏的DOM Breakpoints页面中看到，这个页面可以看到当前网页的所有元素断点。</p></li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120000958.png" alt="img"/></p>

<ul>
<li>查看元素的监听事件：元素的右边栏的Event Listener页面，可以查看到该元素的所有监听事件。在开发中，尤其是维护其他人的代码时，会出现不了解元素对应的监听事件，这个时候，可以在这个页面中找到。这个页面不仅能看到对应的事件函数，还可以定位该函数所在的JS文件以及在该文件中的具体位置（行数），大大提高开发维护的效率。 </li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001004.png" alt="img"/></p>

<h2 id="toc_3">3. 控制台（Console）</h2>

<ul>
<li><p>查看JS对象的及其属性： <br/>
<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001012.png" alt="img"/></p></li>
<li><p>执行JS语句： <br/>
<img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001017.png" alt="img"/></p></li>
<li><p>查看控制台日志：当网页的JS代码中使用了console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉</p></li>
</ul>

<h2 id="toc_4">4. 源代码（Source）</h2>

<ul>
<li>查看文件：在源代码（Source）页面可以查看到当前网页的所有源文件。在左侧栏中可以看到源文件以树结构进行展示。 <img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001023.png" alt="img"/></li>
<li>添加断点：在源代码左边有行号，点击对应行的行号，就好给改行添加上一个断点（再次点击可删除断点）。右键点击断点，在弹出的菜单中选择Edit breakpoint可以给该断的添加中断条件。</li>
</ul>

<p>​     <img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001030.png" alt="img"/></p>

<ul>
<li><p>中断调试：添加断点后，当JS代码运行到断点时会中断（对于添加了中断条件的断点在符合条件时中断），此时可以将光标放在变量上查看变量的</p></li>
<li><p>也可以在右边的侧栏上查看： </p></li>
</ul>

<p>​    <img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001036.png" alt="img"/></p>

<ul>
<li>在右侧变量上方，有继续运行、单步跳过等按钮，可以在当前断点后，逐行运行代码，或者直接让其继续运行。</li>
</ul>

<p>​     <em><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001049.png" alt="img"/></em></p>

<h2 id="toc_5">5.Network详细介绍</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001054.png" alt="img"/></p>

<p>那我就按照从左到右的顺序来写啦~</p>

<ul>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001404.png" alt="img"/>：记录按钮 处于打开状态时会在此面板进行网络连接的信息记录，关闭后则不会记录。</li>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001358.png" alt="img"/>：清除按钮 清除当前的网络连接记录信息。（点击一下就能清空）</li>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001354.png" alt="img"/>：捕获截屏 记录页面加载过程中一些时间点的页面渲染情况，截图根据可视窗口截取，如下图所示。</li>
</ul>

<p><em><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001059.png" alt="img"/></em></p>

<ul>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001345.png" alt="img"/>：过滤器 能够自定义筛选条件，找到自己想要资源信息，如下图所示。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001103.png" alt="img"/></p>

<p>也可以是一些指定条件<br/>
指定条件有哪些？</p>

<p>domain：资源所在的域，即url中的域名部分。如 domain:api.github.com</p>

<p>has-response-header：资源是否存在响应头，无论其值是什么。如 has-response-header：Access-Control-Allow-Origin</p>

<p>is：当前时间点在执行的请求。当前可用值：running</p>

<p>larger-than：显示大于指定值大小规格的资源。单位是字节(B),但是K(kB)和M(MB)也是可以的~ 如larger-than:150K</p>

<p>method：使用何种HTTP请求方式。如 GET</p>

<p>mime-type：也写作content-type，是资源类型的标识符。如 text/html</p>

<p>scheme：协议规定。如 HTTPS</p>

<p>set-cookie-name：服务器设置的cookies名称</p>

<p>set-cookie-value：服务器设置的cookies的值</p>

<p>set-cookie-domain：服务器设置的cookies的域</p>

<p>status-code：HTTP响应头的状态码</p>

<ul>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001303.png" alt="img"/>：显示详细信息</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001109.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001114.png" alt="img"/></p>

<ul>
<li><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001326.png" alt="img"/>：显示时间流</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001120.png" alt="img"/></p>

<p>能够根据时间，查看对应时间下 浏览器请求的资源信息</p>

<ul>
<li><p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001150.png" alt="img"/>：是否保留日志 </p>
<p>当选择保留日志，重新加载url当前界面时，之前请求显示的资源信息，会保留下来，不会清空的哟~</p></li>
<li><p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001136.png" alt="img"/>：是否进行缓存</p>
<p>当打开开发者工具时生效，打开这个开关，则页面资源不会存入缓存，可以从Status栏的状态码看文件请求状态。</p></li>
<li><p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001143.png" alt="img"/>：<strong>设置模拟限速，如下图所示。</strong></p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001128.png" alt="img"/></p>
<p>设置限速可以模拟处于各种网络环境下的不同用户访问本页面的情况。</p></li>
</ul>

<h2 id="toc_6">6.Network主题内容介绍</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001157.png" alt="img"/></p>

<p>下列介绍中，前者为名词解释，后者为举例</p>

<ul>
<li><p>Name/Pat：资源名称以及URL路径 （main.css）</p></li>
<li><p>Method：Http请求方法 (GET或者POST)</p></li>
<li><p>status/Text：Http状态码/文字解释 （200，ok）</p></li>
<li><p>Type ：请求资源的MIME类型，MIME是Multipurpose Internet Mail Extensions (html,css,js等)</p></li>
<li><p>Initiator：解释请求是怎么发起的，有四种可能的值</p>
<pre class="line-numbers"><code class="language-text">     1.Parser  ：请求是由页面的html解析时发送
     2.Redirect：请求是由页面重定向发送<br/>
     3.script  ：请求是由script脚本处理发送<br/>
     4.other   ：请求是由其他过程发送的，比如页面里的Link链接点击
</code></pre></li>
<li><p>size/content：size是响应头部和响应体结合的大小，content是请求解码后的大小</p></li>
</ul>

<h2 id="toc_7">7.请求文件具体说明</h2>

<p>点击某个具体请求后的界面，如下图所示：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001203.png" alt="img"/></p>

<p>一共分为四个模块：</p>

<ul>
<li>Headers</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001207.png" alt="img"/></p>

<p>Header面板列出资源的请求url、HTTP方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等</p>

<ul>
<li>Preview：预览面板，用于资源的预览。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001211.png" alt="img"/></p>

<ul>
<li>Response：响应信息面板包含资源还未进行格式处理的内容</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001215.png" alt="img"/></p>

<ul>
<li>Timing：资源请求的详细信息花费时间</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001220.png" alt="img"/></p>

<h2 id="toc_8">8.细节补充</h2>

<p>对某请求右键，出现页面如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210120001225.png" alt="img"/></p>

<ul>
<li><p>Copy Request Headers：复制HTTP请求头到系统剪贴板</p></li>
<li><p>Copy Response Headers：复制HTTP响应头到系统剪贴板</p></li>
<li><p>Copy Response：复制HTTP响应内容到系统剪贴板</p></li>
<li><p>Copy as<br/>
cURL：将网络请求作为一个curl的命令字符复制到系统剪贴板(curl是一种开源的命令行工具和库，用于配合url语法进行数据传输)</p></li>
<li><p>Copy All as HAR：将网络请求记录信息以HAR格式复制到系统剪贴板(what is HAR file)</p></li>
<li><p>Save as HAR with Content：将资源的所有的网络信息保存到HAR文件中(.har文件)</p></li>
<li><p>Clear Browser Cache：清除浏览器缓存</p></li>
<li><p>Clear Browser Cookies：清除浏览器cookies</p></li>
<li><p>Open in Sources Panel：当前选中资源在Sources面板打开</p></li>
<li><p>Open Link in New Tab：在新tab打开资源链接</p></li>
<li><p>Copy Link Address：复制资源url到系统剪贴板</p></li>
</ul>

<p>若将所有的网络信息保存到HAR文件中，点击<a href="https://ericduran.github.io/chromeHAR/">这里</a>，可上传查看</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629001.html">
                
                  <h1>[Pycharm 常用快捷键]</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">常用快捷键</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl + Q</td>
<td>快速查看文档</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>显示错误描述或警告信息</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>行注释（可选中多行）</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>代码格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>自动导入</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>自动缩进</td>
</tr>
<tr>
<td>Tab / Shift + Tab</td>
<td>缩进、不缩进当前行（可选中多行）</td>
</tr>
<tr>
<td>Ctrl+C/Ctrl+Insert</td>
<td>复制当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制选定的区域</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>换行（不用鼠标操作了）</td>
</tr>
<tr>
<td>Ctrl +Ｊ</td>
<td>插入模版</td>
</tr>
<tr>
<td>Ctrl + Shift +/-</td>
<td>展开/折叠全部代码块</td>
</tr>
<tr>
<td>Ctrl + Numpad+</td>
<td>全部展开</td>
</tr>
<tr>
<td>Ctrl + Numpad-</td>
<td>全部折叠</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除到字符结束</td>
</tr>
<tr>
<td>Ctrl + Backspace</td>
<td>删除到字符开始</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮。</td>
</tr>
<tr>
<td>Alt + up/down</td>
<td>方法上移或下移动</td>
</tr>
<tr>
<td>Alt + Shift + up/down</td>
<td>当前行上移或下移动</td>
</tr>
<tr>
<td>Ctrl + B/鼠标左键</td>
<td>转到方法定义处</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选中增加的代码块</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>方法或变量重命名</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>最近访问的文件</td>
</tr>
<tr>
<td>Esc</td>
<td>从其他窗口回到编辑窗口</td>
</tr>
<tr>
<td>Shift + Esc</td>
<td>隐藏当前窗口，焦点到编辑窗口</td>
</tr>
<tr>
<td>F12</td>
<td>回到先前的工具窗口</td>
</tr>
<tr>
<td>Ctrl + Shift + up</td>
<td>快速上移某一行</td>
</tr>
<tr>
<td>Ctrl + Shift + down</td>
<td>快速下移某一行</td>
</tr>
<tr>
<td>ctrl+alt+左箭头</td>
<td>返回上一个光标的位置（CTRL进入函数后返回）</td>
</tr>
<tr>
<td>ctrl+alt+右箭头</td>
<td>前进到后一个光标的位置</td>
</tr>
</tbody>
</table>

<h1 id="toc_1">全部快捷键</h1>

<h2 id="toc_2">1、编辑（Editing）</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl + Space</td>
<td>基本的代码完成（类、方法、属性）</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>快速导入任意类</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>语句完成</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>参数信息（在方法中调用参数）</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>快速查看文档</td>
</tr>
<tr>
<td>Shift + F1</td>
<td>外部文档</td>
</tr>
<tr>
<td>Ctrl + 鼠标</td>
<td>简介</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>显示错误描述或警告信息</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>自动生成代码</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>重新方法</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>选中</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>行注释</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>块注释</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选中增加的代码块</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>回到之前状态</td>
</tr>
<tr>
<td>Ctrl + Shift + ]/[</td>
<td>选定代码块结束、开始</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>快速修正</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>代码格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>自动导入</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>自动缩进</td>
</tr>
<tr>
<td>Tab / Shift + Tab</td>
<td>缩进、不缩进当前行</td>
</tr>
<tr>
<td>Ctrl+X/Shift+Delete</td>
<td>剪切当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl+C/Ctrl+Insert</td>
<td>复制当前行或选定的代码块到剪贴板</td>
</tr>
<tr>
<td>Ctrl+V/Shift+Insert</td>
<td>从剪贴板粘贴</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>从最近的缓冲区粘贴</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制选定的区域或行到后面或下一行</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>添加智能线</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能线切割</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>下一行另起一行</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>在选定的区域或代码块间切换</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除到字符结束</td>
</tr>
<tr>
<td>Ctrl + Backspace</td>
<td>删除到字符开始</td>
</tr>
<tr>
<td>Ctrl + Numpad+/-</td>
<td>展开折叠代码块</td>
</tr>
<tr>
<td>Ctrl + Numpad+</td>
<td>全部展开</td>
</tr>
<tr>
<td>Ctrl + Numpad-</td>
<td>全部折叠</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭运行的选项卡</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">2、查找/替换(Search/Replace)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>F3</td>
<td>下一个</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>前一个</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>替换</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>全局查找</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>全局替换</td>
</tr>
</tbody>
</table>

<h2 id="toc_4">3、运行(Running)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt + Shift + F10</td>
<td>运行模式配置</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>调试模式配置</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>运行</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>调试</td>
</tr>
<tr>
<td>Ctrl + Shift + F10</td>
<td>运行编辑器配置</td>
</tr>
<tr>
<td>Ctrl + Alt + R</td>
<td>运行manage.py任务</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">4、调试(Debugging)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>F8</td>
<td>跳过</td>
</tr>
<tr>
<td>F7</td>
<td>进入</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>退出</td>
</tr>
<tr>
<td>Alt + F9</td>
<td>运行游标</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>验证表达式</td>
</tr>
<tr>
<td>Ctrl + Alt + F8</td>
<td>快速验证表达式</td>
</tr>
<tr>
<td>F9</td>
<td>恢复程序</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>断点开关</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>查看断点</td>
</tr>
</tbody>
</table>

<h2 id="toc_6">5、导航(Navigation)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl + N</td>
<td>跳转到类</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>跳转到符号</td>
<td></td>
</tr>
<tr>
<td>Alt + Right/Left</td>
<td>跳转到下一个、前一个编辑的选项卡</td>
<td></td>
</tr>
<tr>
<td>F12</td>
<td>回到先前的工具窗口</td>
<td></td>
</tr>
<tr>
<td>Esc</td>
<td>从其他窗口回到编辑窗口</td>
<td></td>
</tr>
<tr>
<td>Shift + Esc</td>
<td>隐藏当前窗口，焦点到编辑窗口</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + F4</td>
<td>关闭主动运行的选项卡</td>
<td></td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>查看当前行号、字符号</td>
<td></td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>最近访问的文件</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Alt+Left/Right</td>
<td>后退、前进</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Shift+Backspace</td>
<td>导航到最近编辑区域</td>
<td></td>
</tr>
<tr>
<td>Alt + F1</td>
<td>查找当前文件或标识</td>
<td></td>
</tr>
<tr>
<td>Ctrl+B / Ctrl+Click</td>
<td>跳转到声明</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>跳转到实现</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>查看快速定义</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明</td>
<td></td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>跳转到父方法、父类</td>
<td></td>
</tr>
<tr>
<td>Alt + Up/Down</td>
<td>跳转到上一个、下一个方法</td>
<td></td>
</tr>
<tr>
<td>Ctrl + ]/[</td>
<td>跳转到代码块结束、开始</td>
<td></td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出文件结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>类型层次结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>方法层次结构</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次结构</td>
<td></td>
</tr>
<tr>
<td>F2 / Shift + F2</td>
<td>下一条、前一条高亮的错误</td>
<td></td>
</tr>
<tr>
<td>F4 / Ctrl + Enter</td>
<td>编辑资源、查看资源</td>
<td></td>
</tr>
<tr>
<td>Alt + Home</td>
<td>显示导航条F11书签开关</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Shift +F11</td>
<td>书签助记开关</td>
<td></td>
</tr>
<tr>
<td>Ctrl #[0-9]</td>
<td>+</td>
<td>跳转到标识的书签</td>
</tr>
<tr>
<td>Shift +</td>
<td>F11显示书签</td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="toc_7">6、搜索相关(Usage Search)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt + F7/Ctrl + F7</td>
<td>文件中查询用法</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>文件中用法高亮显示</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示用法</td>
</tr>
</tbody>
</table>

<h2 id="toc_8">7、重构(Refactoring)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>F5</td>
<td>复制</td>
</tr>
<tr>
<td>F6</td>
<td>剪切</td>
</tr>
<tr>
<td>Alt + Delete</td>
<td>安全删除</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>方法或变量重命名</td>
</tr>
<tr>
<td>Ctrl + F6</td>
<td>更改签名</td>
</tr>
<tr>
<td>Ctrl + Alt + N</td>
<td>内联</td>
</tr>
<tr>
<td>Ctrl + Alt + M</td>
<td>提取方法</td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>提取属性</td>
</tr>
<tr>
<td>Ctrl + Alt + F</td>
<td>提取字段</td>
</tr>
<tr>
<td>Ctrl + Alt + C</td>
<td>提取常量</td>
</tr>
<tr>
<td>Ctrl + Alt + P</td>
<td>提取参数</td>
</tr>
</tbody>
</table>

<h2 id="toc_9">8、控制VCS/Local History</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl + K</td>
<td>提交项目</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>更新项目</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近的变化</td>
</tr>
<tr>
<td>Alt + BackQuote(’)VCS</td>
<td>快速弹出</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>当前行使用模版</td>
</tr>
</tbody>
</table>

<h2 id="toc_10">9、模版(Live Templates)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl + Alt + J</td>
<td>当前行使用模版</td>
</tr>
<tr>
<td>Ctrl +Ｊ</td>
<td>插入模版</td>
</tr>
</tbody>
</table>

<h2 id="toc_11">10、基本(General)</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt + #[0-9]</td>
<td>打开相应编号的工具窗口</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>最大化编辑开关</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到最喜欢</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>根据配置检查当前文件</td>
</tr>
<tr>
<td>Ctrl + BackQuote(’)</td>
<td>快速切换当前计划</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开设置页</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找编辑器里所有的动作</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>在窗口间进行切换</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144704.html">
                
                  <h1>[如何在 Linux 中减少/缩小 LVM 大小（逻辑卷调整）]</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>减少/缩小逻辑卷是数据损坏的最高风险。</p>

<p>所以，如果可能的话，尽量避免这种情况，但如果没有其他选择的话，那就继续。</p>

<p>缩减 LVM 之前，建议先做一个备份。</p>

<p>当你在 LVM 中的磁盘空间耗尽时，你可以通过缩小现有的没有使用全部空间的 LVM，而不是增加一个新的物理磁盘，在卷组上腾出一些空闲空间。</p>

<p><strong>需要注意的是：</strong> 在 GFS2 或者 XFS 文件系统上不支持缩小。</p>

<p>如果你是逻辑卷管理 （LVM） 的新手，我建议你从我们之前的文章开始学习。</p>

<ul>
<li><strong>第一部分：[如何在 Linux 中创建/配置 LVM（逻辑卷管理）]</strong></li>
<li><strong>第二部分：[如何在 Linux 中扩展/增加 LVM（逻辑卷调整）]</strong></li>
</ul>

<p><img src="G:%5CSynologyCloud%5CMy%20MarkDown%5Cimages%5C210610kikq1xynfje7hjaa.jpeg" alt="210610kikq1xynfje7hjaa.jpeg"/></p>

<p>减少逻辑卷涉及以下步骤：</p>

<ul>
<li>卸载文件系统</li>
<li>检查文件系统是否有任何错误</li>
<li>缩小文件系统的大小</li>
<li>缩小逻辑卷的大小</li>
<li>重新检查文件系统是否存在错误（可选）</li>
<li>挂载文件系统</li>
<li>检查减少后的文件系统大小</li>
</ul>

<p><strong>比如：</strong> 你有一个 <strong>100GB</strong> 的没有使用全部空间的 LVM，你想把它减少到 <strong>80GB</strong>，这样 <strong>20GB</strong> 可以用于其他用途。</p>

<pre class="line-numbers"><code class="language-text"># df -h /testlvm1
 

 
Filesystem              Size Used Avail Use% Mounted on
 
/dev/mapper/vg01-lv002  100G 15G  85G   12%  /testlvm1
 
</code></pre>

<h3 id="toc_0">卸载文件系统</h3>

<p>使用 <code>umount</code> 命令卸载文件系统：</p>

<pre class="line-numbers"><code class="language-text"># umount /testlvm1
 
</code></pre>

<h3 id="toc_1">检查文件系统是否有任何错误</h3>

<p>使用 <code>e2fsck</code> 命令检查文件系统是否有错误：</p>

<pre class="line-numbers"><code class="language-text"># e2fsck -f /dev/mapper/vg01-lv002
 

 
e2fsck 1.42.9 (28-Dec-2013)
 
Pass 1: Checking inodes, blocks, and sizes
 
Pass 2: Checking directory structure
 
Pass 3: Checking directory connectivity
 
Pass 4: Checking reference counts
 
Pass 5: Checking group summary information
 
/dev/mapper/vg01-lv002: 13/6553600 files (0.0% non-contiguous), 12231854/26212352 blocks
 
</code></pre>

<h3 id="toc_2">缩小文件系统</h3>

<p>下面的命令将把 <code>testlvm1</code> 文件系统从 <strong>100GB</strong> 缩小到 <strong>80GB</strong>。</p>

<p><strong>文件系统大小调整的常用语法（<code>resize2fs</code>）</strong>：</p>

<pre class="line-numbers"><code class="language-text">resize2fs [现有逻辑卷名] [新的文件系统大小]
 
</code></pre>

<p>实际命令如下：</p>

<pre class="line-numbers"><code class="language-text"># resize2fs /dev/mapper/vg01-lv002 80G
 

 
resize2fs 1.42.9 (28-Dec-2013)
 
Resizing the filesystem on /dev/mapper/vg01-lv002 to 28321400 (4k) blocks.
 
The filesystem on /dev/mapper/vg01-lv002 is now 28321400 blocks long.
 
</code></pre>

<h3 id="toc_3">减少逻辑卷 （LVM） 容量</h3>

<p>现在使用 <code>lvreduce</code> 命令缩小逻辑卷（LVM） 的大小。通过下面的命令， <code>/dev/mapper/vg01-lv002</code> 将把逻辑卷 （LVM） 从 100GB 缩小到 80GB。</p>

<p><strong>LVM 缩减 （<code>lvreduce</code>） 的常用语法</strong>：</p>

<pre class="line-numbers"><code class="language-text">lvreduce [新的 LVM 大小] [现有逻辑卷名称]
 
</code></pre>

<p>实际命令如下：</p>

<pre class="line-numbers"><code class="language-text"># lvreduce -L 80G /dev/mapper/vg01-lv002
 

 
WARNING: Reducing active logical volume to 80.00 GiB
 
THIS MAY DESTROY YOUR DATA (filesystem etc.)
 
Do you really want to reduce lv002? [y/n]: y
 
Reducing logical volume lv002 to 80.00 GiB
 
Logical volume lv002 successfully resized
 
</code></pre>

<h3 id="toc_4">可选：检查文件系统是否有错误</h3>

<p>缩减 LVM 后再次检查文件系统是否有错误：</p>

<pre class="line-numbers"><code class="language-text"># e2fsck -f /dev/mapper/vg01-lv002
 

 
e2fsck 1.42.9 (28-Dec-2013)
 
Pass 1: Checking inodes, blocks, and sizes
 
Pass 2: Checking directory structure
 
Pass 3: Checking directory connectivity
 
Pass 4: Checking reference counts
 
Pass 5: Checking group summary information
 
/dev/mapper/vg01-lv002: 13/4853600 files (0.0% non-contiguous), 1023185/2021235 blocks
 
</code></pre>

<h3 id="toc_5">挂载文件系统并检查缩小后的大小</h3>

<p>最后挂载文件系统，并检查缩小后的文件系统大小。</p>

<p>使用 <code>mount</code> 命令[挂载逻辑卷]：</p>

<pre class="line-numbers"><code class="language-text"># mount /testlvm1
 
</code></pre>

<p>使用 [df 命令]检查挂载的卷。</p>

<pre class="line-numbers"><code class="language-text"># df -h /testlvm1
 

 
Filesystem              Size Used Avail Use% Mounted on
 
/dev/mapper/vg01-lv002  80G  15G  65G   18%  /testlvm1
 
</code></pre>

<hr/>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628475.html">
                
                  <h1>Anaconda + VSCode 最详细教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，同时也是为了让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<p>现在 Python 的广告可谓铺天盖地，文章、朋友圈、各种网页基本都能看到，虽然有些广告确实夸大了 Python 的作用，标题很雷人，但是无论如何也反映了一种趋势，未来编程思维很重要。而我们看待 Python 等编程语言应保持客观，能够帮到自己那就值得花点时间学习，入门之后才知道是不是自己的菜。</p>

<h2 id="toc_1">「戏」说 Python</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225635.png" alt="img"/></p>

<h2 id="toc_2">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，因为封装成 EXE 不方便调试和更新，同时也是让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<h2 id="toc_3">一、Anaconda 下载</h2>

<p>Anaconda 可以看做Python的一个集成安装，安装它后就默认安装了python、IPython、集成开发环境Spyder和众多的包和模块，让你在管理环境和包时更加方便。</p>

<p>可以选择从官网或清华源下载 Anaconda 安装包，<strong>清华源</strong>下载速度相对较快。</p>

<p>安装的位数推荐32位，兼容性最强，也可以根据自己的系统位数选择安装。</p>

<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anaconda.com%2Fproducts%2Findividual">https://www.anaconda.com/products/individual</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225643.png" alt="img"/></p>

<p>清华源：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fanaconda%2Farchive%2F">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225646.png" alt="img"/></p>

<h2 id="toc_4">二、Anaconda 安装</h2>

<p>安装过程中三个注意的地方：</p>

<ul>
<li>勾选 <code>Alls Users</code></li>
<li>勾选 <code>Add Anaconda to the system PATH environment variable</code></li>
<li>如果之前没有安装 VSCode，可以在 Anaconda 安装过程中选择安装</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225654.gif" alt="img"/></p>

<h2 id="toc_5">三、VSCode 下载安装</h2>

<p>Anaconda 安装过程中 VSCode 有时候可能会出错，导致安装失败，这种情况下可以选择从 VSCode 官网下载安装。</p>

<p>VSCode官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com%2FDownload%23">https://code.visualstudio.com/Download#</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225658.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225700.gif" alt="img"/></p>

<h2 id="toc_6">四、管理 conda</h2>

<h3 id="toc_7">1. 查看 conda 版本</h3>

<p>安装完成后按<code>Win+R</code>打开<code>cmd</code>终端，输入<code>conda --version</code></p>

<p>如果正常输出了 conda 的版本，说明 Anaconda 成功安装了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225704.gif" alt="img"/></p>

<h3 id="toc_8">2. 添加国内源</h3>

<ul>
<li>查看现有源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --show-sources
</code></pre>

<ul>
<li>添加国内清华源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</code></pre>

<ul>
<li>删除默认源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --remove channels defaults
</code></pre>

<ul>
<li>设置搜索时显示通道地址</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --set show_channel_urls yes
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225707.gif" alt="img"/></p>

<h3 id="toc_9">3. 升级 conda</h3>

<p>设置完国内源后，升级 conda 的速度会快很多，之后安装包时也会从国内源下载。</p>

<pre class="line-numbers"><code class="language-text">conda update conda
</code></pre>

<p>升级时弹出<code>Proceed ([y]/n)?</code>时，选择<code>y</code>，确认升级。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225711.gif" alt="img"/></p>

<h2 id="toc_10">五、环境管理</h2>

<p><strong>可跳过，直接用默认环境</strong></p>

<h3 id="toc_11">1. 查看 Python 版本</h3>

<pre class="line-numbers"><code class="language-text">python --version
</code></pre>

<h3 id="toc_12">2. 创建环境</h3>

<p>上一步查到我电脑上的 Python 版本为 3.7.0 ，我想在这个版本基础上创建一个名为 [虚拟环境名] 的虚拟环境。</p>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] python=3.7.0
</code></pre>

<p>新的开发环境会被默认安装在你 conda 目录下的 envs 文件目录下。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225714.gif" alt="img"/></p>

<h3 id="toc_13">3. 激活环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_14">4. 列出所有的环境</h3>

<pre class="line-numbers"><code class="language-text">conda info -e
</code></pre>

<p>当前激活的环境会标<code>*</code>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225718.png" alt="img"/></p>

<h3 id="toc_15">5. 切换到另一个环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_16">6. 注销当前环境（默认的环境是base）</h3>

<pre class="line-numbers"><code class="language-text">deactivate
虚拟环境激活后，在cmd中输入python，显示的就是一个新的环境。
</code></pre>

<h3 id="toc_17">7. 复制环境</h3>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] --clone [参考环境名]

---常用 
conda env --help    #查看帮助
conda env list  #列出所有的虚拟环境
conda list --name [虚拟环境名]   #查看指定虚拟环境下的package

#创建
conda create --name [虚拟环境名] [python的版本] [需要的包]
conda create --name myenv
conda create --name myenv python=2.7
conda create --name myenv pytohon=2.7 numpy scipy

#克隆
conda create --name [虚拟环境名] -- clone [clone的环境]

#创建一个和原python环境一样的虚拟环境
conda create --name mybase --clone base



</code></pre>

<h3 id="toc_18">8. 删除环境</h3>

<pre class="line-numbers"><code class="language-text">conda remove --name [虚拟环境名] -all
</code></pre>

<h2 id="toc_19">六、包管理</h2>

<h3 id="toc_20">1. 查看已安装包</h3>

<pre class="line-numbers"><code class="language-text">conda list
</code></pre>

<h3 id="toc_21">2. 使用 Conda 命令安装包</h3>

<pre class="line-numbers"><code class="language-text">conda install beautifulsoup4
</code></pre>

<h3 id="toc_22">3. 通过 pip 命令来安装包</h3>

<p>如果无法通过conda安装，可以用pip命令来安装包。</p>

<pre class="line-numbers"><code class="language-text">pip install beautifulsoup4
</code></pre>

<h3 id="toc_23">4. 移除包</h3>

<pre class="line-numbers"><code class="language-text">conda remove beautifulsoup4
</code></pre>

<h2 id="toc_24">七、VSCode 配置</h2>

<h3 id="toc_25">1. 安装 Python 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225724.png" alt="img"/></p>

<h3 id="toc_26">2. 安装 Code Runner 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225727.png" alt="img"/></p>

<h3 id="toc_27">3. 安装中文插件（可选）</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225729.png" alt="img"/></p>

<h3 id="toc_28">4. 指定路径（可跳过）</h3>

<p>确定当前激活环境所在路径</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225732.png" alt="img"/></p>

<p>然后在<code>File--&gt;Preferences--&gt;Settings--&gt;Extensions--&gt;Python--&gt;setting.json</code>添加下面的 Python 路径，这个路径和你设置的环境名称有关。</p>

<pre class="line-numbers"><code class="language-text">&quot;python.pythonPath&quot; :&quot;D:\\anaconda3\\envs\\xiaolvshijie\\python.exe&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225734.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225741.png" alt="img"/></p>

<h2 id="toc_29">八、开始运行 Py 文件</h2>

<p>运行代码前一定要按<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>或者用快捷键<code>Ctrl + Alt + N</code>执行代码。</p>

<h3 id="toc_30">1. 运行简单代码测试</h3>

<pre class="line-numbers"><code class="language-text">print(&#39;hello xiaolvshijie&#39;)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225744.gif" alt="img"/></p>

<h3 id="toc_31">2. 运行 Py 文件</h3>

<p>复制下面这段代码到编辑器中，<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>执行代码。</p>

<pre class="line-numbers"><code class="language-python">import prettytable as pt

tb = pt.PrettyTable()
tb.field_names = [&#39;Author&#39;, &#39;wwcheng&#39;]
tb.add_row([&#39;ID&#39;, &#39;xiaolvshijie&#39;])

print(tb)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225753.gif" alt="img"/></p>

<p>会出现报错提示：<code>ModuleNotFoundError: No module named &#39;prettytable&#39;</code></p>

<p>意思是当前环境中缺少<code>prettytable</code>的包，你需要安装这个包。。</p>

<p>我们可以用<code>conda install prettytable</code>或者<code>pip install prettytable</code>来安装这个包。</p>

<p>如果不知道报错提示的意思，可以利用<strong>搜索引擎</strong>，百度一下你就知道，Python编程相关的问题网络上基本都能搜索到。</p>

<h2 id="toc_32">结语</h2>

<p>成功安装 Anaconda 和 VSCode 并运行上面测试代码后，你可以正常加入码农行业。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177589969503.html">
                
                  <h1>Anaconda + VSCode 最详细教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，同时也是为了让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<p>现在 Python 的广告可谓铺天盖地，文章、朋友圈、各种网页基本都能看到，虽然有些广告确实夸大了 Python 的作用，标题很雷人，但是无论如何也反映了一种趋势，未来编程思维很重要。而我们看待 Python 等编程语言应保持客观，能够帮到自己那就值得花点时间学习，入门之后才知道是不是自己的菜。</p>

<h2 id="toc_1">「戏」说 Python</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225635.png" alt="img"/></p>

<h2 id="toc_2">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，因为封装成 EXE 不方便调试和更新，同时也是让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<h2 id="toc_3">一、Anaconda 下载</h2>

<p>Anaconda 可以看做Python的一个集成安装，安装它后就默认安装了python、IPython、集成开发环境Spyder和众多的包和模块，让你在管理环境和包时更加方便。</p>

<p>可以选择从官网或清华源下载 Anaconda 安装包，<strong>清华源</strong>下载速度相对较快。</p>

<p>安装的位数推荐32位，兼容性最强，也可以根据自己的系统位数选择安装。</p>

<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anaconda.com%2Fproducts%2Findividual">https://www.anaconda.com/products/individual</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225643.png" alt="img"/></p>

<p>清华源：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fanaconda%2Farchive%2F">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225646.png" alt="img"/></p>

<h2 id="toc_4">二、Anaconda 安装</h2>

<p>安装过程中三个注意的地方：</p>

<ul>
<li>勾选 <code>Alls Users</code></li>
<li>勾选 <code>Add Anaconda to the system PATH environment variable</code></li>
<li>如果之前没有安装 VSCode，可以在 Anaconda 安装过程中选择安装</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225654.gif" alt="img"/></p>

<h2 id="toc_5">三、VSCode 下载安装</h2>

<p>Anaconda 安装过程中 VSCode 有时候可能会出错，导致安装失败，这种情况下可以选择从 VSCode 官网下载安装。</p>

<p>VSCode官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com%2FDownload%23">https://code.visualstudio.com/Download#</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225658.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225700.gif" alt="img"/></p>

<h2 id="toc_6">四、管理 conda</h2>

<h3 id="toc_7">1. 查看 conda 版本</h3>

<p>安装完成后按<code>Win+R</code>打开<code>cmd</code>终端，输入<code>conda --version</code></p>

<p>如果正常输出了 conda 的版本，说明 Anaconda 成功安装了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225704.gif" alt="img"/></p>

<h3 id="toc_8">2. 添加国内源</h3>

<ul>
<li>查看现有源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --show-sources
</code></pre>

<ul>
<li>添加国内清华源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</code></pre>

<ul>
<li>删除默认源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --remove channels defaults
</code></pre>

<ul>
<li>设置搜索时显示通道地址</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --set show_channel_urls yes
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225707.gif" alt="img"/></p>

<h3 id="toc_9">3. 升级 conda</h3>

<p>设置完国内源后，升级 conda 的速度会快很多，之后安装包时也会从国内源下载。</p>

<pre class="line-numbers"><code class="language-text">conda update conda
</code></pre>

<p>升级时弹出<code>Proceed ([y]/n)?</code>时，选择<code>y</code>，确认升级。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225711.gif" alt="img"/></p>

<h2 id="toc_10">五、环境管理</h2>

<p><strong>可跳过，直接用默认环境</strong></p>

<h3 id="toc_11">1. 查看 Python 版本</h3>

<pre class="line-numbers"><code class="language-text">python --version
</code></pre>

<h3 id="toc_12">2. 创建环境</h3>

<p>上一步查到我电脑上的 Python 版本为 3.7.0 ，我想在这个版本基础上创建一个名为 [虚拟环境名] 的虚拟环境。</p>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] python=3.7.0
</code></pre>

<p>新的开发环境会被默认安装在你 conda 目录下的 envs 文件目录下。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225714.gif" alt="img"/></p>

<h3 id="toc_13">3. 激活环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_14">4. 列出所有的环境</h3>

<pre class="line-numbers"><code class="language-text">conda info -e
</code></pre>

<p>当前激活的环境会标<code>*</code>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225718.png" alt="img"/></p>

<h3 id="toc_15">5. 切换到另一个环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_16">6. 注销当前环境（默认的环境是base）</h3>

<pre class="line-numbers"><code class="language-text">deactivate
虚拟环境激活后，在cmd中输入python，显示的就是一个新的环境。
</code></pre>

<h3 id="toc_17">7. 复制环境</h3>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] --clone [参考环境名]

---常用 
conda env --help    #查看帮助
conda env list  #列出所有的虚拟环境
conda list --name [虚拟环境名]   #查看指定虚拟环境下的package

#创建
conda create --name [虚拟环境名] [python的版本] [需要的包]
conda create --name myenv
conda create --name myenv python=2.7
conda create --name myenv pytohon=2.7 numpy scipy

#克隆
conda create --name [虚拟环境名] -- clone [clone的环境]

#创建一个和原python环境一样的虚拟环境
conda create --name mybase --clone base



</code></pre>

<h3 id="toc_18">8. 删除环境</h3>

<pre class="line-numbers"><code class="language-text">conda remove --name [虚拟环境名] -all
</code></pre>

<h2 id="toc_19">六、包管理</h2>

<h3 id="toc_20">1. 查看已安装包</h3>

<pre class="line-numbers"><code class="language-text">conda list
</code></pre>

<h3 id="toc_21">2. 使用 Conda 命令安装包</h3>

<pre class="line-numbers"><code class="language-text">conda install beautifulsoup4
</code></pre>

<h3 id="toc_22">3. 通过 pip 命令来安装包</h3>

<p>如果无法通过conda安装，可以用pip命令来安装包。</p>

<pre class="line-numbers"><code class="language-text">pip install beautifulsoup4
</code></pre>

<h3 id="toc_23">4. 移除包</h3>

<pre class="line-numbers"><code class="language-text">conda remove beautifulsoup4
</code></pre>

<h2 id="toc_24">七、VSCode 配置</h2>

<h3 id="toc_25">1. 安装 Python 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225724.png" alt="img"/></p>

<h3 id="toc_26">2. 安装 Code Runner 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225727.png" alt="img"/></p>

<h3 id="toc_27">3. 安装中文插件（可选）</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225729.png" alt="img"/></p>

<h3 id="toc_28">4. 指定路径（可跳过）</h3>

<p>确定当前激活环境所在路径</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225732.png" alt="img"/></p>

<p>然后在<code>File--&gt;Preferences--&gt;Settings--&gt;Extensions--&gt;Python--&gt;setting.json</code>添加下面的 Python 路径，这个路径和你设置的环境名称有关。</p>

<pre class="line-numbers"><code class="language-text">&quot;python.pythonPath&quot; :&quot;D:\\anaconda3\\envs\\xiaolvshijie\\python.exe&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225734.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225741.png" alt="img"/></p>

<h2 id="toc_29">八、开始运行 Py 文件</h2>

<p>运行代码前一定要按<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>或者用快捷键<code>Ctrl + Alt + N</code>执行代码。</p>

<h3 id="toc_30">1. 运行简单代码测试</h3>

<pre class="line-numbers"><code class="language-text">print(&#39;hello xiaolvshijie&#39;)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225744.gif" alt="img"/></p>

<h3 id="toc_31">2. 运行 Py 文件</h3>

<p>复制下面这段代码到编辑器中，<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>执行代码。</p>

<pre class="line-numbers"><code class="language-python">import prettytable as pt

tb = pt.PrettyTable()
tb.field_names = [&#39;Author&#39;, &#39;wwcheng&#39;]
tb.add_row([&#39;ID&#39;, &#39;xiaolvshijie&#39;])

print(tb)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225753.gif" alt="img"/></p>

<p>会出现报错提示：<code>ModuleNotFoundError: No module named &#39;prettytable&#39;</code></p>

<p>意思是当前环境中缺少<code>prettytable</code>的包，你需要安装这个包。。</p>

<p>我们可以用<code>conda install prettytable</code>或者<code>pip install prettytable</code>来安装这个包。</p>

<p>如果不知道报错提示的意思，可以利用<strong>搜索引擎</strong>，百度一下你就知道，Python编程相关的问题网络上基本都能搜索到。</p>

<h2 id="toc_32">结语</h2>

<p>成功安装 Anaconda 和 VSCode 并运行上面测试代码后，你可以正常加入码农行业。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15838967255194.html">
                
                  <h1>Docker 必备可视化工具 Portainer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>​   推荐使用 Portainer 作为 docker 容器的 GUI 管理方案。</p>

<blockquote>
<p>Portainer 是一个开源、轻量级 Docker 管理用户界面，基于 Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm 集群和服务等集中管理和操作、登录用户管理和控制等功能。</p>
</blockquote>

<p>​   官方地址：<a href="https://portainer.io/install.html">https://portainer.io/install.html</a></p>

<h3 id="toc_0"><strong>安装命令：</strong></h3>

<pre class="line-numbers"><code class="language-text">docker volume create portainer_data
docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>

<p>访问你的 IP:9000 即可进入容器管理页面。如果是本机的话访问地址就是: http:localhost:9000</p>

<h3 id="toc_1"><strong>运行效果:</strong></h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200311114555.jpg" alt="Docker 必备可视化工具"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200311114738.jpg" alt="Docker 必备可视化工具"/></p>

<h3 id="toc_2">参考资料：</h3>

<p>docker：轻量级图形页面管理之 Portainer: <a href="https://blog.51cto.com/ganbing/2083051">https://blog.51cto.com/ganbing/2083051</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628611.html">
                
                  <h1>docker的28个常用指令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>1，查看Docker的版本详细信息。</p>

<pre class="line-numbers"><code class="language-undefined">docker version
</code></pre>

<p>2，查看Docker系统信息，包括镜像和容器数。</p>

<pre class="line-numbers"><code class="language-undefined">docker info
</code></pre>

<p>3，登陆到一个Docker镜像仓库。</p>

<pre class="line-numbers"><code class="language-undefined">docker login -u 用户名 -p 密码；
</code></pre>

<p>4，退出到一个Docker镜像仓库。</p>

<pre class="line-numbers"><code class="language-bash">docker logout
</code></pre>

<p>5，从镜像仓库中拉取或者更新指定镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker pull 
</code></pre>

<blockquote>
<p>说明：<br/>
-a :拉取所有 tagged 镜像；<br/>
docker pull 镜像名字 例：docker pull python；<br/>
docker pull 镜像名字：版本号 例：docker pull python:3.6。</p>
</blockquote>

<p>6，将本地的镜像上传到镜像仓库,要先登陆到镜像仓库；</p>

<pre class="line-numbers"><code class="language-undefined">docker push
</code></pre>

<blockquote>
<p>说明：<br/>
docker push 镜像名字 例：docker push python；<br/>
docker push 镜像名字：版本号 例：docker push python：v1。</p>
</blockquote>

<p>7，从Docker Hub查找镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker search
</code></pre>

<blockquote>
<p>--no-trunc :显示完整的镜像描述；<br/>
-s :列出收藏数不小于指定值的镜像；<br/>
docker search 镜像名字 例 ：docker search python。</p>
</blockquote>

<p>8，创建一个新的容器并运行一个命令；</p>

<pre class="line-numbers"><code class="language-undefined">docker run
</code></pre>

<blockquote>
<p>说明<br/>
-d: 后台运行容器，并返回容器ID；<br/>
-i: 以交互模式运行容器，通常与 -t 同时使用；<br/>
-p: 端口映射，格式为：主机(宿主)端口:容器端口<br/>
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br/>
-v: 目录映射；<br/>
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；<br/>
--env-file=[]: 从指定文件读入环境变量；<br/>
--restart=[]:重启策略：<br/>
a、no，默认策略，在容器退出时不重启容器；<br/>
b、on-failure，在容器非正常退出时（退出状态非0），才会重启容器；<br/>
c、on-failure:3，在容器非正常退出时重启容器，最多重启3次；<br/>
d、always，在容器退出时总是重启容器；<br/>
e、unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器。<br/>
例：sudo docker run -itd \ 后台运行进入容器 --name=wssc \ 为容器起一个名字 --restart=always \ 退出时重启 --env-file ./env.list \ 需在当前目录下的env.list运行 -p 8011:80 \ 端口号映射 -v /var/www/project/data:/var/www/project/data \ 挂载 wellaac/wsscr:v1 镜像名字</p>
</blockquote>

<p>9，启动一个或多个已经被停止的容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker start
</code></pre>

<blockquote>
<p>docker start 容器名字 例：docker start wssc。</p>
</blockquote>

<p>10，停止一个运行中的容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker stop
</code></pre>

<blockquote>
<p>docker stop 容器名字 例：docker wssc；<br/>
docker stop $(docker ps -a -q) 停止所有容器。</p>
</blockquote>

<p>11,重启容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker restart
</code></pre>

<blockquote>
<p>docker restart 容器名字 例：docker restart wssc。</p>
</blockquote>

<p>12，删除一个或多少容器</p>

<pre class="line-numbers"><code class="language-undefined">docker rm
</code></pre>

<blockquote>
<p>说明<br/>
-f :强制删除一个运行中的容器；<br/>
-v :-v 删除与容器关联的卷；<br/>
docker rm 容器名字 例：docker rm wssc<br/>
docker rm -f 容器名字 例：docker rm -f wssc。</p>
</blockquote>

<p>13，在运行的容器中执行命令；</p>

<pre class="line-numbers"><code class="language-bash">docker exec
</code></pre>

<blockquote>
<p>说明<br/>
-i :即使没有附加也保持STDIN 打开；<br/>
-t :分配一个伪终端；<br/>
docker exec -it 容器名字 /bin/bash 例：docker exec -it wssc /bin/bash</p>
</blockquote>

<p>14，列出容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker ps
</code></pre>

<blockquote>
<p>说明<br/>
-a :显示所有的容器，包括未运行的；<br/>
--format :指定返回值的模板文件；<br/>
-l :显示最近创建的容器；<br/>
-n :列出最近创建的n个容器；<br/>
--no-trunc :不截断输出；<br/>
-s :显示总的文件大小；<br/>
例：docker ps docker ps -a docker ps -n 5 。</p>
</blockquote>

<p>15， 获取容器/镜像的元数据；</p>

<pre class="line-numbers"><code class="language-undefined">docker inspect
</code></pre>

<blockquote>
<p>docker inspect 镜像名字/容器名字 例：docker inspect wssc 容器 docker inspect wellaac/wsscr:v1 镜像。</p>
</blockquote>

<p>16，查看容器中运行的进程信息；</p>

<pre class="line-numbers"><code class="language-undefined">docker top
</code></pre>

<blockquote>
<p>docker top 容器名字 例：docker top wssc。</p>
</blockquote>

<p>17，获取容器的日志</p>

<pre class="line-numbers"><code class="language-undefined">docker logs
</code></pre>

<blockquote>
<p>说明<br/>
-f : 跟踪日志输出；<br/>
--since :显示某个开始时间的所有日志；<br/>
-t : 显示时间戳；<br/>
--tail :仅列出最新N条容器日志；<br/>
docker logs -f 容器名字；<br/>
例：docker logs -f wssc 跟踪日志输出。</p>
</blockquote>

<p>18，列出指定的容器的端口映射；</p>

<pre class="line-numbers"><code class="language-undefined">docker port
</code></pre>

<blockquote>
<p>docker port 容器名字；例：docker port wssc。</p>
</blockquote>

<p>19，从容器创建一个新的镜像</p>

<pre class="line-numbers"><code class="language-undefined">docker commit
</code></pre>

<blockquote>
<p>说明<br/>
-a :提交的镜像作者；<br/>
-c :使用Dockerfile指令来创建镜像；<br/>
-m :提交时的说明文字；<br/>
-p :在commit时，将容器暂停；<br/>
docker commit -a &#39;nihao.com&#39; -m&#39;xiawang&#39; 容器 新的镜像；<br/>
例：docker commit -a &#39;nihao.com&#39; -m&#39;xiawang&#39; q8da8ds7ads1 wssc:v1。</p>
</blockquote>

<p>20，用于容器与主机间的数据拷贝;</p>

<pre class="line-numbers"><code class="language-undefined">docker cp
</code></pre>

<blockquote>
<p>docker cp 主机路径 53543d59db8a:容器里面的路径；<br/>
例：docker cp /home/python/index.html 53543d59db8a:/var/www/html ；<br/>
docker cp 53543d59db8a:容器里面的路径 主机路径；<br/>
例：docker cp 53543d59db8a:/var/www/html ./pytho。</p>
</blockquote>

<p>21，检查容器里文件结构的更改；</p>

<pre class="line-numbers"><code class="language-undefined">docker diff
</code></pre>

<blockquote>
<p>docker diff 容器名字 例：docker diff wssc。</p>
</blockquote>

<p>22，列出本地镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker image
</code></pre>

<blockquote>
<p>说明<br/>
-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br/>
--no-trunc :显示完整的镜像信息；<br/>
-q :只显示镜像ID；<br/>
例：docker images -a docker images -q。</p>
</blockquote>

<p>23，删除本地一个或多少镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker rmi
</code></pre>

<blockquote>
<p>说明<br/>
-f :强制删除；<br/>
docker rmi 容器名字 例：docker rmi wssc；<br/>
docker rmi -f 容器名字 例：docker rmi -f wssc。</p>
</blockquote>

<p>24，标记本地镜像，将其归入某一仓库[重新命名]</p>

<pre class="line-numbers"><code class="language-undefined">docker tag
</code></pre>

<blockquote>
<p>说明：<br/>
重新命名的可以直接上传到自己的docker仓库里面；<br/>
docker tag 镜像名字 镜像名字：v1；<br/>
例：docker tag ubuntu wellqa/web:v1。</p>
</blockquote>

<p>25，命令用于使用 Dockerfile 创建镜像</p>

<pre class="line-numbers"><code class="language-undefined">docker build
</code></pre>

<blockquote>
<p>说明<br/>
--tag, -t: 镜像的名字及标签；<br/>
最后一点别漏；<br/>
需要在dockerfile目录下执行；<br/>
docker -t 镜像名字 . ；<br/>
例：docker build -t wellass/web:v1. 。</p>
</blockquote>

<p>26，查看指定镜像的创建历史；</p>

<pre class="line-numbers"><code class="language-bash">docker history
</code></pre>

<blockquote>
<p>说明<br/>
-H :以可读的格式打印镜像大小和日期，默认为true；<br/>
--no-trunc :显示完整的提交记录；<br/>
-q :仅列出提交记录ID；<br/>
docker history 镜像名字；<br/>
例：docker history wellass/web:v1。</p>
</blockquote>

<p>27，将指定镜像保存成 tar.gz</p>

<pre class="line-numbers"><code class="language-undefined">docker save
</code></pre>

<blockquote>
<p>说明<br/>
-o :输出到的文件；<br/>
docker save 镜像名字 -o tar.gz文件；<br/>
例：docker save python:3.6 -o ./wellaas_python.tar.gz。</p>
</blockquote>

<p>28，将从tar归档文件或者标准输入载入镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker load
</code></pre>

<blockquote>
<p>说明<br/>
-i :从tar归档文件中读取；<br/>
docker load -i tar.gz文件；<br/>
例：docker load -i ./wellaas_python.tar.gz；（CentOS）<br/>
例：docker image load -i ./wellaas_python.tar.gz。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177589969445.html">
                
                  <h1>docker的28个常用指令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>1，查看Docker的版本详细信息。</p>

<pre class="line-numbers"><code class="language-undefined">docker version
</code></pre>

<p>2，查看Docker系统信息，包括镜像和容器数。</p>

<pre class="line-numbers"><code class="language-undefined">docker info
</code></pre>

<p>3，登陆到一个Docker镜像仓库。</p>

<pre class="line-numbers"><code class="language-undefined">docker login -u 用户名 -p 密码；
</code></pre>

<p>4，退出到一个Docker镜像仓库。</p>

<pre class="line-numbers"><code class="language-bash">docker logout
</code></pre>

<p>5，从镜像仓库中拉取或者更新指定镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker pull 
</code></pre>

<blockquote>
<p>说明：<br/>
-a :拉取所有 tagged 镜像；<br/>
docker pull 镜像名字 例：docker pull python；<br/>
docker pull 镜像名字：版本号 例：docker pull python:3.6。</p>
</blockquote>

<p>6，将本地的镜像上传到镜像仓库,要先登陆到镜像仓库；</p>

<pre class="line-numbers"><code class="language-undefined">docker push
</code></pre>

<blockquote>
<p>说明：<br/>
docker push 镜像名字 例：docker push python；<br/>
docker push 镜像名字：版本号 例：docker push python：v1。</p>
</blockquote>

<p>7，从Docker Hub查找镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker search
</code></pre>

<blockquote>
<p>--no-trunc :显示完整的镜像描述；<br/>
-s :列出收藏数不小于指定值的镜像；<br/>
docker search 镜像名字 例 ：docker search python。</p>
</blockquote>

<p>8，创建一个新的容器并运行一个命令；</p>

<pre class="line-numbers"><code class="language-undefined">docker run
</code></pre>

<blockquote>
<p>说明<br/>
-d: 后台运行容器，并返回容器ID；<br/>
-i: 以交互模式运行容器，通常与 -t 同时使用；<br/>
-p: 端口映射，格式为：主机(宿主)端口:容器端口<br/>
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br/>
-v: 目录映射；<br/>
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；<br/>
--env-file=[]: 从指定文件读入环境变量；<br/>
--restart=[]:重启策略：<br/>
a、no，默认策略，在容器退出时不重启容器；<br/>
b、on-failure，在容器非正常退出时（退出状态非0），才会重启容器；<br/>
c、on-failure:3，在容器非正常退出时重启容器，最多重启3次；<br/>
d、always，在容器退出时总是重启容器；<br/>
e、unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器。<br/>
例：sudo docker run -itd \ 后台运行进入容器 --name=wssc \ 为容器起一个名字 --restart=always \ 退出时重启 --env-file ./env.list \ 需在当前目录下的env.list运行 -p 8011:80 \ 端口号映射 -v /var/www/project/data:/var/www/project/data \ 挂载 wellaac/wsscr:v1 镜像名字</p>
</blockquote>

<p>9，启动一个或多个已经被停止的容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker start
</code></pre>

<blockquote>
<p>docker start 容器名字 例：docker start wssc。</p>
</blockquote>

<p>10，停止一个运行中的容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker stop
</code></pre>

<blockquote>
<p>docker stop 容器名字 例：docker wssc；<br/>
docker stop $(docker ps -a -q) 停止所有容器。</p>
</blockquote>

<p>11,重启容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker restart
</code></pre>

<blockquote>
<p>docker restart 容器名字 例：docker restart wssc。</p>
</blockquote>

<p>12，删除一个或多少容器</p>

<pre class="line-numbers"><code class="language-undefined">docker rm
</code></pre>

<blockquote>
<p>说明<br/>
-f :强制删除一个运行中的容器；<br/>
-v :-v 删除与容器关联的卷；<br/>
docker rm 容器名字 例：docker rm wssc<br/>
docker rm -f 容器名字 例：docker rm -f wssc。</p>
</blockquote>

<p>13，在运行的容器中执行命令；</p>

<pre class="line-numbers"><code class="language-bash">docker exec
</code></pre>

<blockquote>
<p>说明<br/>
-i :即使没有附加也保持STDIN 打开；<br/>
-t :分配一个伪终端；<br/>
docker exec -it 容器名字 /bin/bash 例：docker exec -it wssc /bin/bash</p>
</blockquote>

<p>14，列出容器；</p>

<pre class="line-numbers"><code class="language-undefined">docker ps
</code></pre>

<blockquote>
<p>说明<br/>
-a :显示所有的容器，包括未运行的；<br/>
--format :指定返回值的模板文件；<br/>
-l :显示最近创建的容器；<br/>
-n :列出最近创建的n个容器；<br/>
--no-trunc :不截断输出；<br/>
-s :显示总的文件大小；<br/>
例：docker ps docker ps -a docker ps -n 5 。</p>
</blockquote>

<p>15， 获取容器/镜像的元数据；</p>

<pre class="line-numbers"><code class="language-undefined">docker inspect
</code></pre>

<blockquote>
<p>docker inspect 镜像名字/容器名字 例：docker inspect wssc 容器 docker inspect wellaac/wsscr:v1 镜像。</p>
</blockquote>

<p>16，查看容器中运行的进程信息；</p>

<pre class="line-numbers"><code class="language-undefined">docker top
</code></pre>

<blockquote>
<p>docker top 容器名字 例：docker top wssc。</p>
</blockquote>

<p>17，获取容器的日志</p>

<pre class="line-numbers"><code class="language-undefined">docker logs
</code></pre>

<blockquote>
<p>说明<br/>
-f : 跟踪日志输出；<br/>
--since :显示某个开始时间的所有日志；<br/>
-t : 显示时间戳；<br/>
--tail :仅列出最新N条容器日志；<br/>
docker logs -f 容器名字；<br/>
例：docker logs -f wssc 跟踪日志输出。</p>
</blockquote>

<p>18，列出指定的容器的端口映射；</p>

<pre class="line-numbers"><code class="language-undefined">docker port
</code></pre>

<blockquote>
<p>docker port 容器名字；例：docker port wssc。</p>
</blockquote>

<p>19，从容器创建一个新的镜像</p>

<pre class="line-numbers"><code class="language-undefined">docker commit
</code></pre>

<blockquote>
<p>说明<br/>
-a :提交的镜像作者；<br/>
-c :使用Dockerfile指令来创建镜像；<br/>
-m :提交时的说明文字；<br/>
-p :在commit时，将容器暂停；<br/>
docker commit -a &#39;nihao.com&#39; -m&#39;xiawang&#39; 容器 新的镜像；<br/>
例：docker commit -a &#39;nihao.com&#39; -m&#39;xiawang&#39; q8da8ds7ads1 wssc:v1。</p>
</blockquote>

<p>20，用于容器与主机间的数据拷贝;</p>

<pre class="line-numbers"><code class="language-undefined">docker cp
</code></pre>

<blockquote>
<p>docker cp 主机路径 53543d59db8a:容器里面的路径；<br/>
例：docker cp /home/python/index.html 53543d59db8a:/var/www/html ；<br/>
docker cp 53543d59db8a:容器里面的路径 主机路径；<br/>
例：docker cp 53543d59db8a:/var/www/html ./pytho。</p>
</blockquote>

<p>21，检查容器里文件结构的更改；</p>

<pre class="line-numbers"><code class="language-undefined">docker diff
</code></pre>

<blockquote>
<p>docker diff 容器名字 例：docker diff wssc。</p>
</blockquote>

<p>22，列出本地镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker image
</code></pre>

<blockquote>
<p>说明<br/>
-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br/>
--no-trunc :显示完整的镜像信息；<br/>
-q :只显示镜像ID；<br/>
例：docker images -a docker images -q。</p>
</blockquote>

<p>23，删除本地一个或多少镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker rmi
</code></pre>

<blockquote>
<p>说明<br/>
-f :强制删除；<br/>
docker rmi 容器名字 例：docker rmi wssc；<br/>
docker rmi -f 容器名字 例：docker rmi -f wssc。</p>
</blockquote>

<p>24，标记本地镜像，将其归入某一仓库[重新命名]</p>

<pre class="line-numbers"><code class="language-undefined">docker tag
</code></pre>

<blockquote>
<p>说明：<br/>
重新命名的可以直接上传到自己的docker仓库里面；<br/>
docker tag 镜像名字 镜像名字：v1；<br/>
例：docker tag ubuntu wellqa/web:v1。</p>
</blockquote>

<p>25，命令用于使用 Dockerfile 创建镜像</p>

<pre class="line-numbers"><code class="language-undefined">docker build
</code></pre>

<blockquote>
<p>说明<br/>
--tag, -t: 镜像的名字及标签；<br/>
最后一点别漏；<br/>
需要在dockerfile目录下执行；<br/>
docker -t 镜像名字 . ；<br/>
例：docker build -t wellass/web:v1. 。</p>
</blockquote>

<p>26，查看指定镜像的创建历史；</p>

<pre class="line-numbers"><code class="language-bash">docker history
</code></pre>

<blockquote>
<p>说明<br/>
-H :以可读的格式打印镜像大小和日期，默认为true；<br/>
--no-trunc :显示完整的提交记录；<br/>
-q :仅列出提交记录ID；<br/>
docker history 镜像名字；<br/>
例：docker history wellass/web:v1。</p>
</blockquote>

<p>27，将指定镜像保存成 tar.gz</p>

<pre class="line-numbers"><code class="language-undefined">docker save
</code></pre>

<blockquote>
<p>说明<br/>
-o :输出到的文件；<br/>
docker save 镜像名字 -o tar.gz文件；<br/>
例：docker save python:3.6 -o ./wellaas_python.tar.gz。</p>
</blockquote>

<p>28，将从tar归档文件或者标准输入载入镜像；</p>

<pre class="line-numbers"><code class="language-undefined">docker load
</code></pre>

<blockquote>
<p>说明<br/>
-i :从tar归档文件中读取；<br/>
docker load -i tar.gz文件；<br/>
例：docker load -i ./wellaas_python.tar.gz；（CentOS）<br/>
例：docker image load -i ./wellaas_python.tar.gz。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16177589969532.html">**用好VSCode这13款插件和8个快捷键**</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025628955.html">1000行MySQL学习笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144586.html">[Chrome浏览器F12开发者工具简单使用]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025629001.html">[Pycharm 常用快捷键]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144704.html">[如何在 Linux 中减少/缩小 LVM 大小（逻辑卷调整）]</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
