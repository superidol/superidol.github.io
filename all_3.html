<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15998025629089.html">
                
                  <h1>Please put new translation README files here.</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>To start a new translation, please:</p>

<ol>
<li>Make an issue (for collaboration with other translators)</li>
<li>Make a pull request to collaborate and commit to.</li>
<li>Let me know when it&#39;s ready to pull.</li>
</ol>

<p>Thank you!</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629135.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Translations:</h2>

<ul>
<li><a href="media/15998025629135/README.md">English</a></li>
<li><a href="media/15998025629135/README-es.md">Español</a></li>
<li><a href="media/15998025629135/README-fr.md">Français</a></li>
<li><a href="media/15998025629135/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629135/README-cn.md">中文版</a></li>
<li><a href="media/15998025629135/README-ja.md">日本語</a></li>
<li><a href="media/15998025629135/README-ko.md">한국어</a></li>
<li><a href="media/15998025629135/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629135/README-gr.md">Greek</a></li>
<li><a href="media/15998025629135/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629135/README-pl.md">Polish</a></li>
<li><a href="media/15998025629135/README-ru.md">Русский</a></li>
<li><a href="media/15998025629135/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629135/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">什么是正则表达式?</h2>

<blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p>
</blockquote>

<p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.<br/>
例如&quot;Regular expression&quot;是一个完整的句子, 但我们常使用缩写的术语&quot;regex&quot;或&quot;regexp&quot;.<br/>
正则表达式可以用来替换文本中的字符串,验证形式,提取字符串等等.</p>

<p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br/>
我们使用以下正则表达式来验证一个用户名:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-cn.png" alt="Regular expression"><br/>
</p></p>

<p>以上的正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>.<br/>
但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.</p>

<h1 id="toc_2">目录</h1>

<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">1. 基本匹配</a></li>
<li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">2. 元字符</a>
<ul>
<li><a href="#21-%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-">2.1 点运算符 .</a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">2.2 字符集</a>
<ul>
<li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">2.2.1 否定字符集</a></li>
</ul></li>
<li><a href="#23-%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0">2.3 重复次数</a>
<ul>
<li><a href="#231--%E5%8F%B7">2.3.1 * 号</a></li>
<li><a href="#232--%E5%8F%B7">2.3.2   号</a></li>
<li><a href="#233--%E5%8F%B7">2.3.3 ? 号</a></li>
</ul></li>
<li><a href="#24--%E5%8F%B7">2.4 {} 号</a></li>
<li><a href="#25--%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4">2.5 (...) 特征标群</a></li>
<li><a href="#26--%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6">2.6 | 或运算符</a></li>
<li><a href="#27-%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">2.7 转码特殊字符</a></li>
<li><a href="#28-%E9%94%9A%E7%82%B9">2.8 锚点</a>
<ul>
<li><a href="#281--%E5%8F%B7">2.8.1 ^ 号</a></li>
<li><a href="#282--%E5%8F%B7">2.8.2 $ 号</a></li>
</ul></li>
</ul></li>
<li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">3. 简写字符集</a></li>
<li><a href="#4-%E5%89%8D%E5%90%8E%E5%85%B3%E8%81%94%E7%BA%A6%E6%9D%9F%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5">4. 前后关联约束(前后预查)</a>
<ul>
<li><a href="#41--%E5%89%8D%E7%BD%AE%E7%BA%A6%E6%9D%9F%E5%AD%98%E5%9C%A8">4.1 ?=... 前置约束(存在)</a></li>
<li><a href="#42--%E5%89%8D%E7%BD%AE%E7%BA%A6%E6%9D%9F-%E6%8E%92%E9%99%A4">4.2 ?!... 前置约束-排除</a></li>
<li><a href="#43---%E5%90%8E%E7%BD%AE%E7%BA%A6%E6%9D%9F-%E5%AD%98%E5%9C%A8">4.3 ?&lt;= ... 后置约束-存在</a></li>
<li><a href="#44--%E5%90%8E%E7%BD%AE%E7%BA%A6%E6%9D%9F-%E6%8E%92%E9%99%A4">4.4 ?&lt;!... 后置约束-排除</a></li>
</ul></li>
<li><a href="#5-%E6%A0%87%E5%BF%97">5. 标志</a>
<ul>
<li><a href="#51-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive">5.1 忽略大小写 (Case Insensitive)</a></li>
<li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search">5.2 全局搜索 (Global search)</a></li>
<li><a href="#53-%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline">5.3 多行修饰符 (Multiline)</a></li>
</ul></li>
<li><a href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85">额外补充</a></li>
<li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></li>
<li><a href="#%E8%AE%B8%E5%8F%AF%E8%AF%81">许可证</a></li>
</ul>

<h2 id="toc_3">1. 基本匹配</h2>

<p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.<br/>
例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat. 
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p>

<p>正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较.</p>

<p>正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p>

<h2 id="toc_4">2. 元字符</h2>

<p>正则表达式主要依赖于元字符.<br/><br/>
元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>

<table>
<thead>
<tr>
<th style="text-align: center">元字符</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>句号匹配任意单个字符除了换行符.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>字符种类. 匹配方括号内的任意字符.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>否定的字符种类. 匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>匹配&gt;1个重复的+号前的字符.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>匹配num个中括号之前的字符 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>字符集, 匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>或运算符,匹配符号前或后的字符.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>转义字符,用于匹配一些保留的字符 <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 点运算符 <code>.</code></h2>

<p><code>.</code>是元字符中最简单的例子. <br/>
<code>.</code>匹配任意单个字符, 但不匹配换行符.<br/>
例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p>

<h2 id="toc_6">2.2 字符集</h2>

<p>字符集也叫做字符类.<br/>
方括号用来指定一个字符集.<br/>
在方括号中使用连字符来指定字符集的范围.<br/>
在方括号中的字符集不关心顺序.<br/>
例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p>

<p>方括号的句号就表示句号.<br/>
表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p>

<h3 id="toc_7">2.2.1 否定字符集</h3>

<p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br/>
例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p>

<h2 id="toc_8">2.3 重复次数</h2>

<p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数. <br/>
这些元字符在不同的情况下有着不同的意思.</p>

<h3 id="toc_9">2.3.1 <code>*</code> 号</h3>

<p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br/>
例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p>

<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br/>
<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p>

<h3 id="toc_10">2.3.2 <code>+</code> 号</h3>

<p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次个字符.<br/>
例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p>

<h3 id="toc_11">2.3.3 <code>?</code> 号</h3>

<p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.<br/>
例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p>

<h2 id="toc_12">2.4 <code>{}</code> 号</h2>

<p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.<br/>
例如,  表达式 <code>[0-9]{2,3}</code> 匹配 2~3 位 0~9 的数字.</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p>

<p>我们可以省略第二个参数.<br/>
例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>

<p>如果逗号也省略掉则表示重复固定的次数. <br/>
例如, <code>[0-9]{3}</code> 匹配3位数字</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p>

<h2 id="toc_13">2.5 <code>(...)</code> 特征标群</h2>

<p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>

<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p>

<h2 id="toc_14">2.6 <code>|</code> 或运算符</h2>

<p>或运算符就表示或, 用作判断条件.</p>

<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p>

<h2 id="toc_15">2.7 转码特殊字符</h2>

<p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p>

<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code>.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p>

<h2 id="toc_16">2.8 锚点</h2>

<p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>

<h3 id="toc_17">2.8.1 <code>^</code> 号</h3>

<p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>

<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 应为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>

<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p>

<h3 id="toc_18">2.8.2 <code>$</code> 号</h3>

<p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p>

<p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p>

<h2 id="toc_19">3. 简写字符集</h2>

<p>正则表达式提供一些常用的字符集简写. 如下:</p>

<table>
<thead>
<tr>
<th style="text-align: center">简写</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>匹配所有非空格字符: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. 前后关联约束(前后预查)</h2>

<p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br/>
前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p>

<p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\$)[0-9\.]*</code>.<br/>
这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>

<p>前后关联约束如下:</p>

<table>
<thead>
<tr>
<th style="text-align: center">符号</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>前置约束-存在</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>前置约束-排除</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>后置约束-存在</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>后置约束-排除</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 <code>?=...</code> 前置约束(存在)</h3>

<p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p>

<p>返回结果只瞒住第一部分表达式.<br/>
定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p>

<p>前置约束的内容写在括号中的等号后面.<br/>
例如, 表达式 <code>[T|t]he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>

<pre>
"[T|t]he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p>

<h3 id="toc_22">4.2 <code>?!...</code> 前置约束-排除</h3>

<p>前置约束-排除 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式<br/>
<code>前置约束-排除</code>  定义和 <code>前置约束(存在)</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>. </p>

<p>表达式 <code>[T|t]he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>

<pre>
"[T|t]he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p>

<h3 id="toc_23">4.3 <code>?&lt;= ...</code> 后置约束-存在</h3>

<p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br/>
例如, 表达式 <code>(?&lt;=[T|t]he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>

<pre>
"(?<=[T|t]he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">在线练习</a></p>

<h3 id="toc_24">4.4 <code>?&lt;!...</code> 后置约束-排除</h3>

<p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br/>
例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>

<pre>
"(?&lt;![T|t]he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p>

<h2 id="toc_25">5. 标志</h2>

<p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br/>
这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>

<table>
<thead>
<tr>
<th style="text-align: center">标志</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>忽略大小写.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>全局搜索.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 忽略大小写 (Case Insensitive)</h3>

<p>修饰语 <code>i</code> 用于忽略大小写.<br/>
例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p>

<h3 id="toc_27">5.2 全局搜索 (Global search)</h3>

<p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). <br/>
例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p>

<h3 id="toc_28">5.3 多行修饰符 (Multiline)</h3>

<p>多行修饰符 <code>m</code> 常用于执行一个多行匹配.</p>

<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>

<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示在待检测字符串每行的末尾搜索 <code>at</code>后跟一个或多个 <code>.</code> 的字符串, 并返回全部结果.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p>

<h2 id="toc_29">额外补充</h2>

<ul>
<li><em>正整数</em>: <code>^\d+$</code></li>
<li><em>负整数</em>: <code>^-\d+$</code></li>
<li><em>手机国家号</em>: <code>^+?[\d\s]{3,}$</code></li>
<li><em>手机号</em>: <code>^+?[\d\s]+(?[\d\s]{10,}$</code></li>
<li><em>整数</em>: <code>^-?\d+$</code></li>
<li><em>用户名</em>: <code>^[\w\d_.]{4,16}$</code></li>
<li><em>数字和英文字母</em>: <code>^[a-zA-Z0-9]*$</code></li>
<li><em>数字和应为字母和空格</em>: <code>^[a-zA-Z0-9 ]*$</code></li>
<li><em>密码</em>: <code>^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>
<li><em>邮箱</em>: <code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$</code></li>
<li><em>IP4 地址</em>: <code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>
<li><em>纯小写字母</em>: <code>^([a-z])*$</code></li>
<li><em>纯大写字母</em>: <code>^([A-Z])*$</code></li>
<li><em>URL</em>: <code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li>
<li><em>VISA 信用卡号</em>: <code>^(4[0-9]{12}(?:[0-9]{3})?)*$</code></li>
<li><em>日期 (MM/DD/YYYY)</em>: <code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$</code></li>
<li><em>日期 (YYYY/MM/DD)</em>: <code>^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>
<li><em>MasterCard 信用卡号</em>: <code>^(5[1-5][0-9]{14})*$</code></li>
</ul>

<h2 id="toc_30">贡献</h2>

<ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> 或 <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_31">许可证</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629238.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/twitter/follow/ziishaned.svg?style=social&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://github.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/github/followers/ziishaned.svg?label=Follow%20%40ziishaned&amp;style=social&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Translations:</h2>

<ul>
<li><a href="media/15998025629238/README.md">English</a></li>
<li><a href="media/15998025629238/README-es.md">Español</a></li>
<li><a href="media/15998025629238/README-fr.md">Français</a></li>
<li><a href="media/15998025629238/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629238/README-cn.md">中文版</a></li>
<li><a href="media/15998025629238/README-ja.md">日本語</a></li>
<li><a href="media/15998025629238/README-ko.md">한국어</a></li>
<li><a href="media/15998025629238/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629238/README-gr.md">Greek</a></li>
<li><a href="media/15998025629238/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629238/README-pl.md">Polish</a></li>
<li><a href="media/15998025629238/README-ru.md">Русский</a></li>
<li><a href="media/15998025629238/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629238/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Biểu thức chính quy là gì?</h2>

<blockquote>
<p>Biểu thức chính quy là một nhóm các ký tự hoặc ký hiệu được sử dụng để tìm một mẫu cụ thể từ một văn bản.</p>
</blockquote>

<p>Biểu thức chính quy là một khuôn mẫu được khớp với chuỗi các từ, từ trái sang phải. Từ &quot;Biểu thức chính quy&quot; là một câu cửa miệng, bạn thường sẽ tìm thấy thuật ngữ viết tắt là &quot;regex&quot; hoặc &quot;regexp&quot;. Biểu thức chính quy được sử dụng để thay thế một văn bản trong một chuỗi, xác thực mẫu, trích xuất một chuỗi con từ một chuỗi dựa trên khớp mẫu và hơn thế nữa.</p>

<p>Hãy tưởng tượng bạn đang viết một ứng dụng và bạn muốn đặt quy tắc khi người dùng chọn tên người dùng của họ. Chúng tôi muốn cho phép tên người dùng chứa các chữ cái, số, dấu gạch dưới và dấu gạch nối. Chúng tôi cũng muốn giới hạn số lượng ký tự trong tên người dùng để nó trông không xấu. Chúng tôi sử dụng biểu thức chính quy sau để xác thực tên người dùng:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-en.png" alt="Regular expression"><br/>
</p></p>

<p>Trên biểu thức chính quy có thể chấp nhận các chuỗi <code>john_doe</code>, <code>jo-hn_doe</code> và <code>john12_as</code>. Nó không khớp với <code>Jo</code> vì chuỗi đó chứa chữ hoa và nó quá ngắn.</p>

<h2 id="toc_2">Table of Contents</h2>

<ul>
<li><a href="#1-basic-matchers">Basic Matchers</a></li>
<li><a href="#2-meta-characters">Meta character</a>
<ul>
<li><a href="#21-full-stop">Full stop</a></li>
<li><a href="#22-character-set">Character set</a></li>
<li><a href="#221-negated-character-set">Negated character set</a></li>
<li><a href="#23-repetitions">Repetitions</a></li>
<li><a href="#231-the-star">The Star</a></li>
<li><a href="#232-the-plus">The Plus</a></li>
<li><a href="#233-the-question-mark">The Question Mark</a></li>
<li><a href="#24-braces">Braces</a></li>
<li><a href="#25-character-group">Character Group</a></li>
<li><a href="#26-alternation">Alternation</a></li>
<li><a href="#27-escaping-special-character">Escaping special character</a></li>
<li><a href="#28-anchors">Anchors</a></li>
<li><a href="#281-caret">Caret</a></li>
<li><a href="#282-dollar">Dollar</a></li>
</ul></li>
<li><a href="#3-shorthand-character-sets">Shorthand Character Sets</a></li>
<li><a href="#4-lookaround">Lookaround</a>
<ul>
<li><a href="#41-positive-lookahead">Positive Lookahead</a></li>
<li><a href="#42-negative-lookahead">Negative Lookahead</a></li>
<li><a href="#43-positive-lookbehind">Positive Lookbehind</a></li>
<li><a href="#44-negative-lookbehind">Negative Lookbehind</a></li>
</ul></li>
<li><a href="#5-flags">Flags</a>
<ul>
<li><a href="#51-case-insensitive">Case Insensitive</a></li>
<li><a href="#52-global-search">Global search</a></li>
<li><a href="#53-multiline">Multiline</a></li>
</ul></li>
<li><a href="#6-greedy-vs-lazy-matching">Greedy vs lazy matching</a></li>
</ul>

<h2 id="toc_3">1. Basic Matchers</h2>

<p>Biểu thức chính quy chỉ là một mẫu các ký tự mà chúng ta sử dụng để thực hiện tìm kiếm trong văn bản. Ví dụ, biểu thức chính quy <code>the</code> có nghĩa là: chữ <code>t</code>, tiếp theo là chữ <code>h</code>, tiếp theo là chữ <code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Test the regular expression</a></p>

<p>Biểu thức chính quy <code>123</code> khớp với chuỗi <code>123</code>. Biểu thức chính quy được khớp với chuỗi đầu vào bằng cách so sánh từng ký tự trong biểu thức chính quy với từng ký tự trong chuỗi đầu vào, lần lượt từng ký tự. Biểu thức chính quy thường phân biệt chữ hoa chữ thường nên biểu thức chính quy <code>The</code> sẽ không khớp với chuỗi <code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Test the regular expression</a></p>

<h2 id="toc_4">2. Meta Characters</h2>

<p>Các ký tự <code>meta</code> là các khối xây dựng của các biểu thức chính quy. Các ký tự <code>meta</code> không biểu diễn chính nó mà thay vào đó được diễn giải theo một cách đặc biệt nào đó. Một số ký tự <code>meta</code> có ý nghĩa đặc biệt và được viết bên trong dấu ngoặc vuông. Các ký tự meta như sau:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Meta character</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Khớp với tất cả các kí tự trừ dấu xuống dòng.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Lớp kí tự. Khớp với bất kỳ ký tự nào nằm giữa dấu ngoặc vuông.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Lớp kí tự phủ định. Khớp với bất kỳ ký tự nào không có trong dấu ngoặc vuông.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>Khớp 0 hoặc nhiều lần lặp lại của kí tự trước.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>Khớp 1 hoặc nhiều lần lặp lại của kí tự trước.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>Làm cho kí tự trước tùy chọn.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Braces. Khớp ít nhất là &quot;n&quot; nhưng không nhiều hơn &quot;m&quot; lặp lại của kí tự trước.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Nhóm kí tự. Khớp các ký tự xyz theo thứ tự chính xác đó.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Thay thế. Khớp các ký tự trước hoặc ký tự sau ký hiệu.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Thoát khỏi kí tự tiếp theo. Điều này cho phép bạn khớp các ký tự dành riêng <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Khớp với sự bắt đầu của đầu vào.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Khớp với kết thúc đầu vào.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Full stop</h2>

<p>Full stop <code>.</code>  là ví dụ đơn giản nhất về ký tự meta. Kí tự meta <code>.</code><br/>
khớp với bất kì kí tự nào. Nó sẽ không khớp kí tự trả về (return) hoặc xuống dòng (newline)</p>

<p>Ví dụ, biểu thức chính quy <code>.ar</code> có ý nghĩa: bất kỳ ký tự nào, theo sau là chữ <code>a</code>, tiếp theo là chữ <code>r</code>.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Test the regular expression</a></p>

<h2 id="toc_6">2.2 Character set</h2>

<p>Bộ ký tự cũng được gọi là lớp kí tự. Dấu ngoặc vuông được sử dụng để chỉ định bộ ký tự. Sử dụng dấu gạch nối bên trong bộ ký tự để chỉ định phạm vi của các ký tự. Thứ tự của phạm vi ký tự trong dấu ngoặc vuông không quan trọng. </p>

<p>Ví dụ: biểu thức chính quy <code>[Tt]he</code> có nghĩa là: chữ hoa <code>T</code> hoặc chữ thường <code>t</code>, theo sau là chữ <code>h</code>, tiếp theo là chữ <code>e</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Test the regular expression</a></p>

<p>Tuy nhiên, khoảng thời gian bên trong một bộ ký tự có nghĩa là một khoảng thời gian theo nghĩa đen. Biểu thức chính quy <code>ar[.]</code> Có nghĩa là: ký tự chữ thường <code>a</code>, theo sau là chữ <code>r</code>, theo sau là kí tự <code>.</code> .</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Test the regular expression</a></p>

<h3 id="toc_7">2.2.1 Negated character set</h3>

<p>Nói chung, biểu tượng dấu mũ biểu thị sự bắt đầu của chuỗi, nhưng khi nó được gõ sau dấu ngoặc vuông mở, nó sẽ phủ định bộ ký tự. Ví dụ: biểu thức chính quy <code>[^ c]ar</code> có nghĩa là: bất kỳ ký tự nào ngoại trừ <code>c</code>, theo sau là ký tự <code>a</code>, theo sau là chữ <code>r</code>.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Test the regular expression</a></p>

<h2 id="toc_8">2.3 Repetitions</h2>

<p>Theo dõi các ký tự meta, <code>+</code>, <code>*</code> hoặc <code>?</code> được sử dụng để xác định số lần mô hình con (subpattern) có thể xảy ra. Những kí tự meta này hành động khác nhau trong các tình huống khác nhau.</p>

<h3 id="toc_9">2.3.1 The Star</h3>

<p>Biểu tượng <code>*</code> khớp 0 hoặc nhiều lần lặp lại của trình so khớp trước. Biểu thức chính quy <code>a*</code> có nghĩa là: 0 hoặc nhiều lần lặp lại ký tự chữ thường trước <code>a</code>. Nhưng nếu nó xuất hiện sau một bộ ký tự hoặc lớp thì nó sẽ tìm thấy sự lặp lại của toàn bộ bộ ký tự. Ví dụ: biểu thức chính quy <code>[a-z]*</code> có nghĩa là: bất kỳ số lượng chữ cái viết thường trong một hàng.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Test the regular expression</a></p>

<p>Biểu tượng <code>*</code> có thể được sử dụng với ký tự meta. để khớp với bất kỳ chuỗi ký tự nào <code>.*</code> . Biểu tượng <code>*</code> có thể được sử dụng với ký tự khoảng trắng <code>\s</code> để khớp với một chuỗi các ký tự khoảng trắng. </p>

<p>Ví dụ: biểu thức <code>\s*cat\s*</code> có nghĩa là: không hoặc nhiều khoảng trắng, theo sau là ký tự chữ thường <code>c</code>, theo sau là ký tự chữ thường <code>a</code>, theo sau là ký tự chữ thường <code>t</code>, tiếp theo là 0 hoặc nhiều khoảng trắng.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Test the regular expression</a></p>

<h3 id="toc_10">2.3.2 The Plus</h3>

<p>Biểu tượng <code>+</code> khớp với một hoặc nhiều lần lặp lại của ký tự trước. </p>

<p>Ví dụ: biểu thức chính quy <code>c.+t</code> có nghĩa là: chữ thường chữ <code>c</code>, theo sau là ít nhất một ký tự, tiếp theo là ký tự chữ thường <code>t</code>. Nó cần phải được làm rõ rằng <code>t</code> là <code>t</code> cuối cùng trong câu.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Test the regular expression</a></p>

<h3 id="toc_11">2.3.3 The Question Mark</h3>

<p>Trong biểu thức chính quy các ký tự meta <code>?</code> làm cho ký tự trước là một tùy chọn. Biểu tượng này khớp với 0 hoặc một thể hiện (instance ) của ký tự trước. Ví dụ: biểu thức chính quy <code>[T]?he</code> có nghĩa là: Tùy chọn chữ hoa chữ <code>T</code>, theo sau là ký tự chữ thường <code>h</code>, tiếp theo là ký tự chữ thường <code>e</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Test the regular expression</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Test the regular expression</a></p>

<h2 id="toc_12">2.4 Braces</h2>

<p>Trong các dấu ngoặc nhọn thông thường còn được gọi là bộ định lượng được sử dụng để chỉ định số lần mà một ký tự hoặc một nhóm ký tự có thể được lặp lại. Ví dụ: biểu thức chính quy <code>[0-9]{2,3}</code> có nghĩa là: Ghép ít nhất 2 chữ số nhưng không quá 3 (ký tự trong phạm vi từ 0 đến 9).</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Test the regular expression</a></p>

<p>Chúng ta có thể bỏ qua số thứ hai. Ví dụ: biểu thức chính quy <code>[0-9]{2,}</code> có nghĩa là: Ghép 2 chữ số trở lên. Nếu chúng tôi cũng xóa dấu phẩy, biểu thức chính quy <code>[0-9]{3}</code> có nghĩa là: Ghép chính xác 3 chữ số.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Test the regular expression</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Test the regular expression</a></p>

<h2 id="toc_13">2.5 Capturing Group</h2>

<p>Một nhóm capturing là một nhóm các mẫu con được viết bên trong Dấu ngoặc đơn <code>(...)</code>. Giống như chúng ta đã thảo luận trước đó trong biểu thức chính quy nếu chúng ta đặt một bộ định lượng sau một ký tự thì nó sẽ lặp lại ký tự trước. Nhưng nếu chúng ta đặt bộ định lượng sau một nhóm capturing thì nó lặp lại toàn bộ nhóm capturing. Ví dụ: biểu thức chính quy <code>(ab)*</code> khớp với 0 hoặc nhiều lần lặp lại của ký tự &quot;ab&quot;. Chúng ta cũng có thể sử dụng luân phiên <code>|</code> kí tự meta trong nhóm capturing. Ví dụ: biểu thức chính quy <code>(c|g|p)ar</code> có nghĩa là: ký tự chữ thường <code>c</code>, <code>g</code> hoặc <code>p</code>, theo sau là ký tự <code>a</code>, tiếp theo là ký tự <code>r</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Test the regular expression</a></p>

<p>Lưu ý rằng các nhóm capturing không chỉ khớp mà còn capturing các ký tự để sử dụng trong ngôn ngữ gốc. Ngôn ngữ gốc có thể là python hoặc javascript hoặc hầu như bất kỳ ngôn ngữ nào thực hiện các biểu thức chính quy trong định nghĩa hàm.</p>

<h3 id="toc_14">2.5.1 Non-capturing group</h3>

<p>Nhóm không capturing là nhóm capturing chỉ khớp với các ký tự, nhưng không capturing được nhóm. Một nhóm không capturing được ký hiệu là <code>?</code> theo sau là <code>:</code> trong ngoặc đơn <code>(...)</code>. </p>

<p>Ví dụ: biểu thức chính quy <code>(?:c|g|p)ar</code> tương tự như <code>(c|g|p)ar</code> ở chỗ nó khớp với các ký tự giống nhau nhưng sẽ không tạo nhóm capturing.</p>

<pre>
"(?:c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/Rm7Me8/1">Test the regular expression</a></p>

<p>Các nhóm không capturing có thể có ích khi được sử dụng trong chức năng tìm và thay thế hoặc khi trộn với các nhóm capturing để giữ tổng quan khi sản xuất bất kỳ loại đầu ra nào khác. Xem thêm <a href="#4-lookaround">4. Lookaround</a>. </p>

<h2 id="toc_15">2.6 Alternation</h2>

<p>Trong một biểu thức chính quy, thanh dọc <code>|</code> được sử dụng để xác định xen kẽ. Sự xen kẽ giống như một câu lệnh OR giữa nhiều biểu thức. Bây giờ, bạn có thể nghĩ rằng bộ ký tự và luân phiên hoạt động theo cùng một cách. Nhưng sự khác biệt lớn giữa bộ ký tự và xen kẽ là bộ ký tự hoạt động ở cấp độ ký tự nhưng xen kẽ hoạt động ở cấp độ biểu thức. </p>

<p>Ví dụ: biểu thức chính quy <code>(T|t)he|car</code> có nghĩa là: hoặc (ký tự chữ <code>T</code> hoặc chữ thường <code>t</code>, theo sau là ký tự chữ thường <code>h</code>, tiếp theo là ký tự chữ thường <code>e</code>) OR (ký tự chữ thường <code>c</code>, tiếp theo là ký tự chữ thường <code>a</code>, theo sau bằng ký tự viết thường <code>r</code>). Lưu ý rằng tôi đặt dấu ngoặc đơn cho rõ ràng, để cho thấy rằng một trong hai biểu thức trong ngoặc đơn có thể được đáp ứng và nó sẽ khớp.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Test the regular expression</a></p>

<h2 id="toc_16">2.7 Escaping special character</h2>

<p>Dấu gạch chéo ngược <code>\</code> được sử dụng trong biểu thức chính quy để thoát ký tự tiếp theo. Điều này cho phép chúng tôi chỉ định một biểu tượng là một ký tự phù hợp bao gồm các ký tự dành riêng <code>{} [] / \ *. $ ^ | ?</code> . Để sử dụng một ký tự đặc biệt, ta dùng <code>\</code> làm ký tự trùng khớp trước kí tự ta muốn dùng.</p>

<p>Ví dụ, biểu thức chính quy <code>.</code> được sử dụng để khớp với bất kỳ ký tự nào ngoại trừ dòng mới. Bây giờ để phù hợp <code>.</code> trong một chuỗi đầu vào, biểu thức chính quy <code>(f|c|m)at\.?</code> có nghĩa là: chữ thường <code>f</code>, <code>c</code> hoặc <code>m</code>, theo sau là ký tự chữ thường <code>a</code>, tiếp theo là chữ thường chữ <code>t</code>, theo sau là tùy chọn <code>.</code> tính cách.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Test the regular expression</a></p>

<h2 id="toc_17">2.8 Anchors</h2>

<p>Trong các biểu thức chính quy, chúng tôi sử dụng các anchors để kiểm tra xem biểu tượng phù hợp là biểu tượng bắt đầu hay biểu tượng kết thúc của chuỗi đầu vào. Các anchors có hai loại: Loại thứ nhất là Caret <code>^</code> kiểm tra xem ký tự khớp có phải là ký tự bắt đầu của đầu vào không và loại thứ hai là Dollar <code>$</code> kiểm tra xem ký tự khớp có phải là ký tự cuối cùng của chuỗi đầu vào không.</p>

<h3 id="toc_18">2.8.1 Caret</h3>

<p>Biểu tượng Caret <code>^</code> được sử dụng để kiểm tra xem ký tự khớp có phải là ký tự đầu tiên của chuỗi đầu vào không. Nếu chúng ta áp dụng biểu thức chính quy sau <code>^a</code> ( nếu a là ký hiệu bắt đầu) cho chuỗi đầu vào <code>abc</code> thì nó khớp với <code>a</code>. Nhưng nếu chúng ta áp dụng biểu thức chính quy <code>^b</code> trên chuỗi đầu vào ở trên thì nó không khớp với bất cứ thứ gì. Bởi vì trong chuỗi đầu vào <code>abc</code> &quot;b&quot; không phải là ký hiệu bắt đầu. Chúng ta hãy xem một biểu thức chính quy khác <code>^(T|t)he</code> có nghĩa là: ký tự chữ hoa <code>T</code> hoặc ký tự chữ thường <code>t</code> là ký hiệu bắt đầu của chuỗi đầu vào, tiếp theo là ký tự chữ thường <code>h</code>, tiếp theo là ký tự chữ thường <code>e</code>.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Test the regular expression</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Test the regular expression</a></p>

<h3 id="toc_19">2.8.2 Dollar</h3>

<p>Biểu tượng Dollar <code>$</code> được sử dụng để kiểm tra xem ký tự khớp có phải là ký tự cuối cùng của chuỗi đầu vào không. Ví dụ: biểu thức chính quy <code>(at\.)$</code> có nghĩa là: ký tự chữ thường <code>a</code>, theo sau là ký tự chữ thường <code>t</code>, theo sau là <code>.</code> ký tự và bộ so khớp phải là cuối chuỗi.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Test the regular expression</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Test the regular expression</a></p>

<h2 id="toc_20">3. Shorthand Character Sets</h2>

<p>Biểu thức chính quy cung cấp các shorthand cho các bộ ký tự thường được sử dụng, cung cấp các shorthand thuận tiện cho các biểu thức thông thường được sử dụng. Các bộ ký tự shorthand như sau:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Shorthand</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Bất kỳ kí tự nào ngoại trừ dòng mới</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Khớp các ký tự chữ và số: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Khớp các ký tự không phải chữ và số: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>khớp với số trong khoảng: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Khớp không có chữ số: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Khớp các ký tự khoảng trắng: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Khớp với ký tự không phải khoảng trắng: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_21">4. Lookaround</h2>

<p>Lookbehind và lookahead (còn được gọi là lookaround) là các loại nhóm <strong><em>không capturing</em></strong> cụ thể (Được sử dụng để khớp với mẫu nhưng không được bao gồm trong danh sách phù hợp). <code>Lookarounds</code> sử dụng khi chúng ta có điều kiện mẫu này được đi trước hoặc theo sau bởi một mẫu khác. </p>

<p>Ví dụ: chúng tôi muốn nhận tất cả các số có trước ký tự <code>$</code> từ chuỗi đầu vào sau <code>$4,44 và $10,88</code>. Chúng tôi sẽ sử dụng biểu thức chính quy sau <code>(?&lt;=\$)[0-9\.]*</code> có nghĩa là: lấy tất cả các số có chứa <code>.</code> ký tự và đứng trước ký tự <code>$</code>. Sau đây là những cái nhìn được sử dụng trong các biểu thức thông thường:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Kí hiệu</th>
<th>Mô tả</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Positive Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Negative Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Positive Lookbehind</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Negative Lookbehind</td>
</tr>
</tbody>
</table>

<h3 id="toc_22">4.1 Positive Lookahead</h3>

<p><code>Positive lookahead</code> khẳng định rằng phần đầu tiên của biểu thức phải được theo sau bởi biểu thức <code>lookahead expression</code>. Phần khớp trả về (The returned match) chỉ chứa văn bản được khớp bởi phần đầu tiên của biểu thức. Để xác định một <code>positive lookahead</code>, dấu ngoặc đơn được sử dụng. Trong các dấu ngoặc đơn đó, một dấu hỏi có dấu bằng được sử dụng như thế này: <code>(?=...)</code>. Biểu thức <code>Lookahead</code> được viết sau dấu bằng trong ngoặc đơn. </p>

<p>Ví dụ: biểu thức chính quy <code>(T|t)he(?=\Sfat)</code> có nghĩa là: tùy ý khớp chữ thường chữ <code>t</code> hoặc chữ hoa chữ <code>T</code>, theo sau là chữ <code>h</code>, tiếp theo là chữ <code>e</code>. Trong ngoặc đơn, chúng tôi xác định <code>positive lookahead</code> cho biết công cụ (engine) biểu thức chính quy khớp với <code>The</code> hoặc <code>the</code> cái mà được đứng trước bởi từ <code>fat</code>.</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Test the regular expression</a></p>

<h3 id="toc_23">4.2 Negative Lookahead</h3>

<p><code>Negative lookahead</code> được sử dụng khi chúng ta cần lấy tất cả các kết quả khớp từ chuỗi đầu vào không được theo sau bởi một mẫu. <code>Negative lookahead</code> được định nghĩa giống như chúng ta định nghĩa <code>positive lookahead</code> nhưng sự khác biệt duy nhất là thay vì bằng ký tự <code>=</code> chúng ta sử dụng kí tự phủ định <code>!</code>  tức là <code>(?! ...)</code>. </p>

<p>Chúng ta hãy xem biểu thức chính quy sau đây: <code>(T|t)he(?!\sfat)</code> có nghĩa là: lấy tất cả các từ <code>The</code> hoặc <code>the</code> từ chuỗi đầu vào không được đứng trước bởi từ <code>fat</code> trước một ký tự khoảng trắng.</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Test the regular expression</a></p>

<h3 id="toc_24">4.3 Positive Lookbehind</h3>

<p><code>Positive lookbehind</code> được sử dụng để có được tất cả mẫu khớp cái mà theo sau bởi một mẫu cụ thể. <code>Positive lookbehind</code> được biểu thị bởi <code>(?&lt;=...)</code>. </p>

<p>Ví dụ: biểu thức chính quy <code>(?&lt;=(T|t)he\s)(fat|mat)</code> có nghĩa là: lấy tất cả các từ <code>fat</code> hoặc <code>mat</code> từ chuỗi đầu vào, cái mà sau từ <code>The</code> hoặc <code>the</code>.</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Test the regular expression</a></p>

<h3 id="toc_25">4.4 Negative Lookbehind</h3>

<p><code>Negative lookbehind</code> được sử dụng để có được tất cả các từ khớp không có trước một mẫu cụ thể. <code>Negative lookbehind</code> được ký hiệu là <code>(?&lt;!...)</code>. </p>

<p>Ví dụ: biểu thức chính quy <code>(?&lt;!(T|t)he\s)(cat)</code> có nghĩa là: lấy tất cả các từ <code>cat</code> từ chuỗi đầu vào, không nằm sau từ <code>The</code> hoặc <code>the</code>.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Test the regular expression</a></p>

<h2 id="toc_26">5. Flags</h2>

<p>Cờ (flags) cũng được gọi là bổ nghĩa (modifiers) vì chúng sửa đổi đầu ra của biểu thức chính quy. Các cờ này có thể được sử dụng theo bất kỳ thứ tự hoặc kết hợp nào và là một phần không thể thiếu của RegExp.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Cờ</th>
<th>Mô tả</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Case insensitive: Đặt khớp với mẫu không phân biệt chữ hoa chữ thường.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Global Search: Tìm kiếm một mẫu trong suốt chuỗi đầu vào.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Multiline: ký tự Anchor meta hoạt động trên mỗi dòng.</td>
</tr>
</tbody>
</table>

<h3 id="toc_27">5.1 Case Insensitive</h3>

<p>Công cụ sửa đổi <code>i</code> được sử dụng để thực hiện khớp không phân biệt chữ hoa chữ thường. </p>

<p>Ví dụ: biểu thức chính quy <code>/The/gi</code> có nghĩa là: chữ hoa chữ <code>T</code>, theo sau là ký tự chữ thường <code>h</code>, tiếp theo là ký tự <code>e</code>. Và ở cuối biểu thức chính quy, cờ <code>i</code> báo cho công cụ biểu thức chính quy bỏ qua trường hợp này. Như bạn có thể thấy, chúng tôi cũng đã cung cấp cờ <code>g</code> vì chúng tôi muốn tìm kiếm mẫu trong toàn bộ chuỗi đầu vào.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Test the regular expression</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Test the regular expression</a></p>

<h3 id="toc_28">5.2 Global search</h3>

<p>Công cụ sửa đổi <code>g</code> được sử dụng để thực hiện khớp toàn cầu (tìm tất cả các từ có thể khớp thay vì dừng sau lần khớp đầu tiên). </p>

<p>Ví dụ: biểu thức chính quy <code>/.(at)/g</code> có nghĩa là: bất kỳ ký tự nào ngoại trừ dòng mới, theo sau là ký tự chữ thường <code>a</code>, tiếp theo là ký tự chữ thường <code>t</code>. Vì chúng tôi đã cung cấp cờ <code>g</code> ở cuối biểu thức chính quy nên bây giờ nó sẽ tìm thấy tất cả các kết quả khớp trong chuỗi đầu vào, không chỉ là đầu tiên (là hành vi mặc định).</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Test the regular expression</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Test the regular expression</a></p>

<h3 id="toc_29">5.3 Multiline</h3>

<p>Công cụ sửa đổi <code>m</code> được sử dụng để thực hiện khớp nhiều dòng. Như chúng ta đã thảo luận về các anchors <code>(^, $)</code> trước đó, được sử dụng để kiểm tra xem mẫu là phần đầu của phần đầu vào hay phần cuối của chuỗi đầu vào. Nhưng nếu chúng ta muốn các anchors hoạt động trên mỗi dòng, chúng ta sử dụng cờ <code>m</code>. </p>

<p>Ví dụ: biểu thức chính quy <code>/at(.)?$/gm</code> có nghĩa là: ký tự chữ thường <code>a</code>, theo sau là ký tự chữ thường <code>t</code>, tùy chọn mọi thứ trừ dòng mới. Và vì cờ <code>m</code> bây giờ công cụ biểu thức chính quy khớp với mẫu ở cuối mỗi dòng trong một chuỗi.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Test the regular expression</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Test the regular expression</a></p>

<h2 id="toc_30">6. Greedy vs lazy matching</h2>

<p>Theo mặc định, regex sẽ thực hiện greedy matching, có nghĩa là nó sẽ khớp càng lâu càng tốt. chúng ta có thể sử dụng <code>?</code> để khớp theo cách lười biếng có nghĩa là càng ngắn càng tốt</p>

<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1">Test the regular expression</a></p>

<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/2">Test the regular expression</a></p>

<h2 id="toc_31">Contribution</h2>

<ul>
<li>Open pull request with improvements</li>
<li>Discuss ideas in issues</li>
<li>Spread the word</li>
<li>Reach out with any feedback <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_32">License</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629329.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Çeviriler:</h2>

<ul>
<li><a href="media/15998025629329/README.md">English</a></li>
<li><a href="media/15998025629329/README-es.md">Español</a></li>
<li><a href="media/15998025629329/README-fr.md">Français</a></li>
<li><a href="media/15998025629329/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629329/README-cn.md">中文版</a></li>
<li><a href="media/15998025629329/README-ja.md">日本語</a></li>
<li><a href="media/15998025629329/README-ko.md">한국어</a></li>
<li><a href="media/15998025629329/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629329/README-gr.md">Greek</a></li>
<li><a href="media/15998025629329/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629329/README-pl.md">Polish</a></li>
<li><a href="media/15998025629329/README-ru.md">Русский</a></li>
<li><a href="media/15998025629329/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629329/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Düzenli İfade Nedir?</h2>

<blockquote>
<p>Düzenli ifade, bir metinden belirli bir deseni bulmak için kullanılan bir karakter veya sembol grubudur.</p>
</blockquote>

<p>Bir düzenli ifade soldan sağa söz konusu harf öbekleriyle eşleşen bir desendir.<br/>
&quot;Regular expression&quot; söylemesi zor bir tabir olduğundan dolayı, genellikle<br/>
&quot;regex&quot; ya da &quot;regexp&quot; olarak kısaltılmış olarak bulacaksınız. Düzenli ifade bir<br/>
harf öbeğinde ki bir metin değiştirmek, form doğrulamak, bir desen eşleşmesine<br/>
dayalı harf öbeğinden bir alt harf öbeği ayıklamak ve çok daha fazlası için<br/>
kullanılır.</p>

<p>Bir uygulama yazdığınızı hayal edin ve bir kullanıcı adını seçtiğinde, bu<br/>
kullanıcı adı için kurallar belirlemek istiyorsunuz. Kullanıcı adının harfler,<br/>
sayılar, altçizgiler ve tireler içermesine izin vermek, ayrıca, kullanıcı<br/>
adındaki karakter sayısını sınırlamak istiyorsunuz, böylece çirkin görünmeyecek.<br/>
Böyle durumlarda kullanıcı adını doğrulamak için aşağıdaki düzenli ifadeyi<br/>
kullanıyoruz:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-tr.png" alt="Regular expression"><br/>
</p></p>

<p>Yukardaki düzenli ifade <code>john_doe</code>, <code>jo-hn_doe</code> ve <code>john12_as</code> gibi girişleri kabul edebilir.<br/>
<code>Jo</code> girişi uyuşmaz, çünkü harf öbeği büyük harf içeriyor ve aynı zamanda uzunluğu 3 karakterden az.</p>

<h2 id="toc_2">İçindekiler</h2>

<ul>
<li><a href="#1-temel-e%C5%9Fle%C5%9Ftiriciler">Temel Eşleştiriciler</a></li>
<li><a href="#2-meta-karakterler">Meta Karakterler</a>
<ul>
<li><a href="#21-nokta">Nokta</a></li>
<li><a href="#22-karakter-tak%C4%B1m%C4%B1">Karakter takımı</a></li>
<li><a href="#221-negatiflenmi%C5%9F-karakter-seti">Negatiflenmiş karakter seti</a></li>
<li><a href="#23-tekrarlar">Tekrarlar</a></li>
<li><a href="#231-y%C4%B1ld%C4%B1z-%C4%B0%C5%9Fareti">Yıldız İşareti</a></li>
<li><a href="#232-art%C4%B1-%C4%B0%C5%9Fareti">Artı İşareti</a></li>
<li><a href="#233-soru-%C4%B0%C5%9Fareti">Soru İşareti</a></li>
<li><a href="#24-s%C3%BCsl%C3%BC-parantez">Süslü Parantez</a></li>
<li><a href="#25-karakter-grubu">Karakter Grubu</a></li>
<li><a href="#26-de%C4%9Fi%C5%9Fim">Değişim</a></li>
<li><a href="#27-%C3%96zel-karakter-hari%C3%A7-tutma">Özel Karakter Hariç Tutma</a></li>
<li><a href="#28-sabitleyiciler">Sabitleyiciler</a></li>
<li><a href="#281-%C5%9Eapka-%C4%B0%C5%9Fareti">Ters v işareti</a></li>
<li><a href="#282-dolar-%C4%B0%C5%9Fareti">Dolar işareti</a></li>
</ul></li>
<li><a href="#3-k%C4%B1saltma-karakter-tak%C4%B1mlar%C4%B1">Kısaltma Karakter Takımları</a></li>
<li><a href="#4-bak%C4%B1nmak">Bakınmak</a>
<ul>
<li><a href="#41-positive-lookahead">Olumlu Bakınma</a></li>
<li><a href="#42-negative-lookahead">Olumsuz Bakınma</a></li>
<li><a href="#43-positive-lookbehind">Positive Lookbehind</a></li>
<li><a href="#44-negative-lookbehind">Negative Lookbehind</a></li>
</ul></li>
<li><a href="#5-%C4%B0%C5%9Faretler">İşaretler</a>
<ul>
<li><a href="#51-b%C3%BCy%C3%BCkk%C3%BC%C3%A7%C3%BCk-harf-duyarl%C4%B1l%C4%B1%C4%9F%C4%B1">Büyük/Küçük harf duyarlılığı</a></li>
<li><a href="#52-genel-arama">Bütünsel Arama</a></li>
<li><a href="#53-%C3%87ok-sat%C4%B1rl%C4%B1">Çok satırlı</a></li>
</ul></li>
</ul>

<h2 id="toc_3">1. Temel Eşleştiriciler</h2>

<p>Bir düzenli ifade bir metin içinde arama yapabilmek için kullandığımız bir karakter desenidir.<br/>
Örneğin, <code>the</code> düzenli ifadesi şu anlama gelir: <code>t</code> harfi ardından <code>h</code>, ardından <code>e</code> harfi gelir.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Düzenli ifadeyi test edin</a></p>

<p><code>123</code> düzenli ifadesi <code>123</code> harf öbeğiyle eşleşir. Düzenli ifade birbiri ardına,<br/>
girilen harf öbeğindeki her karakter düzenli ifadenin içindeki her karakterle<br/>
karşılaştırılarak eşleştirilir. Düzenli ifadeler normal olarak büyük/küçük harfe<br/>
duyarlıdırlar, yani <code>The</code> düzenli ifadesi <code>the</code> harf öbeğiyle eşleşmez.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_4">2. Meta Karakterler</h2>

<p>Meta karakterler düzenli ifadelerin yapı taşlarıdırlar. Meta karakterler<br/>
kendileri için değil bunun yerine bazı özel yollarla yorumlanırlar. Bazı meta<br/>
karakterler özel anlamları vardır ve bunlar köşeli parantez içinde yazılırlar.</p>

<p>Meta karakterler aşağıdaki gibidir:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Meta karakter</th>
<th>Açıklama</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Satır sonuç hariç herhangi bir karakterle eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Köşeli parantezler arasında bulunan herhangi bir karakterle eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Köşeli parantez içerisinde yer alan <code>^</code> işaretinden sonra girilen karakterler haricindeki karakterlerle eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>Kendisinden önce yazılan karakterin sıfır veya daha fazla tekrarı ile eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>Kendisinden önce yazılan karakterin bir veya daha fazla olan tekrarı ile eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>Kendisinden önce yazılan karakterin varlık durumunu opsiyonel kılar.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Kendisinden önce yazılan karakterin en az <code>n</code> en fazla <code>m</code> değeri kadar olmasını ifade eder.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Verilen sırayla <code>xyz</code> karakterleriyle eşleşir.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Karakterden önce veya sonra verilen ifadelerin herhangi biriyle eşleşebilir. İfadeye Yada anlamı katar.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td><code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code> özel karakterin aranmasını sağlar.</td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Girilen verinin başlangıcını ifade eder.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Girilen verinin sonunu ifade eder.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Nokta</h2>

<p>Nokta <code>.</code> meta karakterlerin en basit örneğidir. <code>.</code> meta karakteri satır<br/>
başlangıcı hariç herhangi bir karakterle eşleşir. Örneğin, <code>.ar</code> düzenli<br/>
ifadesinin anlamı: herhangi bir karakterin ardından <code>a</code> harfi ve <code>r</code> harfi<br/>
gelir.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_6">2.2 Karakter Takımı</h2>

<p>Karakter takımları aryıca Karakter sınıfı olarak bilinir. Karakter takımlarını<br/>
belirtmek için köşeli ayraçlar kullanılır. Karakterin aralığını belirtmek için<br/>
bir karakter takımında tire kullanın. Köşeli parantezlerdeki karakter aralığının<br/>
sıralaması önemli değildir.</p>

<p>Örneğin, <code>[Tt]he</code> düzenli ifadesinin anlamı: bir büyük <code>T</code> veya küçük <code>t</code><br/>
harflerinin ardından sırasıyla <code>h</code> ve <code>e</code> harfi gelir.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Düzenli ifadeyi test edin</a></p>

<p>Bununla birlikte, bir karakter takımı içerisindeki bir periyot bir tam periyot<br/>
demektir.</p>

<p><code>ar[.]</code> düzenli ifadesinin anlamı: Küçük <code>a</code> karakteri ardından <code>r</code> harfi gelir,<br/>
ardından bir <code>.</code> karakteri gelir.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_7">2.2.1 Negatiflenmiş karakter seti</h3>

<p>Genellikle, şapka <code>^</code> sembolü harf öbeğinin başlangıcını temsil eder, ama köşeli<br/>
parantez içinde kullanıldığında verilen karakter takımını hariç tutar.</p>

<p>Örneğin, <code>[^c]ar</code> ifadesinin anlamı: <code>c</code> harfinden hariç herhangi bir harfin<br/>
ardından <code>a</code>, ardından <code>r</code> gelir.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_8">2.3 Tekrarlar</h2>

<p><code>+</code>, <code>*</code> ya da <code>?</code> meta karakterlerinden sonra bir alt desenin kaç defa tekrar<br/>
edebileceğini belirtmek için kullanılır. Bu meta karakterler farklı durumlarda<br/>
farklı davranırlar.</p>

<h3 id="toc_9">2.3.1 Yıldız İşareti</h3>

<p><code>*</code> sembolü, kendinden önce girilen eşlemenin sıfır veya daha fazla tekrarıyla<br/>
eşleşir. Ama bir karakter seti ya da sınıf sonrasına girildiğinde, tüm karakter<br/>
setinin tekrarlarını bulur.</p>

<p><code>a*</code> düzenli ifadesinin anlamı: <code>a</code> karakterinin sıfır veya daha fazla<br/>
tekrarları, <code>[a-z]*</code> düzenli ifadesinin anlamı ise bir satırdaki herhangi bir<br/>
sayıdaki küçük harfler anlamına gelir.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Düzenli ifadeyi test edin</a></p>

<p><code>*</code> sembolü <code>.</code> meta karakteri ile <code>.*</code> karakterinin herhangi harf öbeğine<br/>
eşleştirmek için kullanılabilir. <code>*</code> sembolü boşluk karakteriyle <code>\s</code> bir harf<br/>
öbeğinde boşluk karakterlerini eşleştirmek için kullanılabilir.</p>

<p>Örneğin, <code>\s*cat\s*</code> düzenli ifadesinin anlamı: sıfır veya daha fazla boşluk<br/>
ardından küçük <code>c</code> karakteri gelir, ardından küçük <code>a</code> karakteri gelir, ardından<br/>
küçük <code>t</code> karakteri gelir, ardından sıfır veya daha fazla boşluk gelir.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_10">2.3.2 Artı İşareti</h3>

<p><code>+</code> sembolü, kendinden önce girilen eşlemenin bir veya daha fazla tekrarıyla<br/>
eşleşir.</p>

<p>Örneğin, <code>c.+t</code> ifadesinin anlamı: küçük <code>c</code> harfi, ardından en az bir karakter<br/>
gelir, ardından küçük <code>t</code> karakteri gelir. Örnekte açıklamak gereken önemli<br/>
nokta: <code>t</code> harfi cümledeki son <code>t</code> harfi olacaktır. <code>c</code> ve <code>t</code> harfi arasında en<br/>
az bir karakter vardır.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_11">2.3.3 Soru İşareti</h3>

<p>Düzenli ifadelerde <code>?</code> meta karakterinden önce girilen karakteri opsiyonel<br/>
olarak tanımlar. Bu sembol önce gelen karakterin sıfır veya bir örbeğiyle<br/>
eşleşir.</p>

<p>Örneğin, <code>[T]?he</code> ifadesinin anlamı: opsiyonel büyük <code>T</code> harfi, ardından küçük<br/>
<code>h</code> karakteri gelir, ardından küçük <code>e</code> karakteri gelir.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Düzenli ifadeyi test edin</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_12">2.4 Süslü Parantez</h2>

<p>Düzenli ifadelerde miktar belirliyiciler olarakda bilinen süslü parantezler, bir<br/>
karakterin veya karakter grubunun kaç defa tekrar edebileceğini belirtmek için<br/>
kullanılırlar.</p>

<p>Örneğin, <code>[0-9]{2,3}</code> ifadesinin anlamı: 0 ile 0 aralığındaki karakterlerden, en<br/>
az 2 en fazla 3 defa ile eşleş.</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Düzenli ifadeyi test edin</a></p>

<p>İkinci numarayı boş bırakabiliriz.</p>

<p>Örneğin, <code>[0-9]{2,}</code> ifadesinin anlamı: En az 2 veya daha fazla defa eşleş.<br/>
Düzenli ifadeden virgülü kaldırırsak <code>[0-9]{3}</code>: doğrudan 3 defa eşleşir.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Düzenli ifadeyi test edin</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_13">2.5 Karakter Grubu</h2>

<p>Karakter grubu parantezler içine yazılmış alt desenler grubudur. Daha önce<br/>
tasarım deseninde değindiğimiz gibi, bir karakterden önce bir miktar belirleyici<br/>
koyarsak önceki karakteri tekrar eder. Fakat miktar belirleyiciyi bir karakter<br/>
grubundan sonra koyarsak tüm karakter grubunu tekrarlar.</p>

<p>Örneğin: <code>(ab)*</code> düzenli ifadesi &quot;ab&quot; karakterinin sıfır veya daha fazla<br/>
tekrarıyla eşleşir.</p>

<p>Ayrıca karakter grubu içinde <code>|</code> meta karakterini kullanabiliriz.</p>

<p>Örneğin, <code>(c|g|p)ar</code> düzenli ifadesinin anlamı: küçük <code>c</code>, <code>g</code> veya <code>p</code><br/>
karakteri, ardından <code>a</code> karakteri, ardından <code>r</code> karakteri gelir.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_14">2.6 Değişim</h2>

<p>Düzenli ifadede dik çizgi alternasyon(değişim, dönüşüm) tanımlamak için<br/>
kullanılır. Alternasyon birden fazla ifade arasındaki bir koşul gibidir. Şu an,<br/>
karakter grubu ve alternasyonun aynı şekilde çalıştığını düşünüyor<br/>
olabilirsiniz. Ama, Karakter grubu ve alternasyon arasındaki büyük fark karakter<br/>
grubu karakter düzeyinde çalışır ama alternasyon ifade düzeyinde çalışır.</p>

<p>Örneğin, <code>(T|t)he|car</code> düzenli ifadesinin anlamı: Büyük <code>T</code> ya da küçük <code>t</code><br/>
karakteri, ardından küçük <code>h</code> karakteri, ardından küçük <code>e</code> ya da <code>c</code> karakteri,<br/>
ardından küçük <code>a</code>, ardından küçük <code>r</code> karakteri gelir.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_15">2.7 Özel Karakter Hariç Tutma</h2>

<p><code>\</code> işareti sonraki karakteri hariç tutmak için kullanılır. Bu bir semboülü<br/>
ayrılmış karakterlerde <code>{ } [ ] / \ + * . $ ^ | ?</code> dahil olmak üzere eşleşen bir<br/>
karakter olarak belirtmemizi sağlar. Bir özel karakteri eşleşen bir karakter<br/>
olarak kullanmak için önüne <code>\</code> işareti getirin.</p>

<p>Örneğin, <code>.</code> düzenli ifadesi yeni satır hariç herhangi bir karakteri eşleştirmek<br/>
için kullanılır. Bir harf öbeği içinde nokta <code>.</code> karakterini yakalamak için <code>.</code><br/>
ayrılmış karakterini hariç tutmamız gerekir. Bunun için nokta önüne <code>\</code><br/>
işaretini koymamız gereklidir.</p>

<p><code>(f|c|m)at\.?</code> düzenli ifadesinin anlamı: küçük <code>f</code>, <code>c</code>ya da <code>m</code> harfi,<br/>
ardından küçük <code>a</code> harfi, ardından küçük <code>t</code> harfi, ardından opsiyonel <code>.</code><br/>
karakteri gelir.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_16">2.8 Sabitleyiciler</h2>

<p>Düzenli ifadelerde, eşleşen sembolün girilen harf öbeğinin başlangıç sembolü<br/>
veya bitiş sembolü olup olmadığını kontrol etmek için sabitleyicileri<br/>
kullanırız. Sabitleyiciler iki çeşittir: İlk çeşit, eşleşen karakterin girişin<br/>
ilk karakteri olup olmadığını kontrol eden şapka <code>^</code> karakteri, ikinci çeşit ise<br/>
eşleşen karakterin girişin son karakteri olup olmadığını kontrol eden dolar <code>$</code><br/>
karakteridir.</p>

<h3 id="toc_17">2.8.1 Şapka İşareti</h3>

<p>Şapka <code>^</code> işareti eşleşen karakterin giriş harf öbeğinin ilk karakteri olup<br/>
olmadığını kontrol etmek için kullanılır. Eğer <code>^a</code> düzenli ifadesini <code>abc</code> harf<br/>
öbeğine uygularsak <code>a</code> ile eşleşir. Ama <code>^b</code> ifadesini uygularsak bir eşleşme<br/>
bulamayız. Bunun nedeni <code>abc</code> harf öbeğinde <code>b</code> karakterinin başlangıç karakteri<br/>
olmamasıdır.</p>

<p>Bir başka örnek üzerinden ilerlersek,</p>

<p><code>^(T|t)he</code> düzenli ifadesinin anlamı: büyük <code>T</code> ya da <code>t</code> karakteri giriş harf<br/>
öbeğinin ilk karakteri olmak üzere, ardından küçük <code>h</code>, ardından küçük <code>e</code><br/>
karakteri gelir.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Düzenli ifadeyi test edin</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_18">2.8.2 Dolar İşareti</h3>

<p>Dolar <code>$</code> işareti eşleşen karakterin giriş harf öbeğinin son karakteri olup<br/>
olmadığını kontrol etmek için kullanılır.</p>

<p>Örneğin, <code>(at\.)$</code> ifadesinin anlamı: küçük bir <code>a</code> karakteri, ardından küçük<br/>
bir <code>t</code> karakteri, ardıdan nokta <code>.</code> karakteri gelir ve bu eşleşme harf öbeğinin<br/>
sonunda olmalıdır.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Düzenli ifadeyi test edin</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_19">3. Kısaltma Karakter Takımları</h2>

<p>Regex, sık olarak kullanılan düzenli ifadeler için özel karakter setleri ve<br/>
kısaltmalar sağlar.</p>

<p>Kullanılan karakter setlerinin kısaltmaları aşağıdaki gibidir:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Kısaltma</th>
<th>Açıklama</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Satır başı hariç herhangi bir karakter</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Alfanumerik karakterlerle eşleşir: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Alfanumerik olmayan karakterlerle eşleşir: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Rakamlarla eşlelir: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Rakam olmayan karakterlerle eşleşir: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Boşluk karakteri ile eşleşir: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Boşluk karakteri olmayan karakterlerle eşleşir: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. Bakınmak</h2>

<p>Bakınma sembolleri, bir ifade öncesinde veya sonrasında başka bir ifademiz<br/>
olduğunda kullanılırlar.</p>

<p>Örneğin, <code>$4.44 ve $10.88</code> girişlerinden <code>$</code> karakteri önündeki tüm sayıları<br/>
almak istiyoruz, bu durumda <code>(?&lt;=\$)[0-9\.]*</code> ifadesini kullanırız.</p>

<p><code>(?&lt;=\$)[0-9\.]*</code> ifadesinin anlamı: <code>.</code> karakterini içeren ve <code>$</code> karakteriyle<br/>
devam eden tüm sayıları al demektir.</p>

<p>Düzenli ifadelerde kullanılan bakınma sembolleri aşadaki gibidir:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Sembol</th>
<th>Açıklama</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Positive Lookahead (Verdiğimiz ifade sonrası arar ve <code>eşleşme varsa</code> sonuç döndürür.)</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Negative Lookahead (Verdiğimiz ifade sonrası arar ve <code>eşleşme yoksa</code> sonuç döndürür.)</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Positive Lookbehind (Verdiğimiz ifade öncesini arar ve <code>eşleşme varsa</code> sonuç döndürür.)</td>
</tr>
<tr>
<td style="text-align: center">?&lt;-!-</td>
<td>Negative Lookbehind Verdiğimiz ifade öncesini arar ve <code>eşleşme yoksa</code> sonuç döndürür.</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 Positive Lookahead</h3>

<p>Positive Lookahead, ifadenin ilk bölümü bakınma ifadesiyle devam etmesi<br/>
gerektiğini savunur. Bulunan eşleşme yalnızca ifadenin ilk bölümüyle eşleşen<br/>
metin içerir. Olumlu bir bakınma tanımlamak için, içinde eşittir işareti yer<br/>
alan parantezler <code>(?=...)</code> şeklinde kullanılır. Bakınma ifadesi parantezler<br/>
içinde eşittir işaretinden sonra yazılır.</p>

<p>Örneğin, <code>[T|t]he(?=\sfat)</code> ifadesinin anlamı: opsiyonel küçük bir <code>t</code> ya da<br/>
büyük <code>T</code> harfi, ardından <code>h</code> harfi gelir, ardından <code>e</code> harfi gelir. Parantez<br/>
içinde ise bu dizilimin bir boşluk karakterinden sonra <code>fat</code> öbeğiyle devam<br/>
edeceğini tanımlıyoruz.</p>

<pre>
"[T|t]he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_22">4.2 Negative Lookahead</h3>

<p>Negative Lookahead sembolü positive lookahead tersine, verdiğimiz desenle devam<br/>
etmemesi durumunda eşleşir. Bu sembol positive lookahead gibi tanımlanır ama <code>=</code><br/>
işareti yerine <code>!</code> kullanılır.</p>

<p><code>[T|t]he(?!\sfat)</code> ifadesinin anlamı: opsiyonel küçük bir <code>t</code> ya da büyük <code>T</code><br/>
harfi, ardından <code>h</code> harfi gelir, ardından <code>e</code> harfi gelir, ardından öncesinde<br/>
boşluk olan bir <code>fat</code> öbeği olmamalıdır.</p>

<pre>
"[T|t]he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_23">4.3 Positive Lookbehind</h3>

<p>Positive Lookbehind, belirli bir desenden önceki eşleşmeleri almak için<br/>
kullanılır. <code>(?&lt;=...)</code> ile gösterilir.</p>

<p>Örneğin, <code>(?&lt;=[T|t]he\s)(fat|mat)</code> ifadesinin anlamı: Öncesinde <code>The</code> veya <code>the</code><br/>
öbekleri olan tüm <code>fat</code> veya <code>mat</code> öbeklerini getir.</p>

<pre>
"(?<=[T|t]he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_24">4.4 Negative Lookbehind</h3>

<p>Negative Lookbehind, belirli bir desenden önce olmayan eşleşmeleri almak için<br/>
kullanılır. <code>(?&lt;=!..)</code> ile gösterilir.</p>

<p>Örneğin, <code>(?&lt;!(T|t)he\s)(cat)</code> ifadesinin anlamı: Öncesinde <code>The</code> veya <code>the</code><br/>
öbekleri yer almayan tüm <code>cat</code> öbeklerini getir.</p>

<pre>
"(?&lt;![T|t]he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_25">5. İşaretler</h2>

<p>İşaretler ayrıca düzenleyiciler olarak bilinirler, çünkü onlar bir düzenli<br/>
ifadenin çıktısını düzenlerler. Bu işaretler herhangi bir sırada veya<br/>
kombinasyonda kullanılabilirler, ve bunlar Düzenli İfadelerin ayrılmaz bir<br/>
parçasıdırlar.</p>

<table>
<thead>
<tr>
<th style="text-align: center">İşaret</th>
<th>Açıklama</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Büyük küçük harf duyarlılık: Eşleştirmeleri küçük/büyük harfe karşı duyarsız yapar.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Genel Arama: Girilen harf öbeği boyunca bir desen arar.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Çok satırlı: Sabitleyici meta karakteri her satırda çalışır.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 Büyük/Küçük harf duyarlılığı</h3>

<p><code>i</code> işaretleyicisi büyük/küçük harfe duyarsız eşleştirme yapmak için kullanılır.</p>

<p>Örneğin, <code>/The/gi</code> ifadesi: büyük <code>T</code> harfi, ardından küçük <code>h</code> harfi, ardından<br/>
küçük <code>e</code> harfi gelir. ifadenin sonunda yer alan <code>i</code> işareti büyük-küçük harfe<br/>
karşı duyarsız olması gerektiğini belirtir. Ayrıca <code>g</code> işaretinide<br/>
kullandığımızı görebilirsiniz, tüm text içinde bu aramayı yapmak istediğimiz<br/>
için <code>g</code> işaretini ayrıca belirtiyoruz.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Düzenli ifadeyi test edin</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_27">5.2 Genel Arama</h3>

<p><code>g</code> işareti bir giriş içinde eşleşen tüm varsayonları bulmak için kullanılır.<br/>
<code>g</code> işareti kullanılmazsa ilk eşleşme bulunduktan sonra arama sona erer.</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Düzenli ifadeyi test edin</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Düzenli ifadeyi test edin</a></p>

<h3 id="toc_28">5.3 Çok Satırlı</h3>

<p><code>m</code> işareti çok satırlı bir eşleşme bulmak için kullanılır. Daha önce<br/>
sabitleyicilerde gördüğümüz gibi <code>(^, $)</code> sembolleri aradığımız desenin harf<br/>
öbeğinin başında veya sonunda olup olmadığını kontrol etmemiz için kullanılır.<br/>
Bu sabitleyicilerin tüm satırlarda çalışması için <code>m</code> işaretini kullanırız.</p>

<p>Örneğin, <code>/at(.)?$/gm</code> ifadesinin anlamı: küçük <code>a</code> harfi, ardından küçük <code>t</code><br/>
harfi gelir, ardından opsiyonel olarak yeni satır hariç herhangi birşey<br/>
gelebilir. <code>m</code> işaretini kullandığımız için bir girişin her satırının sonunda<br/>
eşleştirir.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Düzenli ifadeyi test edin</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Düzenli ifadeyi test edin</a></p>

<h2 id="toc_29">Contribution</h2>

<ul>
<li>Report issues</li>
<li>Open pull request with improvements</li>
<li>Spread the word</li>
<li>Reach out to me directly at <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> or <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">License</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629422.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/twitter/follow/ziishaned.svg?style=social&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://github.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/github/followers/ziishaned.svg?label=Follow%20%40ziishaned&amp;style=social&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Translations:</h2>

<ul>
<li><a href="media/15998025629422/README.md">English</a></li>
<li><a href="media/15998025629422/README-es.md">Español</a></li>
<li><a href="media/15998025629422/README-fr.md">Français</a></li>
<li><a href="media/15998025629422/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629422/README-cn.md">中文版</a></li>
<li><a href="media/15998025629422/README-ja.md">日本語</a></li>
<li><a href="media/15998025629422/README-ko.md">한국어</a></li>
<li><a href="media/15998025629422/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629422/README-gr.md">Greek</a></li>
<li><a href="media/15998025629422/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629422/README-pl.md">Polish</a></li>
<li><a href="media/15998025629422/README-ru.md">Русский</a></li>
<li><a href="media/15998025629422/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629422/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Что такое Регулярное выражение?</h2>

<blockquote>
<p>Регулярное выражение - это группа букв или символов, которая используется для поиска определенного шаблона в тексте.</p>
</blockquote>

<p>Регулярное выражение - это шаблон, сопоставляемый с искомой строкой слева направо.<br/>
Термин «Регулярное выражение» сложно произносить каждый раз, поэтому, обычно, вы будете сталкиваться с сокращениями &quot;регэкспы&quot; или &quot;регулярки&quot;.<br/>
Регулярные выражения используются для замен текста внутри строк, валидации форм,<br/>
извлечений подстрок по определенным шаблонам и множества других вещей.</p>

<p>Представьте, что вы пишете приложение и хотите установить правила, по которым пользователь выбирает свой юзернейм. Мы хотим, чтобы имя пользователя содержало буквы, цифры, подчеркивания и дефисы. Мы также хотим ограничить количество символов в имени пользователя, чтобы оно не выглядело безобразно.<br/>
Для этого, используем следующее регулярное выражение:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-ru.png" alt="Regular expression"><br/>
</p></p>

<p>Регулярное выражения выше может принимать строки <code>john_doe</code>,<code>jo-hn_doe</code> и <code>john12_as</code>.<br/>
Оно не валидирует <code>Jo</code>, поскольку эта строка содержит заглавные буквы, а также она слишком короткая.</p>

<h2 id="toc_2">Содержание</h2>

<ul>
<li><a href="#1-%D1%81%D0%BE%D0%B2%D0%BF%D0%B0%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Совпадения</a></li>
<li><a href="#2-%D0%BC%D0%B5%D1%82%D0%B0%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B">Метасимволы</a>
<ul>
<li><a href="#21-%D1%82%D0%BE%D1%87%D0%BA%D0%B0">Точка</a></li>
<li><a href="#22-%D0%BD%D0%B0%D0%B1%D0%BE%D1%80-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2">Набор символов</a></li>
<li><a href="#221-%D0%BE%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%D0%B0-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2">Отрицание набора символов</a></li>
<li><a href="#23-%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%B5%D0%BD%D0%B8%D1%8F">Повторения</a></li>
<li><a href="#231-%D0%B7%D0%B2%D1%91%D0%B7%D0%B4%D0%BE%D1%87%D0%BA%D0%B0">Звёздочка</a></li>
<li><a href="#232-%D0%BF%D0%BB%D1%8E%D1%81">Плюс</a></li>
<li><a href="#233-%D0%B7%D0%BD%D0%B0%D0%BA-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%B0">Знак вопроса</a></li>
<li><a href="#24-%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%BD%D1%8B%D0%B5-%D1%81%D0%BA%D0%BE%D0%B1%D0%BA%D0%B8">Фигурные скобки</a></li>
<li><a href="#25-%D1%81%D0%BA%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B">Скобочные группы</a></li>
<li><a href="#26-%D0%B0%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%86%D0%B8%D1%8F">Альтернация</a></li>
<li><a href="#27-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Экранирование</a></li>
<li><a href="#28-%D1%8F%D0%BA%D0%BE%D1%80%D1%8F">Якоря</a></li>
<li><a href="#281-%D0%BA%D0%B0%D1%80%D0%B5%D1%82%D0%BA%D0%B0">Каретка</a></li>
<li><a href="#282-%D0%B4%D0%BE%D0%BB%D0%BB%D0%B0%D1%80">Доллар</a></li>
</ul></li>
<li><a href="#3-%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%D1%8B-%D1%81%D0%BE%D0%BA%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8-%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B">Наборы сокращений и диапазоны</a></li>
<li><a href="#4-%D0%BE%D0%BF%D0%B5%D1%80%D0%B5%D0%B6%D0%B0%D1%8E%D1%89%D0%B8%D0%B5-%D0%B8-%D1%80%D0%B5%D1%82%D1%80%D0%BE%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8">Опережающие и ретроспективные проверки</a>
<ul>
<li><a href="#41-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B5%D0%B6%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">Положительное опережающее условие</a></li>
<li><a href="#42-%D0%BE%D1%82%D1%80%D0%B8%D1%86%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B5%D0%B6%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">Отрицательное опережающее условие</a></li>
<li><a href="#43-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D1%80%D0%B5%D1%82%D1%80%D0%BE%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">Положительное ретроспективное условие</a></li>
<li><a href="#44-%D0%BE%D1%82%D1%80%D0%B8%D1%86%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D1%80%D0%B5%D1%82%D1%80%D0%BE%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">Отрицательное ретроспективное условие</a></li>
</ul></li>
<li><a href="#5-%D1%84%D0%BB%D0%B0%D0%B3%D0%B8">Флаги</a>
<ul>
<li><a href="#51-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%B1%D0%B5%D0%B7-%D1%83%D1%87%D0%B5%D1%82%D0%B0-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0">Поиск без учета регистра</a></li>
<li><a href="#52-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA">Глобальный поиск</a></li>
<li><a href="#53-%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA">Мультистроковый поиск</a></li>
</ul></li>
<li><a href="#6-%D0%B6%D0%B0%D0%B4%D0%BD%D1%8B%D0%B5-vs-%D0%BB%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D0%B5-%D0%BA%D0%B2%D0%B0%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B">Жадные vs ленивые квантификаторы</a></li>
</ul>

<h2 id="toc_3">1. Совпадения.</h2>

<p>В сущности, регулярное выражение - это просто набор символов, который мы используем для поиска в тексте.<br/>
Например, регулярное выражение <code>the</code> состоит из буквы <code>t</code>, за которой следует буква <code>h</code>, за которой следует буква <code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Запустить регулярное выражение</a></p>

<p>Регулярное выражение <code>123</code> соответствует строке <code>123</code>. Регулярное выражение сопоставляется с входной строкой, сравнивая<br/>
каждый символ в регулярном выражении с каждым символом во входной строке по одному символу за другим. Регулярные выражения<br/>
обычно чувствительны к регистру, поэтому регулярное выражение <code>The</code> не будет соответствовать строке <code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Запустить регулярное выражение</a></p>

<h2 id="toc_4">2. Метасимволы</h2>

<p>Метасимволы это блоки, из которых строятся регулярные выражения. Метасимволы не означают что-то сами по себе,<br/>
вместо этого они интерпретируются для распознавания специальных групп символов. Некоторые метасимволы имеют<br/>
особые обозначения и пишутся в квадратных скобках. Существуют следующие метасимволы:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Метасимволы</th>
<th>Описание</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Точка соответствует любому отдельному символу, кроме разрыва строки.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Класс символов. Находить любые символы заключенные в квадратных скобках.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Отрицание класа символов. Находить любые символы не заключенные в квадратных скобках.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>Находить 0 или более повторений предыдущего символа.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>Находить 1 или более повторений предыдущего символа.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>Сделать предыдущий символ необязательным.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Скобки. Находить по крайней мере &quot;n&quot; но не более чем &quot;m&quot; повторений предыдущего символа.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Группа символов. Находить только символы xyz в указанном порядке.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Чередование. Находить либо буквы до, либо буквы после символа.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Экранирование. Позволяет находить зарезервированные символы: <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Обозначает начало пользовательского ввода.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Обозначает конец пользовательского ввода.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Точка</h2>

<p>Точка <code>.</code> это простейший пример метасимвола. Метасимвол <code>.</code><br/>
находит любой отдельный символ. Точка не будет находить символы перехода или перевода строки.<br/>
Например, регулярное выражение <code>.ar</code> обозначает: любой символ, за которым следуют буквы <code>a</code> и <code>r</code>.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Запустить регулярное выражение</a></p>

<h2 id="toc_6">2.2 Набор символов.</h2>

<p>Набор символов также называется классом символов. Квадратные скобки используются<br/>
для определения набора символов. Дефис используется для указания диапазона символов.<br/>
Порядок следования символов, заданный в квадратных скобках, не важен. Например,<br/>
регулярное выражение <code>[Tt]he</code> обозначает заглавную <code>T</code> или строчную <code>t</code>, за которой следуют буквы <code>h</code> и <code>e</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Запустить регулярное выражение</a></p>

<p>Точка внутри набора символов, однако, обозначает непосредственно точку, как символ.<br/>
Регулярное выражение <code>ar[.]</code> обозначает строчную <code>a</code>, за которой следует <code>r</code>, за которой следует <code>.</code> (символ точки).</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Запустить регулярное выражение</a></p>

<h3 id="toc_7">2.2.1 Отрицание набора символов</h3>

<p>Знак вставки <code>^</code> обозначает начало строки, однако, когда вы вписываете его после открытия квадратных скобок, он отрицает набор символов.<br/>
Например, регулярное выражение <code>[^c]ar</code> обозначает любой символ, кроме <code>c</code>, за которым следуют буквы <code>a</code> и <code>r</code>.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Запустить регулярное выражение</a></p>

<h2 id="toc_8">2.3 Повторения</h2>

<p>Символы <code>+</code>, <code>*</code> или <code>?</code> используются для обозначения того, как сколько раз появляется какой-либо подшаблон.<br/>
Данные метасимволы могут вести себя по-разному, в зависимости от ситуации.</p>

<h3 id="toc_9">2.3.1 Звёздочка</h3>

<p>Символ <code>*</code> обозначает ноль или более повторений предыдущего совпадения.<br/>
Регулярное выражение <code>a*</code> означает ноль или более повторений предыдущего<br/>
строчного символа <code>a</code>. Если же символ появляется после набора или класса символов,<br/>
он находит повторения всего набора символов. Например, регулярное выражение <code>[a-z]*</code><br/>
означает любое количество строчных букв в строке.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Запустить регулярное выражение</a></p>

<p>Символы можно комбинировать, так, например, символ <code>*</code> может использоваться с метасимволом <code>.</code><br/>
для поиска одной строки с произвольным содержанием <code>.*</code>. Символ <code>*</code> может использоваться<br/>
с символом пробела <code>\s</code>, чтобы находить строки с символами пробела. Например, выражение<br/>
<code>\s*cat\s*</code> означает: ноль или более пробелов, за которыми следует слово <code>cat</code>,<br/>
за которым следует ноль или более символов пробела.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Запустить регулярное выражение</a></p>

<h3 id="toc_10">2.3.2 Плюс</h3>

<p>Символ <code>+</code> соответствует одному или более повторению предыдущего символа. Например,<br/>
регулярное выражение <code>c.+t</code> означает строчную <code>c</code>, за которой следует по крайней мере один символ,<br/>
следом за которым идёт символ <code>t</code>. Стоит уточнить, что в данном шаблоне, <code>t</code> является последним <code>t</code> в предложении.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Запустить регулярное выражение</a></p>

<h3 id="toc_11">2.3.3 Знак вопроса</h3>

<p>В регулярном выражении метасимвол <code>?</code> делает предыдущий символ необязательным.<br/>
Этот символ соответствует нулю или одному экземпляру предыдущего символа.<br/>
Например, регулярное выражение <code>[T]?he</code> означает необязательную заглавную букву <code>T</code>, за которой следуют символы <code>h</code> и <code>e</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Запустить регулярное выражение</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Запустить регулярное выражение</a></p>

<h2 id="toc_12">2.4 Фигурные скобки</h2>

<p>В фигурных скобках, которые также называются квантификаторами, указывается,<br/>
сколько раз символ или группа символов могут повторяться. Например, регулярное выражение<br/>
<code>[0-9]{2,3}</code> означает совпадение не менее 2 но не более 3 цифр в диапазоне от 0 до 9.</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Запустить регулярное выражение</a></p>

<p>Уберём второй номер (цифру 3), тогда, регулярное выражение <code>[0-9]{2,}</code> будет означать<br/>
совпадение 2 или более цифр. Если мы также удалим запятую, то регулярное выражение<br/>
<code>[0-9]{3}</code> будет означать совпадение точно с 3 цифрами.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Запустить регулярное выражение</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Запустить регулярное выражение</a></p>

<h2 id="toc_13">2.5 Скобочные группы</h2>

<p>Скобочные группы это группы подшаблонов, которые написаны в круглых скобках<br/>
<code>(...)</code>. Как мы уже говорили ранее в регулярном выражении, если мы поставим квантификатор<br/>
после символа, он будет повторять предыдущий символ. Но если мы поставим квантификатор после<br/>
скобочной группы, он будет искать всю группу. Например, регулярное выражение <code>(ab)*</code> соответствует<br/>
нулю или более повторений символа &quot;ab&quot;. Мы также можем использовать метасимвол чередования <code>|</code><br/>
внутри скобочной группы. Например, регулярное выражение <code>(c|g|p)ar</code> означает поиск одной из строчных букв <code>c</code>,<br/>
<code>g</code> или <code>p</code>, за которыми следуют буквы <code>a</code> и <code>r</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Запустить регулярное выражение</a></p>

<p>Обратите внимание, что скобочные группы не только находят, но и захватывают символы для использования на родительском языке.<br/>
Родительским языком может быть python, javascript или практически любой язык, который реализует использование регулярных выражений как параметров функций.</p>

<h3 id="toc_14">2.5.1 Не запоминающие скобочные группы</h3>

<p>Бывает так, что группу определить нужно, а вот запоминать их содержимое в массиве не требуется.<br/>
Подобный трюк осуществляется при помощи зарезервированной комбинации <code>?:</code><br/>
в круглых скобках <code>(...)</code>. Например, регулярное выражение <code>(?:c|g|p)ar</code> будет находить такие же шаблоны как и<br/>
<code>(c|g|p)ar</code>, однако скобочная группа при этом создана не будет.</p>

<pre>
"(?:c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/Rm7Me8/1">Запустить регулярное выражение</a></p>

<p>Не запоминающиеся группы пригодиться, когда они используются в функциях поиска и замены<br/>
или в сочетании со скобочными группами, например, для предпросмотра при создании скобочной группы или другого вида выходных данных,<br/>
смотрите также <a href="#4-%D0%BE%D0%BF%D0%B5%D1%80%D0%B5%D0%B6%D0%B0%D1%8E%D1%89%D0%B8%D0%B5-%D0%B8-%D1%80%D0%B5%D1%82%D1%80%D0%BE%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8">4. Опережающие и ретроспективные проверки</a>.</p>

<h2 id="toc_15">2.6 Альтернация</h2>

<p>В регулярных выражениях, вертикальная черта <code>|</code> используется для определения альтернации (чередования).<br/>
Альтернация по своей сути похожа на оператор ИЛИ между логическими выражениями. Может создаться впечатление, что<br/>
чередование это то же самое, что и определение набора символов. Однако, большая разница между ними в том, что<br/>
набор символов работает на уровне конкретных символов, в то время как альтернация работает на уровне выражений.<br/>
Например, регулярное выражение <code>(T|t)he|car</code> объединяет два шаблона (заглавная <code>T</code> ИЛИ строчная <code>t</code>, с продолжением из <code>h</code> и <code>e</code>) и шаблон<br/>
(строчная <code>c</code>, затем строчная <code>a</code>, за которой следует строчная <code>r</code>). Таким образом, в поиске будет участвовать любой из данных шаблонов,<br/>
по аналогии с логической операцией ИЛИ в программировании и алгебре выражений.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Запустить регулярное выражение</a></p>

<h2 id="toc_16">2.7 Экранирование спецсимволов</h2>

<p>Обратный слэш <code>\</code> используется в регулярных выражениях для экранирования следующего символа.<br/>
Это позволяет формировать шаблоны с поиском зарезервированных символов, таких как <code>{ } [ ] / \ + * . $ ^ | ?</code>.<br/>
Для использования спецсимвола в шаблоне необходимо указать символ <code>\</code> перед ним.</p>

<p>Как упомянуто выше, символ <code>.</code> является зарезервированным и соответствует любому значению, кроме символа новой строки.<br/>
Бывают ситуации, когда необходимо найти точку в предложении, для таких случаев применимо экранирование. Рассмотрим выражение<br/>
<code>(f|c|m)at\.?</code>, что соответствует следующему шаблону: строчный символ <code>f</code>, <code>c</code> или <code>m</code>, за которым следует строчные буквы <code>a</code> и <code>t</code>, с опциональной <code>.</code> точкой в конце.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Запустить регулярное выражение</a></p>

<h2 id="toc_17">2.8 Якоря</h2>

<p>Понятие якорей в регулярных выражениях используется для обозначения проверок, является ли<br/>
соответствующий символ начальным или конечным символом входной строки. Якоря бывают двух типов:<br/>
Первый тип - Каретка <code>^</code>, проверяет, является ли соответствующий символ начальным символом в тексте.<br/>
Второй тип - Доллар <code>$</code>, проверяет, является ли соответствующий символ последним символом входной строки.</p>

<h3 id="toc_18">2.8.1 Каретка</h3>

<p>Символ каретки <code>^</code> используется для проверки, является ли соответствующий символ первым символом входной строки.<br/>
Если мы применяем следующее регулярное выражение <code>^a</code> (если a является начальным символом) для строки <code>abc</code>,<br/>
совпадение будет соответствовать букве <code>a</code>. Если же мы используем регулярное выражение <code>^b</code> на той же строке,<br/>
мы не получим совпадения, поскольку во входящей строке <code>abc</code> &quot;b&quot; не является первым символом. Рассмотрим другое<br/>
регулярное выражение: <code>^(T|t)he</code>, обозначающее заглавную <code>T</code> или строчную <code>t</code> как первый символ, за которым следуют<br/>
символы букв <code>h</code> и <code>e</code>. Cоответственно:</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Запустить регулярное выражение</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Запустить регулярное выражение</a></p>

<h3 id="toc_19">2.8.2 Доллар</h3>

<p>Символ доллара <code>$</code> используется для проверки, является ли соответствующий символ<br/>
последним символом входной строки. Например, регулярное выражение <code>(at\.)$</code> последовательность из<br/>
строчной <code>a</code>, строчной <code>t</code>, и точки <code>.</code>, ключевой момент в том, что благодаря доллару этот шаблон будет<br/>
находить совпадения только в том случае, если будет наблюдаться в конце строки. Например:</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Запустить регулярное выражение</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Запустить регулярное выражение</a></p>

<h2 id="toc_20">3. Наборы сокращений и диапазоны</h2>

<p>Регулярные выражения предоставляют сокращения для часто используемых наборов символов,<br/>
которые предлагают удобные сокращения для часто используемых регулярных выражений.<br/>
Наборы сокращенных символов следующие:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Сокращение</th>
<th>Описание</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Любой символ кроме символа новой строки</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Поиск буквенно-цифрового диапазона символов: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Поиск не буквенно-цифрового диапазона символов: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Поиск цифр: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Поиск всего, что не является цифрой: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Поиск пробелов и символов начала строки: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Поиск всего кроме пробелов и символов начала строки: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_21">4. Опережающие и ретроспективные проверки</h2>

<p>Опережающие и ретроспективные проверки (в английской литературе lookbehind, lookahead) это особый вид<br/>
<strong><em>не запоминающих скобочных групп</em></strong> (находящих совпадения, но не добавляющих в массив).<br/>
Данные проверки используются, мы знаем, что шаблон предшествует или сопровождается другим шаблоном.<br/>
Например, мы хотим получить получить цену в долларах <code>$</code>, из следующей входной строки<br/>
<code>$4.44 and $10.88</code>. Для этого используем следующее регулярное выражение <code>(?&lt;=\$)[0-9\.]*</code>, означающее<br/>
получение всех дробных (с точкой <code>.</code>) цифр, которым предшествует знак доллара <code>$</code>. Существуют<br/>
следующие виды проверок:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Символ</th>
<th>Описание</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Положительное опережающее условие</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Отрицательное опережающее условие</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Положительное ретроспективное условие</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Отрицательное ретроспективное условие</td>
</tr>
</tbody>
</table>

<h3 id="toc_22">4.1 Положительное опережающее условие</h3>

<p>Положительное опережающее утверждение (assert) означает, что за первой частью выражения должно следовать<br/>
опережающее выражение (lookahead expression). (по аналогии с условиями, if (..) then (..)).<br/>
Возвращенное совпадение содержит только текст, который соответствует первой части выражения.<br/>
Для определения положительного опережающего условия используются круглые скобки. В этих скобках используется<br/>
знак вопроса со знаком равенства: <code>(?=...)</code>. Опережающее выражение, записывается в скобках после знака равенства.<br/>
Рассмотрим пример регулярного выражения: <code>(T|t)he(?=\sfat)</code>, обозначающее опциональное наличие строчной <code>t</code> или заглавной <code>T</code>,<br/>
следом буквы <code>h</code> и <code>e</code>. В скобках, мы определяем положительное опережающее условие, которое сообщает движку регулярных выражений<br/>
информацию о том, что после шаблона <code>The</code> или <code>the</code> будет следовать слово <code>fat</code>.</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Запустить регулярное выражение</a></p>

<h3 id="toc_23">4.2 Отрицательное опережающее условие</h3>

<p>Отрицательное опережающее условие работает по обратному принципу: используется, когда нам нужно получить<br/>
все совпадения из входной строки, за которыми НЕ следует определенный шаблон. Отрицательное опережающее условие<br/>
определяется таким же образом, как и позитивное, с той лишь разницей, что вместо равенства <code>=</code> мы ставим<br/>
восклицательный знак <code>!</code> (отрицание) например: <code>(?!...)</code>. Рассмотрим выражение <code>(T|t)he(?!\sfat)</code>, в котором мы<br/>
находим все <code>The</code> или <code>the</code> слова из входной строки, за которыми не следует слово <code>fat</code>.</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Запустить регулярное выражение</a></p>

<h3 id="toc_24">4.3 Положительное ретроспективное условие</h3>

<p>Положительное ретроспективное условие используется чтобы найти все совпадения, которым предшествует<br/>
определенный шаблон. Условие определяется как <code>(?&lt;=...)</code>. Например, выражение <code>(?&lt;=(T|t)he\s)(fat|mat)</code> означает,<br/>
найти все слова <code>fat</code> или <code>mat</code> из входной строки, которым предшествует слово <code>The</code> или <code>the</code>.</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Запустить регулярное выражение</a></p>

<h3 id="toc_25">4.4 Отрицательное ретроспективное условие</h3>

<p>Отрицательное ретроспективное условие используется чтобы найти все совпадения, которым НЕ предшествует<br/>
определенный шаблон. Условие определяется как <code>(?&lt;!...)</code>. Например, выражение <code>(?&lt;!(T|t)he\s)(cat)</code> означает<br/>
найти все слова <code>cat</code> из входной строки, которым не предшествует определенный артикль <code>The</code> или <code>the</code>.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Запустить регулярное выражение</a></p>

<h2 id="toc_26">5. Флаги</h2>

<p>Флаги, также называемые модификаторами, изменяют вывод регулярного выражения.<br/>
Эти флаги могут быть использованы в любом порядке или комбинации, и являются<br/>
неотъемлемой частью регулярных выражений.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Флаг</th>
<th>Описание</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Поиск без учета регистра</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Глобальный поиск: поиск шаблона во всем входном тексте</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Мультистроковый поиск: Якоря применяются к каждой строке.</td>
</tr>
</tbody>
</table>

<h3 id="toc_27">5.1 Поиск без учета регистра</h3>

<p>Модификатор <code>i</code> используется для поиска без учета регистра. Например, регулярное выражение<br/>
<code>/The/gi</code> означает заглавную <code>T</code> следом строчные <code>h</code> и <code>e</code>. В конце регулярного выражения флаг <code>i</code>,<br/>
указывающий движку регулярных выражений игнорировать регистр. Помимо <code>i</code>, для поиска шаблона во<br/>
всем входном тексте, использован флаг <code>g</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Запустить регулярное выражение</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Запустить регулярное выражение</a></p>

<h3 id="toc_28">5.2 Глобальный поиск</h3>

<p>Модификатор <code>g</code> используется для выполнения глобального сопоставления (найти все совпадения, а не останавливаться после первого).<br/>
Например, регулярное выражение <code>/.(at)/g</code> означает любой символ кроме символа новой строки, следом строчная <code>a</code>, далее строчная <code>t</code>.<br/>
Из-за использования флага <code>g</code> в конце регулярного выражения, теперь оно найдет все совпадения во входной строке, а не остановится на первом<br/>
(что является поведением по умолчанию).</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Запустить регулярное выражение</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Запустить регулярное выражение</a></p>

<h3 id="toc_29">5.3 Мультистроковый поиск</h3>

<p>Модификатор <code>m</code> используется для многострочного поиска. Как мы обсуждали ранее,<br/>
якоря <code>(^, $)</code> используются для проверки, является ли шаблон началом или концом входной строки.<br/>
Но если мы хотим, чтобы якоря работали в каждой строке, мы используем флаг <code>m</code>. Например,<br/>
регулярное выражение <code>/at(.)?$/gm</code> означает строчную <code>a</code>, следом строчная <code>t</code> и любой<br/>
символ кроме начала новой строки, идущий опционально (не обязательно). Из-за флага <code>m</code> механизм<br/>
регулярных выражений будет искать данный шаблон в конце каждой строки в тексте.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Запустить регулярное выражение</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Запустить регулярное выражение</a></p>

<h2 id="toc_30">6. Жадные vs ленивые квантификаторы</h2>

<p>По умолчанию регулярное выражение выполняет жадное сопоставление, то есть оно будет<br/>
искать совпадения как можно дольше. Мы можем использовать <code>?</code> для ленивого поиска, который<br/>
будет стремиться быть как можно более коротким по времени.</p>

<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1">Запустить регулярное выражение</a></p>

<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/2">Запустить регулярное выражение</a></p>

<h2 id="toc_31">Содействие</h2>

<ul>
<li>Вы можете открыть пулл реквест с улучшением</li>
<li>Обсуждать идеи в issues</li>
<li>Распространять ссылку на репозиторий</li>
<li>Получить обратную связь через <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_32">Лицензия</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629523.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Traduções:</h2>

<ul>
<li><a href="media/15998025629523/README.md">English</a></li>
<li><a href="media/15998025629523/README-es.md">Español</a></li>
<li><a href="media/15998025629523/README-fr.md">Français</a></li>
<li><a href="media/15998025629523/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629523/README-cn.md">中文版</a></li>
<li><a href="media/15998025629523/README-ja.md">日本語</a></li>
<li><a href="media/15998025629523/README-ko.md">한국어</a></li>
<li><a href="media/15998025629523/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629523/README-gr.md">Greek</a></li>
<li><a href="media/15998025629523/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629523/README-pl.md">Polish</a></li>
<li><a href="media/15998025629523/README-ru.md">Русский</a></li>
<li><a href="media/15998025629523/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629523/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">O que é uma Expressão Regular?</h2>

<blockquote>
<p>Expressão Regular é um grupo de caracteres ou símbolos utilizado para encontrar um padrão específico a partir de um texto.</p>
</blockquote>

<p>Uma expressão regular é um padrão que é comparado com uma cadeia de caracteres da esquerda para a direita. A expressão &quot;Expressão regular&quot; é longa e difícil de falar; você geralmente vai encontrar o termo abreviado como &quot;regex&quot; ou &quot;regexp&quot;. Expressões regulares são usadas para substituir um texto dentro de uma string, validar formulários, extrair uma parte de uma string baseada em um padrão encontrado e muito mais.</p>

<p>Imagine que você está escrevendo uma aplicação e quer colocar regras para quando um usuário escolher seu username. Nós queremos permitir que o username contenha letras, números, underlines e hífens. Nós também queremos limitar o número de caracteres para não ficar muito feio. Então usamos a seguinte expressão regular para validar o username:</p>

<p><br/><br/></p>

<p align="center">
<img src="http://i.imgur.com/8UaOzpq.png" alt="Regular expression">
</p>

<p>A expressão regular acima aceita as strings <code>john_doe</code>, <code>jo-hn_doe</code> e <code>john12_as</code>. Ela não aceita <code>Jo</code> porque essa string contém letras maiúsculas e também é muito curta.</p>

<h2 id="toc_2">Sumário</h2>

<ul>
<li><a href="#1-combina%C3%A7%C3%B5es-b%C3%A1sicas">Combinações Básicas</a></li>
<li><a href="#2-metacaracteres">Metacaracteres</a>
<ul>
<li><a href="#21-ponto-final">Ponto final</a></li>
<li><a href="#22-conjunto-de-caracteres">Conjunto de caracteres</a></li>
<li><a href="#221-conjunto-de-caracteres-negados">Conjunto de caracteres negados</a></li>
<li><a href="#23-repeti%C3%A7%C3%B5es">Repetições</a></li>
<li><a href="#231-o-asterisco">O Asterisco</a></li>
<li><a href="#232-o-sinal-de-adi%C3%A7%C3%A3o">O Sinal de Adição</a></li>
<li><a href="#233-o-ponto-de-interroga%C3%A7%C3%A3o">O Ponto de Interrogação</a></li>
<li><a href="#24-chaves">Chaves</a></li>
<li><a href="#25-grupo-de-caracteres">Grupo de Caracteres</a></li>
<li><a href="#26-altern%C3%A2ncia">Alternância</a></li>
<li><a href="#27-escapando-caracteres-especiais">Escapando Caracteres Especiais</a></li>
<li><a href="#28-%C3%82ncoras">Âncoras</a></li>
<li><a href="#281-acento-circunflexo">Acento Circunflexo</a></li>
<li><a href="#282-sinal-de-d%C3%B3lar">Sinal de Dólar</a></li>
</ul></li>
<li><a href="#3-forma-abreviada-de-conjunto-de-caracteres">Forma Abreviada de Conjunto de Caracteres</a></li>
<li><a href="#4-olhar-ao-redor">Olhar ao Redor</a>
<ul>
<li><a href="#41-lookahead-positivo">Lookahead Positivo</a></li>
<li><a href="#42-lookahead-negativo">Lookahead Negativo</a></li>
<li><a href="#43-lookbehind-positivo">Lookbehind Positivo</a></li>
<li><a href="#44-lookbehind-negativo">Lookbehind Negativo</a></li>
</ul></li>
<li><a href="#5-flags">Flags</a>
<ul>
<li><a href="#51-indiferente-%C3%A0-mai%C3%BAsculas">Indiferente à Maiúsculas</a></li>
<li><a href="#52-busca-global">Busca Global</a></li>
<li><a href="#53-multilinhas">Multilinhas</a></li>
</ul></li>
</ul>

<h2 id="toc_3">1. Combinações Básicas</h2>

<p>Uma expressão regular é apenas um padrão de caracteres que usamos para fazer busca em um texto. Por exemplo, a expressão regular <code>the</code> significa: a letra <code>t</code>, seguida da letra <code>h</code>, seguida da letra <code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Teste a RegExp</a></p>

<p>A expressão regular <code>123</code> corresponde à string <code>123</code>. A expressão regular é comparada com uma string de entrada, comparando cada caractere da expressão regular para cada caractere da string de entrada, um após o outro. Expressões regulares são normalmente case-sensitive (sensíveis a maiúsculas), então a expressão regular <code>The</code> não vai bater com a string <code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Teste a RegExp</a></p>

<h2 id="toc_4">2. Metacaracteres</h2>

<p>Metacaracteres são elementos fundamentais das expressões regulares. Metacaracteres não representam a si mesmos mas, ao invés disso, são interpretados de uma forma especial. Alguns metacaracteres tem um significado especial e são escritos dentro de colchetes.<br/>
Os metacaracteres são os seguintes:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Metacaracter</th>
<th>Descrição</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Corresponde a qualquer caractere, exceto uma quebra de linha</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Classe de caracteres. Corresponde a qualquer caractere contido dentro dos colchetes.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Classe de caracteres negada. Corresponde a qualquer caractere que não está contido dentro dos colchetes.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>Corresponde a 0 ou mais repetições do símbolo anterior.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>Corresponde a 1 ou mais repetições do símbolo anterior.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>Faz com que o símbolo anterior seja opcional.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Chaves. Corresponde a no mínimo &quot;n&quot; mas não mais que &quot;m&quot; repetições do símbolo anterior.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Grupo de caracteres. Corresponde aos caracteres xyz nesta exata ordem.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Alternância. Corresponde aos caracteres antes ou os caracteres depois do símbolo</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Escapa o próximo caractere. Isso permite você utilizar os caracteres reservados <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Corresponde ao início da entrada.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Corresponde ao final da entrada.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Ponto final</h2>

<p>O ponto final <code>.</code> é um simples exemplo de metacaracteres. O metacaractere <code>.</code> corresponde a qualquer caractere sozinho. Ele não se iguala ao Enter e à quebra de linha. Por exemplo, a expressão regular <code>.ar</code> significa: qualquer caractere, seguido da letra <code>a</code>, seguida da letra <code>r</code>.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Teste a RegExp</a></p>

<h2 id="toc_6">2.2 Conjunto de caracteres</h2>

<p>Conjuntos de caracteres também são chamados de classes de caracteres. Utilizamos colchetes para especificar conjuntos de caracteres. Use um hífen dentro de um conjunto de caracteres para especificar o intervalo de caracteres. A ordem dos caracteres dentro dos colchetes não faz diferença. Por exemplo, a expressão regular <code>[Tt]he</code> significa: um caractere maiúsculo <code>T</code> ou minúsculo <code>t</code>, seguido da letra <code>h</code>, seguida da letra <code>e</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Teste a RegExp</a></p>

<p>No entanto, um ponto final dentro de um conjunto de caracteres, significa apenas um ponto final. A expressão regular <code>ar[.]</code> significa: o caractere minúsculo <code>a</code>, seguido da letra <code>r</code>, seguida pelo caractere de ponto final <code>.</code>.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Teste a RegExp</a></p>

<h3 id="toc_7">2.2.1 Conjunto de caracteres negados</h3>

<p>No geral, o símbolo do circunflexo representa o início da string, mas quando está logo após o colchete de abertura, ele faz a negação do conjunto de caracteres. Por exemplo, a expressão regular <code>[^c]ar</code> significa: qualquer caractere com exceção do <code>c</code>, seguido pelo caractere <code>a</code>, seguido da letra <code>r</code>.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Teste a RegExp</a></p>

<h2 id="toc_8">2.3 Repetições</h2>

<p>Seguindo os metacaracteres <code>+</code>, <code>*</code> ou <code>?</code> são utilizados para especificar quantas vezes um sub-padrão pode ocorrer. Esses metacaracteres atuam de formas diferentes em diferentes situações.</p>

<h3 id="toc_9">2.3.1 O Asterisco</h3>

<p>O símbolo <code>*</code> corresponde a zero ou mais repetições do padrão antecedente. A expressão regular <code>a*</code> significa: zero ou mais repetições do caractere minúsculo precedente <code>a</code>. Mas se o asterisco aparecer depois de um conjunto de caracteres, ou classe de caracteres, ele irá procurar as repetições de todo o conjunto. Por exemplo, a expressão regular <code>[a-z]*</code> significa: qualquer quantidade de letras minúsculas numa linha.</p>

<pre>
"[a-z]&ast;" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Teste a RegExp</a></p>

<p>O símbolo <code>*</code> pode ser usado junto do metacaractere <code>.</code> para encontrar qualquer string de caracteres <code>.*</code>. O símbolo <code>*</code> pode ser usado com o caractere de espaço em branco <code>\s</code> para encontrar uma string de caracteres em branco. Por exemplo, a expressão <code>\s*cat\s*</code> significa: zero ou mais espaços, seguidos do caractere minúsculo <code>c</code>, seguido do caractere minúsculo <code>a</code>, seguido do caractere minúsculo <code>t</code>, seguido de zero ou mais espaços.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Teste a RegExp</a></p>

<h3 id="toc_10">2.3.2 O Sinal de Adição</h3>

<p>O símbolo <code>+</code> corresponde a uma ou mais repetições do caractere anterior. Por exemplo, a expressão regular <code>c.+t</code> significa: a letra minúscula <code>c</code>, seguida por pelo menos um caractere, seguido do caractere minúsculo <code>t</code>.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Teste a RegExp</a></p>

<h3 id="toc_11">2.3.3 O Ponto de Interrogação</h3>

<p>Em expressões regulares, o metacaractere <code>?</code> faz o caractere anterior ser opcional. Esse símbolo corresponde a zero ou uma ocorrência do caractere anterior. Por exemplo, a expressão regular <code>[T]?he</code> significa: A letra maiúsculo <code>T</code> opcional, seguida do caractere minúsculo <code>h</code>, seguido do caractere minúsculo <code>e</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Teste a RegExp</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Teste a RegExp</a></p>

<h2 id="toc_12">2.4 Chaves</h2>

<p>Em expressões regulares, chaves, que também são chamadas de quantificadores, são utilizadas para especificar o número de vezes que o caractere, ou um grupo de caracteres, pode se repetir. Por exemplo, a expressão regular <code>[0-9]{2,3}</code> significa: Encontre no mínimo 2 dígitos, mas não mais que 3 (caracteres no intervalo de 0 a 9).</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Teste a RegExp</a></p>

<p>Nós podemos retirar o segundo número. Por exemplo, a expressão regular <code>[0-9]{2,}</code> significa: Encontre 2 ou mais dígitos. Se removermos a vírgula a expressão regular <code>[0-9]{3}</code> significa: Encontre exatamente 3 dígitos.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Teste a RegExp</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Teste a RegExp</a></p>

<h2 id="toc_13">2.5 Grupo de Caracteres</h2>

<p>Grupo de caracteres é um grupo de sub-padrão que é escrito dentro de parênteses <code>(...)</code>. Como falamos antes, se colocaramos um quantificador depois de um caractere, ele irá repetir o caractere anterior. Mas se colocarmos um quantificador depois de um grupo de caracteres, ele irá repetir todo o conjunto. Por exemplo, a expressão regular <code>(ab)*</code> corresponde a zero ou mais repetições dos caracteres &quot;ab&quot;. Nós também podemos usar o metacaractere de alternância <code>|</code> dentro de um grupo de caracteres. Por exemplo, a expressão regular <code>(c|g|p)ar</code> significa: caractere minúsculo <code>c</code>, <code>g</code> ou <code>p</code>, seguido do caractere <code>a</code>, seguido do caractere <code>r</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Teste a RegExp</a></p>

<h2 id="toc_14">2.6 Alternância</h2>

<p>Em expressões regulares, a barra vertical <code>|</code> é usada para definir alternância. Alternância é como uma condição entre múltiplas expressões. Agora, você pode estar pensando que um conjunto de caracteres e a alternância funcionam da mesma forma. Mas a grande diferença entre eles é que o conjunto de caracteres trabalha no nível de caracteres, enquanto a alternância trabalha no nível das expressões. Por exemplo, a expressão regular <code>(T|t)he|car</code> significa: o caractere maiúsculo <code>T</code> ou minúsculo <code>t</code>, seguido do caractere minúsculo <code>h</code>, seguido do caractere minúsculo <code>e</code> ou o caractere minúsculo <code>c</code>, seguido do caractere minúsculo <code>a</code>, seguido do caractere minúsculo <code>r</code>.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Teste a RegExp</a></p>

<h2 id="toc_15">2.7 Escapando Caracteres Especiais</h2>

<p>Em expressões regulares, a contrabarra <code>\</code> é usada para escapar o próximo caractere. Isso possibilita especificar um símbolo como um caractere correspondente, incluindo os caracteres reservados <code>{ } [ ] / \ + * . $ ^ | ?</code>. Para usar um caractere especial como um caractere correspondente, utilize <code>\</code> antes dele. Por exemplo, a expressão regular <code>.</code> é usada para encontrar qualquer caractere, exceto nova linha. Agora, para encontrar <code>.</code> em uma string de entrada, a expressão regular <code>(f|c|m)at\.?</code> significa: letra minúscula <code>f</code>, <code>c</code> ou <code>m</code>, seguida do caractere minúsculo <code>a</code>, seguido da letra minúscula <code>t</code>, seguida do caractere <code>.</code> opcional.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Teste a RegExp</a></p>

<h2 id="toc_16">2.8 Âncoras</h2>

<p>Em empressões regulares, usamos âncoras para verificar se o caractere encontrado está no início ou no final da string de entrada. As âncoras podem ser de dois tipos: O primeiro tipo é o Acento Circunflexo <code>^</code>, que verifica se o caractere encontrado está no início da string de entrada, e o segundo tipo é o Sinal de Dólar <code>$</code>, que verifica se o caractere encontrado é o último caractere da string.</p>

<h3 id="toc_17">2.8.1 Acento Circunflexo</h3>

<p>O símbolo do Acento Circunflexo <code>^</code> é usado para verificar se o caractere encontrado é o primeiro caractere da string de entrada. Se aplicarmos a seguinte expressão regular <code>^a</code> (se a é o primeiro caractere) à string de entrada <code>abc</code>, ela encontra o <code>a</code>. Mas se nós aplicarmos a expressão regular <code>^b</code> na mesma string, ela não encontrará nada. Isso acontece porque, na string <code>abc</code>, &quot;b&quot; não é o caractere inicial. Vamos dar uma olhada em outra expressão regular, <code>^(T|t)he</code> que significa: o caractere maiúsculo <code>T</code> ou o caractere minúsculo <code>t</code> que é o primeiro símbolo da string de entrada, seguido do caractere minúsculo <code>h</code>, seguido do caractere minúsculo <code>e</code>.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Teste a RegExp</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Teste a RegExp</a></p>

<h3 id="toc_18">2.8.2 Sinal de Dólar</h3>

<p>O símbolo do Sinal de Dólar <code>$</code> é usado para verificar se o caractere encontrado é o último caractere da string de entrada. Por exemplo, a expressão regular <code>(at\.)$</code> significa: um caractere minúsculo <code>a</code>, seguido do caractere minúsculo <code>t</code>, seguido de um ponto final <code>.</code> e o grupo deve estar no final da string.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Teste a RegExp</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Teste a RegExp</a></p>

<h2 id="toc_19">3. Forma Abreviada de Conjunto de Caracteres</h2>

<p>As expressões regulares fornecem abreviações para conjuntos de caracteres comumente usados, que oferecem atalhos convenientes para expressões regulares comumente usadas. As abreviações são as seguintes:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Abreviação</th>
<th>Descrição</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Qualquer caractere, exceto nova linha</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Corresponde a caracteres alfanuméricos: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Corresponde a caracteres não alfanuméricos: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Corresponde a dígitos: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Corresponde a não dígitos: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Corresponde a caracteres de espaços em branco: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Corresponde a caracteres de espaços não em branco: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. Olhar ao Redor</h2>

<p>Lookbehind (olhar atrás) e lookahead (olhar à frente), às vezes conhecidos como lookarounds (olhar ao redor), são tipos específicos de <strong><em>grupo de não captura</em></strong> (utilizado para encontrar um padrão, mas não incluí-lo na lista de ocorrêncoas). Lookarounds são usados quando temos a condição de que determinado padrão seja precedido ou seguido de outro padrão. Por exemplo, queremos capturar todos os números precedidos do caractere <code>$</code> da seguinte string de entrada: <code>$4.44 and $10.88</code>. Vamos usar a seguinte expressão regular <code>(?&lt;=\$)[0-9\.]*</code> que significa: procure todos os números que contêm o caractere <code>.</code> e são precedidos pelo caractere <code>$</code>. A seguir estão os lookarounds que são utilizados em expressões regulares:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Símbolo</th>
<th>Descrição</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Lookahead Positivo</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Lookahead Negativo</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Lookbehind Positivo</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Lookbehind Negativo</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 Lookahead Positivo</h3>

<p>O lookahead positivo impõe que a primeira parte da expressão deve ser seguida pela expressão lookahead. A combinação retornada contém apenas o texto que encontrado pela primeira parte da expressão. Para definir um lookahead positivo, deve-se usar parênteses. Dentro desses parênteses, é usado um ponto de interrogação seguido de um sinal de igual, dessa forma: <code>(?=...)</code>. Expressões lookahead são escritas depois do sinal de igual dentro do parênteses. Por exemplo, a expressão regular <code>[T|t]he(?=\sfat)</code> significa: encontre a letra minúscula <code>t</code> ou a letra maiúscula <code>T</code>, seguida da letra <code>h</code>, seguida da letra <code>e</code>. Entre parênteses, nós definimos o lookahead positivo que diz para o motor de expressões regulares para encontrar <code>The</code> ou <code>the</code> que são seguidos pela palavra <code>fat</code>.</p>

<pre>
"[T|t]he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Teste a RegExp</a></p>

<h3 id="toc_22">4.2 Lookahead Negativo</h3>

<p>O lookahead negativo é usado quando nós precisamos encontrar todas as ocorrências da string de entrada que não são seguidas por um determinado padrão. O lookahead negativo é definido da mesma forma que definimos o lookahead positivo, mas a única diferença é que, no lugar do sinal de igual <code>=</code>, usamos o caractere de negação <code>!</code>, ex.: <code>(?!...)</code>. Vamos dar uma olhada na seguinte expressão regular <code>[T|t]he(?!\sfat)</code>, que significa: obtenha as palavras <code>The</code> ou <code>the</code> da string de entrada que não são seguidas pela palavra <code>fat</code>, precedida de um caractere de espaço.</p>

<pre>
"[T|t]he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Teste a RegExp</a></p>

<h3 id="toc_23">4.3 Lookbehind Positivo</h3>

<p>Lookbehind positivo é usado para encontrar todas as ocorrências que são precedidas por um padrão específico. O lookbehind positivo é indicado por <code>(?&lt;=...)</code>. Por exemplo, a expressão regular <code>(?&lt;=[T|t]he\s)(fat|mat)</code> significa: obtenha todas as palavras <code>fat</code> ou <code>mat</code> da string de entrada, que estão depois das palavras <code>The</code> ou <code>the</code>.</p>

<pre>
"(?<=[T|t]he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Teste a RegExp</a></p>

<h3 id="toc_24">4.4 Lookbehind Negativo</h3>

<p>Lookbehind negativo é usado para encontrar todas as ocorrências que não são precedidas por um padrão específico. O lookbehind negativo é indicado por <code>(?&lt;!...)</code>. Por exemplo, a expressão regular <code>(?&lt;!(T|t)he\s)(cat)</code> significa: obtenha todas as palavras <code>cat</code> da string de entrada, que não estão depois das palavras <code>The</code> ou <code>the</code>.</p>

<pre>
"(?&lt;![T|t]he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Teste a RegExp</a></p>

<h2 id="toc_25">5. Flags</h2>

<p>Flags (sinalizadores) também são chamados de modificadores, porque eles modificam o resultado da expressão regular. Essas flags podem ser usadas em qualquer ordem ou combinação, e são uma parte integrante da RegExp.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Flag</th>
<th>Descrição</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Case insensitive: Define que o padrão será case-insensitive.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Busca global: Procura o padrão em toda a string de entrada.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Multilinhas: Os metacaracteres de âncora funcionam em cada linha.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 Indiferente a Maiúsculas</h3>

<p>O modificador <code>i</code> é usado para tornar o padrão case-insensitive. Por exemplo, a expressão regular <code>/The/gi</code> significa: a letra maiúscula <code>T</code>, seguida do caractere minúsculo <code>h</code>, seguido do caractere <code>e</code>. E ao final da expressão regular, a flag <code>i</code> diz ao motor de expressões regulares para ignorar maiúsculas e minúsculas. Como você pode ver, nós também determinamos a flag <code>g</code> porque queremos procurar o padrão em toda a string de entrada.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Teste a RegExp</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Teste a RegExp</a></p>

<h3 id="toc_27">5.2 Busca Global</h3>

<p>O modificador <code>g</code> é usado para realizar uma busca global (encontrar todas as ocorrências sem parar na primeira encontrada). Por exemplo, a expressão regular <code>/.(at)/g</code> significa: qualquer caractere, exceto nova linha, seguido do caractere minúsculo <code>a</code>, seguido do caractere minúsculo <code>t</code>. Por causa da flag <code>g</code> no final da expressão regular, agora ela vai encontrar todas as ocorrências em toda a string de entrada.</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Teste a RegExp</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Teste a RegExp</a></p>

<h3 id="toc_28">5.3 Multilinhas</h3>

<p>O modificador <code>m</code> é usado para realizar uma busca em várias linhas. Como falamos antes, as âncoras <code>(^, $)</code> são usadas para verificar se o padrão está no início ou no final da string de entrada. Mas se queremos que as âncoras funcionem em cada uma das linhas, usamos a flag <code>m</code>. Por exemplo, a expressão regular <code>/at(.)?$/gm</code> significa: o caractere minúsculo <code>a</code>, seguido do caractere minúsculo <code>t</code>, opcionalmente seguido por qualquer caractere, exceto nova linha. E por causa da flag <code>m</code>, agora o motor de expressões regulares encontra o padrão no final de cada uma das linhas da string.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Teste a RegExp</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Teste a RegExp</a></p>

<h2 id="toc_29">Contribution</h2>

<ul>
<li>Reporte bugs</li>
<li>Abra pull request com melhorias</li>
<li>Espalhe a palavra</li>
<li>Me encontre diretamente em <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> ou <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">Licença</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629610.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Tłumaczenia:</h2>

<ul>
<li><a href="media/15998025629610/README.md">English</a></li>
<li><a href="media/15998025629610/README-es.md">Español</a></li>
<li><a href="media/15998025629610/README-fr.md">Français</a></li>
<li><a href="media/15998025629610/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629610/README-cn.md">中文版</a></li>
<li><a href="media/15998025629610/README-ja.md">日本語</a></li>
<li><a href="media/15998025629610/README-ko.md">한국어</a></li>
<li><a href="media/15998025629610/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629610/README-gr.md">Greek</a></li>
<li><a href="media/15998025629610/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629610/README-pl.md">Polish</a></li>
<li><a href="media/15998025629610/README-ru.md">Русский</a></li>
<li><a href="media/15998025629610/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629610/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Co to jest wyrażenie regularne?</h2>

<blockquote>
<p>Wyrażenie regularne to grupa znaków lub symboli, które służą do odnalezienia określonego wzoru w tekście.</p>
</blockquote>

<p>Wyrażenie regularne to wzorzec, który jest dopasowywany do tekstu od lewej<br/>
do prawej strony. Termin &quot;wyrażenie regularne&quot; (ang. &quot;regular expression&quot;)<br/>
jest dość długie, więc zazwyczaj używa się skróconej formy &quot;regex&quot; lub &quot;regexp&quot;.<br/>
Wyrażenie regularne jest używane do zastępowania tekstu w łańcuchu znaków<br/>
(ang. string), walidacji formularzy, wyodrębniania wycinka z łańcucha<br/>
(ang. substring) według podanego wzorca, i wielu innych.</p>

<p>Wyobraź sobie, że piszesz aplikację i chcesz ustawić reguły dotyczące tego,<br/>
jak użytkownik wybiera swoją nazwę. Chcemy, aby nazwa użytkownika zawierała litery,<br/>
liczby, podkreślenia i myślniki. Chcemy również ograniczyć liczbę znaków w nazwie<br/>
użytkownika, aby nie wyglądała za brzydko. Stosujemy następujące wyrażenie<br/>
regularne, aby sprawdzić poprawność nazwy:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-pl.png" alt="Wyrażenie regularne"><br/>
</p></p>

<p>Powyższe wyrażenie akceptuje łańcuchy <code>john_doe</code>, <code>jo-hn_doe</code><br/>
i <code>john12_as</code>. Odrzuca <code>Jo</code> ponieważ łańcuch zawiera dużą literę<br/>
i jest za krótki.</p>

<h2 id="toc_2">Spis treści</h2>

<ul>
<li><a href="#1-najprostsze-wyra%C5%BCenie">Najprostsze wyrażenie</a></li>
<li><a href="#2-metaznaki">Metaznaki</a>
<ul>
<li><a href="#21-kropka">Kropka</a></li>
<li><a href="#22-zestaw-znak%C3%B3w">Zestaw znaków</a></li>
<li><a href="#221-odwr%C3%B3cony-zestaw-znak%C3%B3w">Odwrócony zestaw znaków</a></li>
<li><a href="#23-powt%C3%B3rzenia">Powtórzenia</a></li>
<li><a href="#231-gwiazdka">Gwiazdka</a></li>
<li><a href="#232-plus">Plus</a></li>
<li><a href="#233-znak-zapytania">Znak zapytania</a></li>
<li><a href="#24-klamry">Klamry</a></li>
<li><a href="#25-grupa-znak%C3%B3w">Grupa znaków</a></li>
<li><a href="#26-alternatywa">Alternatywa</a></li>
<li><a href="#27-znak-ucieczki">Znak ucieczki</a></li>
<li><a href="#28-kotwice">Kotwice</a></li>
<li><a href="#281-kareta">Kareta</a></li>
<li><a href="#282-dolar">Dolar</a></li>
</ul></li>
<li><a href="#3-skr%C3%B3ty">Skróty</a></li>
<li><a href="#4-lookaround">Lookaround</a>
<ul>
<li><a href="#41-lookahead">Lookahead</a></li>
<li><a href="#42-odwr%C3%B3cony-lookahead">Odwrócony lookahead</a></li>
<li><a href="#43-lookbehind">Lookbehind</a></li>
<li><a href="#44-odwr%C3%B3cony-lookbehind">Odwrócony lookbehind</a></li>
</ul></li>
<li><a href="#5-flagi">Flagi</a>
<ul>
<li><a href="#51-wielko%C5%9B%C4%87-znak%C3%B3w">Wielkość znaków</a></li>
<li><a href="#52-przeszukiwanie-globalne">Przeszukiwanie globalne</a></li>
<li><a href="#53-multilinia">Multilinia</a></li>
</ul></li>
</ul>

<h2 id="toc_3">1. Najprostsze wyrażenie</h2>

<p>Wyrażenie regularne to ciąg znaków, których używamy do przeszukania tekstu.<br/>
Na przykład, wyrażenie <code>the</code> oznacza: literę <code>t</code>, następującą<br/>
po niej literę <code>h</code>, następującą po niej literę <code>e</code>.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Przetestuj wyrażenie</a></p>

<p>Wyrażenie regularne <code>123</code> pasuje do łańcucha <code>123</code>. Wyrażenie regularne<br/>
jest dopasowywane do danego łańcucha poprzez porównanie każdego znaku,<br/>
jeden po drugim, w wyrażeniu i łańcuchu. Wyrażenia są zwykle wrażliwe<br/>
na wielkość znaków, więc wyrażenie <code>The</code> nie pasuje do łańcucha <code>the</code>.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_4">2. Metaznaki</h2>

<p>Metaznaki to składowe elementy wyrażeń regularnych. Znaki te, nie oznaczają<br/>
siebie samych, są natomiast interpretowane w specjalny sposób.<br/>
Niektóre znaki mają specjalne znaczenie i są zapisywane w kwadratowych nawiasach.<br/>
Metaznaki to:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Metaznaki</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Dowolny znak z wyjątkiem nowej linii.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Zakres. Każdy znak zapisany w kwadratowym nawiasie.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Odwrócony zakres. Każdy znak, który nie znajduje się w kwadratowym nawiasie.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>0 lub więcej poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>1 lub więcej poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>0 lub 1 poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Minimum &quot;n&quot; ale nie więcej niż &quot;m&quot; poprzedzających znaków.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Grupowanie znaków. Znaki xyz dokładnie w tej kolejności.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Alternatywa. Znaki przed symbolem lub za symbolem.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Znak ucieczki. Umożliwia używanie zarezerwowanych znaków <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code>.</td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>Oznacza początek wzorca.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>Oznacza koniec wzorca.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Kropka</h2>

<p>Kropka <code>.</code> jest najprostszym przykładem metaznaku. Oznacza dowolny znak z wyłączeniem entera<br/>
i znaków nowej linii. Na przykład, wyrażenie regularne <code>.ar</code> oznacza: dowolny znak, następującą<br/>
po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_6">2.2 Zestaw znaków</h2>

<p>Zestawy znaków nazywane też klasami znaków. Nawiasy kwadratowe służą do określenia zestawów znaków.<br/>
Użycie myślnika wewnątrz zestawu, określa jego zakres. Kolejność znaków w nawiasach kwadratowych<br/>
nie ma znaczenia. Na przykład wyrażenie <code>[Tt]he</code> oznacza: dużą literę <code>T</code> lub małą <code>t</code>,<br/>
następującą po niej literę <code>h</code>, następującą po niej literę <code>e</code>.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Przetestuj wyrażenie</a></p>

<p>Jednak kropka w zestawie znaków, oznacza dosłownie kropkę. Wyrażenie regularne<br/>
<code>ar[.]</code> oznacza: małą literę <code>a</code>, następującą po niej literę <code>r</code>,<br/>
następującą po niej <code>.</code> kropkę.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_7">2.2.1 Odwrócony zestaw znaków</h3>

<p>Generalnie znak karety oznacza początek wyrażenia, ale gdy zostanie użyty zaraz<br/>
za otwierającym nawiasem kwadratowym, odwraca zestaw znaków. Na przykład<br/>
wyrażenie <code>[^c]ar</code> oznacza: każdy znak z wyjątkiem <code>c</code>,<br/>
następującą po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_8">2.3 Powtórzenia</h2>

<p>Następujące metaznaki <code>+</code>, <code>*</code> czy <code>?</code> określają ile razy wzorzec może się powtórzyć.<br/>
Te metaznaki zachowują się różnie, w zależności od sytuacji.</p>

<h3 id="toc_9">2.3.1 Gwiazdka</h3>

<p>Symbol <code>*</code> oznacza zero lub więcej powtórzeń poprzedzających znaków. Wyrażenie<br/>
regularne <code>a*</code> oznacza: zero lub więcej powtórzeń poprzedzającej małej<br/>
litery <code>a</code>. Ale jeśli występuje po zestawie znaków lub klasie, to oznacza<br/>
powtórzenia całego zestawu lub klasy. Na przykład, wyrażenie regularne<br/>
<code>[a-z]*</code> oznacza: każdy ciąg znaków pisany małymi literami.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Przetestuj wyrażenie</a></p>

<p>Symbol <code>*</code> może być użyty z metaznakiem <code>.</code> by oznaczyć każdy łańcuch<br/>
znaków <code>.*</code>. Symbol <code>*</code> może być użyty ze znakiem <code>\s</code><br/>
by znaleźć łańcuch zawierający spacje. Na przykład, wyrażenie<br/>
<code>\s*cat\s*</code> oznacza: zero lub więcej spacji, następującą po niej małą literę <code>c</code>,<br/>
następującą po niej małą literę <code>a</code>, następującą po niej małą literę <code>t</code>,<br/>
następujące po niej zero lub więcej spacji.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_10">2.3.2 Plus</h3>

<p>Symbol <code>+</code> oznacza jeden lub więcej powtórzeń poprzedzających znaków. Na przykład,<br/>
wyrażenie <code>c.+t</code> oznacza: małą literę <code>c</code>, następujący po niej przynajmniej jeden<br/>
dowolny znak, następującą po nim małą literę <code>t</code>. W tym wypadku <code>t</code> jest ostatnim<br/>
<code>t</code> w zdaniu.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_11">2.3.3 Znak zapytania</h3>

<p>W wyrażeniach regularnych znak <code>?</code> sprawia, że poprzedzający znak jest opcjonalny.<br/>
Ten symbol oznacza zero lub jedno wystąpienie poprzedzającego znaku. Na przykład,<br/>
wyrażenie regularne <code>[T]?he</code> oznacza: opcjonalną dużą literę <code>T</code>, następującą<br/>
po niej małą literę <code>h</code>, następującą po niej małą literę <code>e</code>.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Przetestuj wyrażenie</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_12">2.4 Klamry</h2>

<p>W wyrażeniach regularnych, klamry zwane również kwantyfikatorami, używane są<br/>
do określenia, ile razy znak lub grupa znaków może się powtórzyć.<br/>
Na przykład wyrażenie regularne <code>[0-9]{2,3}</code> oznacza: przynajmniej<br/>
2 znaki, ale nie więcej niż 3 (znaki z zakresu od 0 do 9).</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Przetestuj wyrażenie</a></p>

<p>Możemy opuścić drugą liczbę. Na przykład regularne wyrażenie <code>[0-9]{2,}</code><br/>
oznacza: 2 lub więcej znaków. Jeżeli dodatkowo usuniemy przecinek,<br/>
to wyrażenie <code>[0-9]{3}</code> oznacza: dokładnie 3 znaki z zakresu 0 do 9.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Przetestuj wyrażenie</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_13">2.5 Grupa znaków</h2>

<p>Grupa znaków to grupa podwzorców, które zapisywane są w nawiasach <code>(...)</code>.<br/>
Jak wspominaliśmy wyżej, jeśli w wyrażeniu regularnym wstawimy kwantyfikator po<br/>
znaku, wtedy powtórzy on ten znak. Ale gdy wstawimy kwantyfikator po grupie znaków,<br/>
wtedy cała grupa zostanie powtórzona. Na przykład wyrażenie regularne <code>(ab)*</code><br/>
oznacza zero lub więcej powtórzeń grupy &quot;ab&quot;. Możemy także użyć metaznaku<br/>
alternatywy <code>|</code> wewnątrz grupy. Na przykład wyrażenie <code>(c|g|p)ar</code> oznacza: małą literę <code>c</code>,<br/>
<code>g</code> lub <code>p</code>, następującą po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_14">2.6 Alternatywa</h2>

<p>W wyrażeniach regularnych pionowa kreska <code>|</code> oznacza alternatywę.<br/>
Działa jak warunek pomiędzy różnymi wyrażeniami. Teraz możesz pomyśleć, że<br/>
to działa tak samo jak zestaw znaków. Różnica polega na tym, że zestaw znaków<br/>
działa na poziomie znaków, natomiast alternatywa na poziomie wyrażenia. Na przykład<br/>
wyrażenie regularne <code>(T|t)he|car</code> oznacza: dużą literę <code>T</code> lub małą <code>t</code>,<br/>
następującą po niej literę <code>h</code>, następującą po niej literę <code>e</code> lub <code>c</code>, następującą<br/>
po niej literę <code>a</code>, następującą po niej literę <code>r</code>.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_15">2.7 Znak ucieczki</h2>

<p>Ukośnik <code>\</code> w wyrażeniach regularnych jest znakiem ucieczki. Pozwala on<br/>
używać w wyrażeniu zarezerwowanych znaków takich jak <code>{ } [ ] / \ + * . $ ^ | ?</code>.<br/>
Aby użyć znaku specjalnego w wyrażeniu, postaw <code>\</code> przed nim.</p>

<p>Na przykład wyrażenie <code>.</code> dopasowuje każdy znak z wyjątkiem nowej linii.<br/>
Żeby dopasować kropkę <code>.</code> w wyrażeniu regularnym, trzeba wstawić przed nią ukośnik.<br/>
Wyrażenie <code>(f|c|m)at\.?</code> oznacza: małe litery <code>f</code> lub <code>c</code> lub <code>m</code>, następującą po niej<br/>
literę <code>a</code>, następującą po niej literę <code>t</code>, następującą kropkę <code>.</code>, która jest opcjonalna.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_16">2.8 Kotwice</h2>

<p>W wyrażeniach regularnych używamy kotwic aby sprawdzić czy dopasowywany symbol<br/>
jest pierwszym lub ostatnim symbolem w łańcuchu. Są dwa typy: pierwszy to<br/>
kareta <code>^</code>, która sprawdza czy znak jest początkiem łańcucha, drugi to dolar <code>$</code>,<br/>
który sprawdza czy znak jest ostatnim elementem łańcucha.</p>

<h3 id="toc_17">2.8.1 Kareta</h3>

<p>Kareta <code>^</code> sprawdza czy znak jest początkiem łańcucha. Jeżeli użyjemy takiego<br/>
wyrażenia <code>^a</code> (jeśli a jest pierwszym znakiem) na łańcuchu <code>abc</code> to dopasuje<br/>
nam <code>a</code>. Ale jeśli użyjemy takiego wyrażenia <code>^b</code> na tym samym łańcuchu, to nie<br/>
zwróci nam nic. Ponieważ w łańcuchu <code>abc</code> &quot;b&quot; nie jest pierwszym symbolem.<br/>
Spójrzmy teraz na wyrażenie <code>^(T|t)he</code> które oznacza: dużą literę <code>T</code> lub małą<br/>
<code>t</code>, która jest początkiem łańcucha, następującą po niej literę <code>h</code>, następującą<br/>
po niej literę <code>e</code>.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Przetestuj wyrażenie</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_18">2.8.2 Dolar</h3>

<p>Symbol dolara <code>$</code> używany jest do sprawdzenia czy dopasowywany znak jest ostatni<br/>
w łańcuchu. Na przykład, wyrażenie regularne <code>(at\.)$</code> oznacza: małą literę <code>a</code>,<br/>
następującą po niej literę <code>t</code>, następującą po niej kropkę <code>.</code> i na dodatek<br/>
dopasowanie musi być końcem łańcucha.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Przetestuj wyrażenie</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_19">3. Skróty</h2>

<p>W wyrażeniach regularnych znajdziemy także skróty dla popularnych zestawów znaków,<br/>
które ułatwiają pracę z wyrażeniami regularnymi. Skróty wyglądają następująco:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Skrót</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Każdy znak z wyjątkiem nowej linii</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Znaki alfanumeryczne: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>Znaki nie alfanumeryczne: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Cyfry: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Nie cyfry: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Dowolny biały znak: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Każdy znak oprócz białych: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. Lookaround</h2>

<p>Lookbehind i lookahead (nazywane również lookaround) to specyficzne typy<br/>
<strong><em>niezwracających grup</em></strong> (dopasowują wzorzec, ale nie zwracają wartości).<br/>
Lookaround używane są w sytuacji, gdy mamy wzorzec i jest on poprzedzony innym wzorcem,<br/>
lub następuje po nim kolejny wzorzec. Na przykład, chcemy mieć wszystkie<br/>
numery, które są poprzedzone znakiem <code>$</code> w takim łańcuchu <code>$4.44 and $10.88</code>.<br/>
Użyjemy takiego wyrażenia regularnego <code>(?&lt;=\$)[0-9\.]*</code> które oznacza: znajdź<br/>
wszystkie liczby ze znakiem <code>.</code> poprzedzone znakiem <code>$</code>. W wyrażeniach regularnych<br/>
wyróżniamy:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Symbol</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Odwrócony lookahead</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Lookbehind</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Odwrócony lookbehind</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 Lookahead</h3>

<p>Lookahead stwierdza, że po pierwszej części wyrażenia musi następować<br/>
następne wyrażenie. Zwracane dopasowanie zawiera tylko tekst, który został<br/>
dopasowany przez pierwszą część wyrażenia. Stosuje się je w nawiasach wraz<br/>
ze znakami zapytania i równości: <code>(?=...)</code>. Wyrażenie lookahead<br/>
wpisuje się po znaku równości. Na przykład wyrażenie <code>(T|t)he(?=\sfat)</code><br/>
oznacza: opcjonalną małą literę <code>t</code> lub dużą <code>T</code>, następującą po niej<br/>
literę <code>h</code>, następującą po niej literę <code>e</code>. W nawiasach definiujemy<br/>
wyrażenie lookahead, które mówi aby dopasować <code>The</code> lub <code>the</code> i następujące<br/>
po nich <code>fat</code>.</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_22">4.2 Odwrócony lookahead</h3>

<p>Używany jest, gdy potrzebujemy dopasowania z łańcucha, po których nie następują<br/>
żadne wzorce. Odwrócony lookahead definiujemy w nawiasach, stosując znak negacji<br/>
<code>!</code> po znaku zapytania, na przykład: <code>(?!...)</code>. Popatrzmy na następujące wyrażenie<br/>
<code>(T|t)he(?!\sfat)</code> które oznacza: znajdź wszystkie słowa <code>The</code> lub <code>the</code> w łańcuchu,<br/>
po których nie następuje słowo <code>fat</code>, poprzedzone spacją.</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_23">4.3 Lookbehind</h3>

<p>Lookbehind używany jest do odnalezienia wszystkich dopasowań poprzedzonych konkretnym<br/>
wzorcem. Wyrażenie lookbehind zapisujemy tak: <code>(?&lt;=...)</code>. Na przykład, wyrażenie<br/>
<code>(?&lt;=(T|t)he\s)(fat|mat)</code> oznacza: znajdź wszystkie słowa <code>fat</code> lub <code>mat</code> w łańcuchu,<br/>
które znajdują się po słowach <code>The</code> lub <code>the</code>.</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_24">4.4 Odwrócony lookbehind</h3>

<p>Odwrócony używany jest do odnalezienia wszystkich dopasowań niepoprzedzonych konkretnym<br/>
wzorcem. Odwrócony lookbehind zapisujemy tak: <code>(?&lt;!...)</code>. Na przykład, wyrażenie<br/>
<code>(?&lt;!(T|t)he\s)(cat)</code> oznacza: znajdź wszystkie słowa <code>cat</code> w stringu, które nie następują<br/>
po słowach <code>The</code> lub <code>the</code>.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_25">5. Flagi</h2>

<p>Flagi nazywane są także modyfikatorami, ponieważ zmieniają wynik wyrażenia regularnego.<br/>
Flagi mogą być używane w każdej kombinacji i są integralną częścią wyrażeń regularnych.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Flaga</th>
<th>Opis</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Wielkość znaków: Sprawia, że dopasowanie nie jest wrażliwe na wielkość znaków.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Przeszukanie globalne: Wyszukiwanie wzorca w całym łańcuchu.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Multilinia: Sprawia, że kotwice działają na każdej linii.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 Wielkość znaków</h3>

<p>Modyfikator <code>i</code> używany jest, gdy wielkość liter nie ma znaczenia. Na przykład<br/>
wyrażenie <code>/The/gi</code> oznacza: dużą literę <code>T</code>, następującą po niej literę <code>h</code>,<br/>
następującą po niej literę <code>e</code>. A na końcu wyrażenia, flaga <code>i</code> żeby ignorować<br/>
wielkość znaków. Jak widać, została też użyta flaga <code>g</code> ponieważ chcemy przeszukać<br/>
cały łańcuch.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Przetestuj wyrażenie</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_27">5.2 Przeszukiwanie globalne</h3>

<p>Modyfikator <code>g</code> używany jest do przeszukiwania całego łańcucha (znajdź wszystko,<br/>
a nie tylko zatrzymuj się na pierwszym). Na przykład wyrażenie <code>/.(at)/g</code><br/>
oznacza: każdy znak z wyjątkiem nowej linii, następującą po nim literę <code>a</code>,<br/>
następującą po niej literę <code>t</code>. Ponieważ użyliśmy na końcu wyrażenia flagi <code>g</code>,<br/>
wyszukane zostaną wszystkie dopasowania w łańcuchu, a nie tylko pierwszy (domyślne zachowanie).</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Przetestuj wyrażenie</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Przetestuj wyrażenie</a></p>

<h3 id="toc_28">5.3 Multilinia</h3>

<p>Modyfikator <code>m</code> używany jest do dopasowywania w wielu liniach. Jak wspominaliśmy<br/>
wcześniej, kotwice <code>(^, $)</code> używane są do sprawdzania czy wzorzec jest początkiem<br/>
lub końcem łańcucha. Jeśli chcemy, żeby kotwice zadziałały w każdej linii, używamy<br/>
wtedy flagi <code>m</code>. Na przykład wyrażenie <code>/at(.)?$/gm</code> oznacza: małą literę <code>a</code>,<br/>
następującą po niej małą literę <code>t</code>, opcjonalnie dowolny znak z wyjątkiem nowej linii.<br/>
I ponieważ użyliśmy flagi <code>m</code> dopasowywane będą wzorce na końcu każdej linii w łańcuchu.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Przetestuj wyrażenie</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Przetestuj wyrażenie</a></p>

<h2 id="toc_29">Kontrybucja</h2>

<ul>
<li>Zgłaszanie błędów</li>
<li>Otwieranie pull request z poprawkami</li>
<li>Dzielenie się poradnikiem</li>
<li>Skontaktuj się ze mną <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> lub <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">Licencja</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629703.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">번역:</h2>

<ul>
<li><a href="media/15998025629703/README.md">English</a></li>
<li><a href="media/15998025629703/README-es.md">Español</a></li>
<li><a href="media/15998025629703/README-fr.md">Français</a></li>
<li><a href="media/15998025629703/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629703/README-cn.md">中文版</a></li>
<li><a href="media/15998025629703/README-ja.md">日本語</a></li>
<li><a href="media/15998025629703/README-ko.md">한국어</a></li>
<li><a href="media/15998025629703/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629703/README-gr.md">Greek</a></li>
<li><a href="media/15998025629703/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629703/README-pl.md">Polish</a></li>
<li><a href="media/15998025629703/README-ru.md">Русский</a></li>
<li><a href="media/15998025629703/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629703/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">정규표현식이란 무엇인가?</h2>

<blockquote>
<p>정규표현식은 텍스트에서 특정 패턴을 찾아내는데 사용되는 문자 혹은 기호들의 집합이다.</p>
</blockquote>

<p>정규표현식(Regular expression)은 대상 문자열에 왼쪽에서 오른쪽 방향으로 매칭되는 하나의 패턴이다. &quot;Regular expression&quot;이라고 매번 발음하기 어렵기 때문에, 보통 약어로 &quot;regex&quot; 혹은 &quot;regexp&quot;, &quot;정규식&quot;으로 축약되어 사용된다. 정규 표현식은 문자열 내부의 텍스트 대체, 포맷의 유효성 검사, 패턴 매칭을 기반으로한 문자열에서 일부 텍스트를 추출, 그리고 그 외에 다양한 목적을 위해 사용된다.</p>

<p>당신이 하나의 어플리케이션을 작성하고 있고 사용자가 사용자명을 선택할 때 사용되는 규칙들을 정하고 싶다고 상상해보자. 예를 들어, 우리는 사용자명에 문자, 숫자, 밑줄 문자(_), 그리고 하이픈이 포함되는 것은 허용하고 싶다. 또한, 사용자명의 글자수를 제한해서 사용자명이 지저분해보이지 않도록 하고 싶다. 이때 아래 정규표현식을 사용해 입력된 사용자명이 해당 규칙에 맞는지 검사할 수 있다.</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-en.png" alt="Regular expression"><br/>
</p></p>

<p>위의 정규 표현식은 <code>john_doe</code>, <code>jo-hn_doe</code>, 그리고 <code>john12_as</code> 문자열을 받아들일 수 있다. <code>Jo</code>는 대문자를 포함하고 있고 길이가 너무 짧기 때문에 위의 정규표현식과 매칭되지 않는다.</p>

<h2 id="toc_2">목차</h2>

<ul>
<li><a href="#1-%EA%B8%B0%EB%B3%B8-%EB%A7%A4%EC%B3%90">기본 매쳐</a></li>
<li><a href="#2-%EB%A9%94%ED%83%80-%EB%AC%B8%EC%9E%90">메타 문자</a>
<ul>
<li><a href="#21-%EB%A7%88%EC%B9%A8%ED%91%9C">마침표</a></li>
<li><a href="#22-%EB%AC%B8%EC%9E%90-%EC%A7%91%ED%95%A9">문자 집합</a></li>
<li><a href="#221-%EB%B6%80%EC%A0%95-%EB%AC%B8%EC%9E%90-%EC%A7%91%ED%95%A9">부정 문자 집합</a></li>
<li><a href="#23-%EB%B0%98%EB%B3%B5">반복</a></li>
<li><a href="#231-%EB%B3%84-%EB%B6%80%ED%98%B8">별 부호</a></li>
<li><a href="#232-%EB%8D%A7%EC%85%88-%EB%B6%80%ED%98%B8">덧셈 부호</a></li>
<li><a href="#233-%EB%AC%BC%EC%9D%8C%ED%91%9C">물음표</a></li>
<li><a href="#24-%EC%A4%91%EA%B4%84%ED%98%B8">중괄호</a></li>
<li><a href="#25-%EC%BA%A1%EC%B3%90-%EA%B7%B8%EB%A3%B9">캡쳐링 그룹</a></li>
<li><a href="#251-%EB%85%BC-%EC%BA%A1%EC%B3%90%EB%A7%81-%EA%B7%B8%EB%A3%B9">논-캡쳐링 그룹</a></li>
<li><a href="#26-%EB%8C%80%EC%95%88-%EB%B6%80%ED%98%B8">대안 부호</a></li>
<li><a href="#27-%ED%8A%B9%EC%88%98-%EB%AC%B8%EC%9E%90-%EC%9D%B4%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%95%91">특수 문자 이스케이핑</a></li>
<li><a href="#28-%EC%95%B5%EC%BB%A4-%EB%B6%80%ED%98%B8">앵커 부호</a></li>
<li><a href="#281-%EC%BA%90%EB%9F%BF-%EB%B6%80%ED%98%B8">캐럿 부호</a></li>
<li><a href="#282-%EB%8B%AC%EB%9F%AC-%EB%B6%80%ED%98%B8">달러 부호</a></li>
</ul></li>
<li><a href="#3-%EB%8B%A8%EC%B6%95%ED%98%95-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A7%91%ED%95%A9">단축형 문자열 집합</a></li>
<li><a href="#4-%EC%A0%84%ED%9B%84%EB%B0%A9%ED%83%90%EC%83%89">전후방탐색</a>
<ul>
<li><a href="#41-%EA%B8%8D%EC%A0%95%ED%98%95-%EC%A0%84%EB%B0%A9%ED%83%90%EC%83%89">긍정형 전방탐색</a></li>
<li><a href="#42-%EB%B6%80%EC%A0%95%ED%98%95-%EC%A0%84%EB%B0%A9%ED%83%90%EC%83%89">부정형 전방탐색</a></li>
<li><a href="#43-%EA%B8%8D%EC%A0%95%ED%98%95-%ED%9B%84%EB%B0%A9%ED%83%90%EC%83%89">긍정형 후방탐색</a></li>
<li><a href="#44-%EB%B6%80%EC%A0%95%ED%98%95-%ED%9B%84%EB%B0%A9%ED%83%90%EC%83%89">부정형 후방탐색</a></li>
</ul></li>
<li><a href="#5-%ED%94%8C%EB%9E%98%EA%B7%B8">플래그</a>
<ul>
<li><a href="#51-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EA%B5%AC%EB%B6%84%EC%97%86%EC%9D%8C">대소문자 구분없음</a></li>
<li><a href="#52-%EC%A0%84%EC%B2%B4-%EA%B2%80%EC%83%89">전체 검색</a></li>
<li><a href="#53-%EB%A9%80%ED%8B%B0-%EB%9D%BC%EC%9D%B8">멀티 라인</a></li>
</ul></li>
<li><a href="#6-%ED%83%90%EC%9A%95%EC%A0%81-vs-%EA%B2%8C%EC%9C%BC%EB%A5%B8%20%EB%A7%A4%EC%B9%AD">탐욕적 vs 게으른 매칭</a></li>
</ul>

<h2 id="toc_3">1. 기본 매쳐</h2>

<p>하나의 정규 표현식은 단지 텍스트 내부의 검색을 수행하기 위한 문자열의 패턴이다. 예를 들어, 정규 표현식 <code>the</code>는 문자 <code>t</code> 다음에 문자 <code>h</code>, 그 다음에 문자 <code>e</code>가 나오는 것을 의미한다.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Test the regular expression</a></p>

<p>정규 표현식 <code>123</code>은 문자열 <code>123</code>에 매칭된다. 정규 표현식은 정규 표현식의 각 문자(Character)와 입력된 문자열의 각 문자(Character)를 비교함으로써 해당 문자열과 매칭된다. 정규 표현식들은 일반적으로 대소문자를 구분하기 때문에, 정규 표현식 <code>The</code>는 문자열 <code>the</code>와 매칭되지 않는다.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Test the regular expression</a></p>

<h2 id="toc_4">2. 메타 문자</h2>

<p>메타 문자들은 정규 표현식의 빌딩 블락들이다. 메타 문자들은 자체적인 의미를 가지지 않고 특별한 방식으로 해석되어진다. 어떤 메타 문자열들은 특별한 의미를 가지며 대괄호안에서 쓰인다. 아래는 이러한 메타 문자열들이다:</p>

<table>
<thead>
<tr>
<th style="text-align: center">메타 문자</th>
<th>설명</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>온점(Period)는 줄바꿈을 제외한 어떤 종류의 단일 문자와 매치.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>문자 클래스. 대괄호 사이에 있는 문자들로 매치.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>부정 문자 클래스. 대괄호 안에 포함되지 않은 모든 문자들로 매치.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>이 메타 문자의 바로 앞에 있는 심볼이 0번 이상 반복된 문자들과 매치.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>이 메타 문자의 바로 앞에 있는 심볼이 한번 이상 반복된 문자들과 매치.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>이 메타 문자의 바로 앞에 있는 심볼을 선택적(optional)으로 만듬.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>중괄호. 이 메타 문자의 바로 앞에 위치한 심볼이 최소 n번 최대 m번의 반복된 문자들과 매치.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>문자 그룹. 문자열 xyz와 정확히 같은 순서를 가진 문자들과 매치.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>대안. 문자가 이 메타 문자의 앞에 있는 심볼이거나 뒤에 있는 심볼이면 매치.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>다음 문자 이스케이프(Escape). 예약된 문자열들 <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code>을 이스케이핑함으로써 그 자체와 매칭되는 것을 허용.</td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>입력의 시작과 매치.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>입력의 끝과 매치.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 마침표</h2>

<p>마침표(<code>.</code>)는 메타 문자의 가장 간단한 예다. 메타 문자 <code>.</code>는 어떠한 단일 문자와도 매치되지만 리턴 혹은 개행 문자와는 매치되지 않는다. 예를 들어, 정규 표현식 <code>.ar</code>은 어떠한 단일 문자 다음에 문자 <code>a</code>가 오고, 그 다음에 문자 <code>r</code>이 오는 패턴을 의미한다.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Test the regular expression</a></p>

<h2 id="toc_6">2.2 문자 집합</h2>

<p>문자 집합은 문자 클래스라고도 불린다. 대괄호는 이 문자 집합을 명시하기 위해 사용된다. 문자열 집합내에 사용된 하이픈은 문자들의 범위를 지정하는데 사용된다. 대괄호 내부에 명시된 문자들의 순서는 중요하지 않다. 예를 들어, 정규 표현식 <code>[Tt]he</code>는 대문자 <code>T</code> 혹은 소문자 <code>t</code>가 나온 다음에, 문자 <code>h</code>가 나오고 그 뒤에 문자 <code>e</code>가 나오는 패턴을 의미한다.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Test the regular expression</a></p>

<p>하지만, 문자 집합 내부에서 사용되는 온점(Period)은 온점 그 자체를 의미한다. 정규 표현식 <code>ar[.]</code>은 소문자 <code>a</code> 다음에 문자 <code>r</code>이 오고 그 뒤에 문자 <code>.</code>이 오는 패턴을 의미한다.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Test the regular expression</a></p>

<h3 id="toc_7">2.2.1 부정 문자 집합</h3>

<p>일반적으로, 캐럿 기호(<sup>)는</sup> 문자열의 시작지점을 나타내지만, 왼쪽 대괄호 바로 뒤에 위치했을때는 해당 문자 집합의 부정(negation)을 나타낸다. 예를 들어, 정규 표현식 <code>[^c]ar</code>은 문자 <code>c</code>를 제외한 어떠한 문자뒤에 문자 <code>a</code>가 오고, 그 뒤에 문자 <code>r</code>이 오는 패턴을 의미한다.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Test the regular expression</a></p>

<h2 id="toc_8">2.3 반복</h2>

<p>메타 문자 <code>+</code>, <code>*</code> 또는 <code>?</code>은 하위패턴(subpattern)이 몇 번 발생하는지 지정하는데 사용된다. 이러한 메타 문자들은 상황에 따라 다르게 동작한다.</p>

<h3 id="toc_9">2.3.1 별 부호</h3>

<p><code>*</code> 부호는 부호 앞에 위치한 매처(matcher)가 0번 이상 반복된 문자열과 매치된다. 정규 표현식 <code>a*</code>은 소문자 <code>a</code>가 0번 이상 반복되는 패턴을 의미한다. 하지만, 만약 이 별 부호가 문자 집합(character set) 직후에 나오는 경우에는 문자 집합 전체의 반복을 찾게된다. 예를 들어, 정규 표현식 <code>[a-z]*</code>은 소문자들이 갯수와 상관없이 연속으로 반복되는 패턴을 의미한다.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Test the regular expression</a></p>

<p><code>*</code> 부호는 메타 문자 <code>.</code>와 함께 모든 문자열과 매치되는 패턴을 만드는데 사용될 수 있다. 또한, <code>*</code> 부호는 공백 문자 <code>\s</code>와 함께 공백 문자들로 이루어진 문자열과 매치되는 패턴을 만드는데 사용될 수 있다. 예를 들어, 정규 표현식 <code>\s*cat\s*</code>는 0번 이상 공백문자가 나온 이후에 소문자 <code>c</code>, 소문자 <code>a</code>, 소문자 <code>t</code>가 자체로 나오고 그 뒤에 다시 0번 이상의 공백문자가 나오는 패턴을 의미한다.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Test the regular expression</a></p>

<h3 id="toc_10">2.3.2 덧셈 부호</h3>

<p><code>+</code> 부호는 부호 앞에 위치한 문자가 한번 이상 반복되는 패턴을 만드는데 사용된다. 예를 들어, 정규 표현식 <code>c.+t</code>는 소문자 <code>c</code>가 나오고, 그 뒤에 한개 이상의 문자가 나온 후, 소문자 <code>t</code>가 나오는 패턴을 의미한다. 여기서 문자 <code>t</code>는 해당 문장의 제일 마지막 글자 <code>t</code>라는것을 명확히할 필요가 있다.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Test the regular expression</a></p>

<h3 id="toc_11">2.3.3 물음표</h3>

<p>정규 표현식에서 메타 문자 <code>?</code>는 선행 문자를 선택적으로 만드는 역할을 한다. 물음표는 부호 앞에 쓰여진 문자가 선택적으로 나오는 패턴을 나타내는데 사용된다. 예를 들어, 정규 표현식 <code>[T]?he</code>는 대문자 <code>T</code>가 선택적으로 나온 이후에, 그 뒤에 소문자 <code>h</code>, 그 뒤에 소문자 <code>e</code>가 나오는 패턴을 의미한다.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Test the regular expression</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Test the regular expression</a></p>

<h2 id="toc_12">2.4 중괄호</h2>

<p>정규 표현식에서 정량자(quantifier)라고도 불리는 중괄호는 하나의 문자 혹은 문자 집합으로 표시된 문자가 몇번 반복되는지 명시하는데 사용된다. 예를 들어, 정규 표현식 <code>[0-9]{2,3}</code>은 숫자 문자(0부터 9사이의 문자)가 최소 2번, 최대 3번 연속해서 나오는 문자열 패턴을 의미한다.</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Test the regular expression</a></p>

<p>두번째 숫자를 생략하는 것이 가능하다. 예를 들어, 정규 표현식 <code>[0-9]{2,}</code>는 2번 이상의 숫자가 연속으로 나오는 패턴을 의미한다. 만약 여기서 쉼표를 삭제하는 경우, 정규 표현식 <code>[0-9]{3}</code>은 숫자가 정확히 3번 연속해서 나오는 패턴을 의미한다.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Test the regular expression</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Test the regular expression</a></p>

<h2 id="toc_13">2.5 캡쳐링 그룹</h2>

<p>캡쳐링 그룹은 괄호 <code>(...)</code> 안에 쓰여진 하위 패턴들의 그룹이다. 위에서 논의했듯이, 정규 표현식에서 하나의 문자 뒤에 정량자(quantifier)를 넣는 경우에는 해당 문자의 반복을 나타낸다. 하지만, 만약 하나의 캡쳐링 그룹 뒤에 정량자를 넣는 경우에는 캡쳐링 그룹 전체의 반복을 나타내게 된다. 예를 들어, 정규 표현식 <code>(ab)*</code>는 문자 &quot;ab&quot;가 0번 이상 반복되는 패턴을 의미한다. 대안 부호인 <code>|</code> 또한 문자 그룹 내부에서 사용할 수 있다. 예를 들어, 정규 표현식 <code>(c|g|p)ar</code>은 소문자 <code>c</code>, <code>g</code> 혹은 <code>p</code>가 나온 이후에 문자 <code>a</code>가 나오고 그 뒤에 문자 <code>r</code>이 나오는 패턴을 의미한다.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Test the regular expression</a></p>

<p>캡처링 그룹은 부모 언어에서 사용하기 위해 문자를 일치시킬뿐만 아니라 문자를 캡처한다는 점에 유의해야 한다. 부모 언어는 파이썬이나 자바 스크립트 또는 함수 정의에서 정규 표현식을 구현하는 거의 모든 언어가 될 수 있다.</p>

<h3 id="toc_14">2.5.1 논-캡쳐링 그룹</h3>

<p>논-캡쳐링 그룹은 오직 문자열에 매칭되지만, 그룹을 캡쳐하지 않는 캡쳐링 그룹이다. 논-캡쳐링 그룹은 <code>(...)</code> 괄호안에 <code>?:</code> 로 표시된다. 예를 들어 정규식 <code>(?:c|g|p)ar</code> 는 <code>(c|g|p)ar</code>와 같은 문자열을 매칭하는 것에서 유사하지만, 캡쳐링 그룹을 만들지 않는다.</p>

<pre>
"(?:c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/Rm7Me8/1">Test the regular expression</a></p>

<p>논-캡처링 그룹은 찾기 및 변경 기능에서 사용하거나 캡처 그룹 함께 사용하여 다른 종류의 출력 생성시 overview를 유지할 때 유용하다. 또한 <a href="#4-%EC%A0%84%ED%9B%84%EB%B0%A9%ED%83%90%EC%83%89">4. 전후방탐색</a>를 보아라.</p>

<h2 id="toc_15">2.6 대안 부호</h2>

<p>정규 표현식에서 수직 막대 부호 <code>|</code>는 대안을 정의하는데 사용된다. 대안 부호는 여러개의 표현식들 사이의 조건과도 같다. 지금쯤 당신은 문자 집합(Character set)과 대안 부호가 동일하게 동작한다고 생각하고 있을 것이다. 하지만, 문자 집합과 대안 부호 사이의 가장 큰 차이점은 문자 집합은 문자 수준에서 동작하는 반면, 대안 부호는 표현식 수준에서 동작한다는 것이다. 예를 들어, 정규 표현식 <code>(T|t)he|car</code>는 대문자 <code>T</code> 혹은 소문자 <code>t</code>가 나오고 문자 <code>h</code>, 문자 <code>e</code>가 차례로 나오거나 문자 <code>c</code>, 문자 <code>a</code>, 문자 <code>r</code>이 차례로 나오는 패턴을 의미한다.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Test the regular expression</a></p>

<h2 id="toc_16">2.7 특수 문자 이스케이핑</h2>

<p>백 슬래시 <code>\</code>는 정규 표현식에서 다음에 나오는 부호를 이스케이핑하는데 사용된다. 백 슬래시는 예약 문자들인 <code>{ } [ ] / \ + * . $ ^ | ?</code>를 메타 부호가 아닌 문자 그 자체로 매칭되도록 명시한다. 특수 문자를 매칭 캐릭터로 사용하기 위해서는 백 슬래시 <code>\</code>를 해당 특수 문자 앞에 붙이면 된다. 예를 들어, 정규 표현식 <code>.</code>은 개행을 제외한 어떤 문자와 매칭된다. 입력 문자열에 포함된 <code>.</code> 문자를 매치시키는 정규 표현식 <code>(f|c|m)at\.?</code>은 소문자 <code>f</code>, <code>c</code> 또는 <code>m</code> 이후에 소문자 <code>a</code>와 <code>t</code>가 차례로 등장하고 이후에 문자 <code>.</code>가 선택적으로 나타나는 패턴을 의미한다.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Test the regular expression</a></p>

<h2 id="toc_17">2.8 앵커 부호</h2>

<p>정규 표현식에서 앵커는 매칭 문자가 표현식의 시작 문자인지 혹은 끝 문자인지 명시하는데 사용된다. 앵커는 두가지 종류가 있다: 첫번째 종류인 캐럿 부호 <code>^</code>는 매칭 문자가 입력 문자열의 첫 시작 문자인지 나타내는데 사용되며 두번째 종류인 달러 부호 <code>$</code>는 해당 매칭 문자가 입력 문자의 마지막 문자라는 것을 명시하는데 사용된다.</p>

<h3 id="toc_18">2.8.1 캐럿 부호</h3>

<p>캐럿 부호 <code>^</code>는 매칭 문자가 표현식의 시작이라는 것을 명시하는데 사용된다. 만약 (a가 시작 문자인지 확인하는) 정규 표현식 <code>^a</code>를 입력 문자열 <code>abc</code>에 적용하면, 이 정규 표현식은 <code>a</code>를 매칭 결과값으로 내보낸다. 반면, 정규 표현식 <code>^b</code>를 위의 입력 문자열에 적용하면, 아무런 매칭도 일어나지 않는다. 왜냐하면 입력 문자열 <code>abc</code>에서 &quot;b&quot;는 처음 시작 문자가 아니기 때문이다. 또 다른 정규 표현식인 <code>^(T|t)he</code>를 살펴보자. 이 정규 표현식은 대문자 <code>T</code> 또는 소문자 <code>t</code>가 입력 문자열의 시작으로 나오고, 그 뒤에 문자 <code>h</code>와 문자 <code>e</code>가 차례로 나오는 패턴을 의미한다.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Test the regular expression</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Test the regular expression</a></p>

<h3 id="toc_19">2.8.2 달러 부호</h3>

<p>달러 부호 <code>$</code>는 입력 문자열의 마지막 문자가 매칭 문자로 끝나는지 확인하는데 사용된다. 예를 들어, 정규 표현식 <code>(at\.)$</code>는 소문자 <code>a</code>와 <code>t</code> 그리고 문자 <code>.</code>가 순서대로 입력 문자열의 맨 마지막에 나오는지 확인하는 패턴을 의미한다.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Test the regular expression</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Test the regular expression</a></p>

<h2 id="toc_20">3. 단축형 문자열 집합</h2>

<p>정규 표현식은 일반적으로 사용되는 문자열 집합들을 간편하게 사용할 수 있도록 여러 단축형들을 제공한다. 단축형 문자열 집합은 아래와 같다.</p>

<table>
<thead>
<tr>
<th style="text-align: center">단축형</th>
<th>설명</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>개행을 제외한 모든 문자</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>영숫자 문자와 매치: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>영숫자 문자가 아닌 문자와 매치: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>숫자와 매치: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>숫자가 아닌 문자와 매치: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>공백 문자와 매치: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>공백 문자가 아닌 문자와 매치: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_21">4. 전후방탐색</h2>

<p>때때로 전후방탐색<sub>Lookaround</sub>이라고 알려진 후방탐색<sub>Lookbehind</sub>과 전방탐색<sub>Lookahead</sub>은 (패턴 매칭을 위해서 사용되지만 매칭된 리스트에는 포함되지 않는) <strong><u>넌-캡쳐링 그룹</u></strong> 의 특정 종류들이다. 전후방탐색은 하나의 패턴이 다른 특정 패턴 전이나 후에 나타나는 조건을 가지고 있을때 사용한다. 예를 들어, 우리가 입력 문자열 <code>$4.44 and $10.88</code>에 대해서 달러 부호 <code>$</code>이후에 나오는 모든 숫자를 매칭시키고 싶다고 하자. 이때 정규 표현식 <code>(?&lt;=\$)[0-9\.]*</code>를 사용할 수 있다. 이 정규 표현식은 <code>$</code> 문자 뒤에 나오는 문자 <code>.</code>을 포함한 모든 숫자 문자를 의미한다. 다음은 정규 표현식에서 사용되는 전후방탐색들이다.</p>

<table>
<thead>
<tr>
<th style="text-align: center">부호</th>
<th>설명</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>긍정형 전방탐색</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>부정형 전방탐색</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>긍정형 후방탐색</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>부정형 후방탐색</td>
</tr>
</tbody>
</table>

<h3 id="toc_22">4.1 긍정형 전방탐색</h3>

<p>긍정형 전방탐색는 표현식의 첫 부분뒤에 전방탐색 표현식이 뒤따라 나오는지 확인하는데 사용된다. 매칭의 결과값은 표현식의 첫 부분과 매칭된 텍스트만이 포함된다. 긍정형 전방탐색를 정의하기 위해서는 괄호가 사용된다. 이 괄호 안에서, 물음표 부호 <code>?</code>와 등호 <code>=</code>가 다음과 같이 사용된다: <code>(?=...)</code>. 전방탐색 표현식은 괄호 내부의 등호 <code>=</code> 부호 뒤에 쓰면된다. 예를 들어, 정규 표현식 <code>[T|t]he(?=\sfat)</code>는 대문자 <code>T</code> 혹은 소문자 <code>t</code> 뒤에 문자 <code>h</code>, 문자 <code>e</code>가 나오는 패턴을 의미한다. 괄호 안에서 우리는 정규 표현식 엔진에게 바로 뒤에 공백문자와 문자열 <code>fat</code>이 나오는 <code>The</code> 또는 <code>the</code>만 매치하도록 알리는 긍정형 전방탐색를 정의하였다.</p>

<pre>
"[T|t]he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Test the regular expression</a></p>

<h3 id="toc_23">4.2 부정형 전방탐색</h3>

<p>부정형 전방탐색는 입력 문자열로부터 특정 패턴이 뒤에 나오지 않기를 바라는 상황에서 사용된다. 부정형 전방탐색는 우리가 긍정형 전방탐색를 정의하는 방식과 동일하게 정의된다. 하지만, 유일한 차이점은 등호 부호 <code>=</code> 대신 부정 부호 <code>!</code> 문자를 사용한다는 것이다, 즉 <code>(?!...)</code>. 정규 표현식 <code>[T|t]he(?!\sfat)</code>를 살펴보도록 하자. 이 정규 표현식은 공백 문자와 <code>fat</code> 문자열이 연속으로 나오지 않는 모든 <code>The</code> 혹은 <code>the</code> 문자열과 매치된다.</p>

<pre>
"[T|t]he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Test the regular expression</a></p>

<h3 id="toc_24">4.3 긍정형 후방탐색</h3>

<p>긍정형 후방탐색는 특정 패턴뒤에 나오는 문자열 매치를 가져오기 위해서 사용된다. 긍정형 후방탐색는 <code>(?&lt;=...)</code>로 표시된다. 예를 들어, 정규 표현식 <code>(?&lt;=[T|t]he\s)(fat|mat)</code>는 입력 문자열에서 <code>The</code> 혹은 <code>the</code> 뒤에 공백이 나오고, 그 뒤에 <code>fat</code> 또는 <code>mat</code>이 나오는 패턴을 의미한다.</p>

<pre>
"(?<=[T|t]he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Test the regular expression</a></p>

<h3 id="toc_25">4.4 부정형 후방탐색</h3>

<p>부정형 후방탐색는 특정 패턴이 뒤에 나오지 않기를 바라는 상황에서 사용된다. 부정형 후방탐색는 <code>(?&lt;!...)</code>로 표시된다. 예를 들어, 정규 표현식 <code>(?&lt;!(T|t)he\s)(cat)</code>은 앞에 <code>The</code> 혹은 <code>the</code> 가 위치하지 않는 모든 <code>cat</code> 문자열을 의미한다.</p>

<pre>
"(?&lt;![T|t]he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Test the regular expression</a></p>

<h2 id="toc_26">5. 플래그</h2>

<p>플래그는 정규표현식의 출력값을 수정하기 때문에 수정자(modifier)라고도 불린다. 이러한 플래그들은 어떤 순서 혹은 조합으로 사용 가능하며 정규 표현식의 일부분이다.</p>

<table>
<thead>
<tr>
<th style="text-align: center">플래그</th>
<th>설명</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>대소문자 구분없음: 매칭이 대소문자를 구분하지 않도록 설정.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>전체 검색: 입력 문자열 전체를 대상으로 패턴을 검색.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>멀티 라인: 앵터 메타 문자가 각 줄마다 동작하도록 설정.</td>
</tr>
</tbody>
</table>

<h3 id="toc_27">5.1 대소문자 구분없음</h3>

<p>수정자 <code>i</code>는 대소문자 구분없는 매칭을 수행하는데 사용된다. 예를 들어, 정규 표현식 <code>/The/gi</code>는 대문자 <code>T</code>, 소문자 <code>h</code>, 소문자 <code>e</code>가 차례로 나오는 패턴을 의미한다. 여기서 정규 표현식 마지막에 있는 <code>i</code> 플래그가 정규 표현식 엔진에게 대소문자를 구분하지 않도록 알려준다. <code>g</code> 플래그는 전체 입력 문자열 내부에서 패턴을 검색하기 위해 설정되었다.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Test the regular expression</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Test the regular expression</a></p>

<h3 id="toc_28">5.2 전체 검색</h3>

<p>수정자 <code>g</code>는 첫번째 매칭후에 멈추지 않고 계속해서 모든 매칭을 검색하는 전체 검색을 수행하는데 사용된다. 예를 들어, 정규 표현식 <code>/.(at)/g</code>는 개행을 제외한 문자가 나오고, 그 뒤에 소문자 <code>a</code>, 소문자 <code>t</code>가 나오는 패턴을 의미한다. 여기에서 <code>g</code> 플래그를 정규 표현식의 마지막에 설정했기 때문에, 이 패턴은 입력 문자열 전체에서 나타나는 모든 패턴을 찾아낸다.</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Test the regular expression</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Test the regular expression</a></p>

<h3 id="toc_29">5.3 멀티 라인</h3>

<p>수정자 <code>m</code>은 멀티 라인 매치를 수행하는데 사용된다. 이전에 이야기 했던 것처럼, 앵커 <code>(^, $)</code>는 패턴의 시작과 끝을 확인하는데 사용된다. 하지만 만약 우리가 각 라인마다 이 앵커가 동작하게하고 싶으면 <code>m</code> 플래그를 설정하면된다. 예를 들어, 정규 표현식 <code>/at(.)?$/gm</code>은 소문자 <code>a</code>와 소문자 <code>t</code>가 차례로 나오고, 선택적으로 개행을 제외한 문자가 나오는 패턴을 의미한다. 여기서 플래그 <code>m</code>으로 인해서 정규 표현식 엔진은 입력 문자열의 각 라인에 대해서 해당 패턴을 매칭하게 된다.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Test the regular expression</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Test the regular expression</a></p>

<h2 id="toc_30">6. 탐욕적 vs 게으른 매칭</h2>

<p>기본적으로 정규 표현식은 탐욕적(greedy) 매칭을 수행하는데, 이는 가능한 한 길게 매칭하는 것을 의미한다. 우리는 <code>?</code>를 사용하여 게으른(lazy) 방법 매칭할 수 있으며, 가능한 한 짧게 매칭하는 것을 의미한다.</p>

<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. 
</pre>

<p><a href="https://regex101.com/r/AyAdgJ/1">Test the regular expression</a></p>

<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. 
</pre>

<p><a href="https://regex101.com/r/AyAdgJ/2">Test the regular expression</a></p>

<h2 id="toc_31">기여 방법</h2>

<ul>
<li>이슈 리포팅</li>
<li>코드 개선해서 풀 리퀘스트 열기</li>
<li>소문내기</li>
<li><a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> 메일로 직접 연락하기 또는 <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_32">라이센스</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629797.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">翻訳</h2>

<ul>
<li><a href="media/15998025629797/README.md">English</a></li>
<li><a href="media/15998025629797/README-es.md">Español</a></li>
<li><a href="media/15998025629797/README-fr.md">Français</a></li>
<li><a href="media/15998025629797/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629797/README-cn.md">中文版</a></li>
<li><a href="media/15998025629797/README-ja.md">日本語</a></li>
<li><a href="media/15998025629797/README-ko.md">한국어</a></li>
<li><a href="media/15998025629797/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629797/README-gr.md">Greek</a></li>
<li><a href="media/15998025629797/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629797/README-pl.md">Polish</a></li>
<li><a href="media/15998025629797/README-ru.md">Русский</a></li>
<li><a href="media/15998025629797/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629797/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">正規表現とは</h2>

<blockquote>
<p>正規表現とは文中からある文字列のパターンを見つけるために使用される文字列や記号の組み合わせのことです。</p>
</blockquote>

<p>正規表現とは対象の文字列に左から右にマッチするパターンのことを言います。<br/>
&quot;Regular expression&quot; （正規表現）という言葉は &quot;regex&quot; や &quot;regexp&quot; などと一言で言い表すことがあります。<br/>
正規表現を使うことで文字列の置換・検証・抽出などを行うことが可能です。</p>

<p>アプリケーション中において、ユーザがユーザ名を決めるときに<br/>
守るべきルールを定義したいとしましょう。<br/>
ユーザ名には文字・数字・アンダースコア・ハイフンが使用可能であるとします。<br/>
また、ユーザ名が単調にならないように文字数にも制約を設けるものとします。<br/>
この場合、次のような正規表現でユーザ名を検証することができます。</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-en.png" alt="Regular expression"><br/>
</p></p>

<p>この正規表現によって <code>john_doe, jo-hn_doe, john12_as</code> などは許容されることになります。<br/>
一方で <code>Jo</code> は大文字を含む上に短すぎるため許容されません。</p>

<h2 id="toc_2">目次</h2>

<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA-matcher">基本的な Matcher</a></li>
<li><a href="#2-%E3%83%A1%E3%82%BF%E6%96%87%E5%AD%97">メタ文字</a>
<ul>
<li><a href="#21-%E3%83%94%E3%83%AA%E3%82%AA%E3%83%89">ピリオド</a></li>
<li><a href="#22-%E6%96%87%E5%AD%97%E9%9B%86%E5%90%88">文字集合</a></li>
<li><a href="#221-%E5%90%A6%E5%AE%9A%E6%96%87%E5%AD%97%E9%9B%86%E5%90%88">否定文字集合</a></li>
<li><a href="#23-%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97">繰り返し</a></li>
<li><a href="#231-%E3%82%A2%E3%82%B9%E3%82%BF%E3%83%AA%E3%82%B9%E3%82%AF">アスタリスク</a></li>
<li><a href="#232-%E3%83%97%E3%83%A9%E3%82%B9%E8%A8%98%E5%8F%B7">プラス記号</a></li>
<li><a href="#233-%E7%96%91%E5%95%8F%E7%AC%A6">疑問符</a></li>
<li><a href="#24-%E6%8B%AC%E5%BC%A7">括弧</a></li>
<li><a href="#25-%E6%96%87%E5%AD%97%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97">文字グループ</a></li>
<li><a href="#26-%E9%81%B8%E8%A8%80">選言</a></li>
<li><a href="#27-%E7%89%B9%E6%AE%8A%E6%96%87%E5%AD%97%E3%82%92%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%81%99%E3%82%8B">特殊文字をエスケープする</a></li>
<li><a href="#28-%E3%82%A2%E3%83%B3%E3%82%AB%E3%83%BC">アンカー</a></li>
<li><a href="#281-%E3%82%AD%E3%83%A3%E3%83%AC%E3%83%83%E3%83%88">キャレット</a></li>
<li><a href="#282-%E3%83%89%E3%83%AB%E8%A8%98%E5%8F%B7">ドル記号</a></li>
</ul></li>
<li><a href="#3-%E6%96%87%E5%AD%97%E9%9B%86%E5%90%88%E3%81%AE%E7%9F%AD%E7%B8%AE%E8%A1%A8%E8%A8%98">文字集合の短縮表記</a></li>
<li><a href="#4-%E5%89%8D%E5%BE%8C%E5%8F%82%E7%85%A7">前後参照</a>
<ul>
<li><a href="#41-%E8%82%AF%E5%AE%9A%E7%9A%84%E3%81%AA%E5%85%88%E8%AA%AD%E3%81%BF">肯定的な先読み</a></li>
<li><a href="#42-%E5%90%A6%E5%AE%9A%E7%9A%84%E3%81%AA%E5%85%88%E8%AA%AD%E3%81%BF">否定的な先読み</a></li>
<li><a href="#43-%E8%82%AF%E5%AE%9A%E7%9A%84%E3%81%AA%E5%BE%8C%E8%AA%AD%E3%81%BF">肯定的な後読み</a></li>
<li><a href="#44-%E5%90%A6%E5%AE%9A%E7%9A%84%E3%81%AA%E5%BE%8C%E8%AA%AD%E3%81%BF">否定的な後読み</a></li>
</ul></li>
<li><a href="#5-%E3%83%95%E3%83%A9%E3%82%B0">フラグ</a>
<ul>
<li><a href="#51-%E5%A4%A7%E6%96%87%E5%AD%97%E3%83%BB%E5%B0%8F%E6%96%87%E5%AD%97%E3%82%92%E5%8C%BA%E5%88%A5%E3%81%97%E3%81%AA%E3%81%84">大文字・小文字を区別しない</a></li>
<li><a href="#52-%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E6%A4%9C%E7%B4%A2">グローバル検索</a></li>
<li><a href="#53-%E8%A4%87%E6%95%B0%E8%A1%8C">複数行</a></li>
</ul></li>
<li><a href="#%E3%81%8A%E3%81%BE%E3%81%91">おまけ</a></li>
</ul>

<h2 id="toc_3">1. 基本的な Matcher</h2>

<p>文中から特定の文字列を検索する時の正規表現は単なる文字の並びとして表されます。<br/>
例えば <code>the</code> という正規表現は <code>t</code> という文字のあとに <code>h</code> が続き、さらに <code>e</code> が続くものだと<br/>
解釈されます。</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">正規表現の動作確認をする</a></p>

<p><code>123</code> という正規表現は <code>123</code> という文字列にマッチします。<br/>
正規表現は正規表現の文字列と入力文字列を1文字ずつ比較しながらマッチングを行います。<br/>
また大文字と小文字は区別されるため、 <code>The</code> は <code>the</code> にはマッチしません。</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">正規表現の動作確認をする</a></p>

<h2 id="toc_4">2. メタ文字</h2>

<p>メタ文字は正規表現の構成要素として使用される文字のことです。<br/>
メタ文字はそれ自身が示す文字を表すものではなく、特別な解釈がなされます。<br/>
一部のメタ文字は角括弧内に記述されることで特別な意味を持つものもあります。<br/>
メタ文字には次のようなものがあります。</p>

<table>
<thead>
<tr>
<th style="text-align: center">メタ文字</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>ピリオド。改行を除く任意の1文字にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>文字集合。角括弧内の任意の文字にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>否定文字集合。角括弧内に含まれない任意の文字にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>直前の文字の 0 個以上の並びにマッチ。</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>直前の文字の 1 個以上の並びにマッチ。</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>直前の文字がオプションであるとみなす。</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>括弧でくくる。直前の文字が n 個以上 m 個以下続く場合にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>文字グループ。 xyz という文字列がその順に現れる場合にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>選言。記号の前後の文字列どちらかにマッチ。</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>次に来る文字をエスケープする。予約語 <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code> にマッチ。</td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>入力値の開始にマッチする。</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>入力値の終了にマッチする。</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 ピリオド</h2>

<p>ピリオド <code>.</code> は最もシンプルなメタ文字の例です。<br/>
メタ文字 <code>.</code> は任意の 1 文字にマッチします。<br/>
キャリッジリターンと改行にはマッチしません。<br/>
例えば <code>.ar</code> は任意の文字の後に <code>a</code> と <code>r</code> が続く文字列にマッチします。</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">正規表現の動作確認をする</a></p>

<h2 id="toc_6">2.2 文字集合</h2>

<p>文字集合は文字クラスとも呼ばれます。<br/>
文字集合を指定するには角括弧でくくります。<br/>
文字の範囲を指定するにはハイフンを使用します。<br/>
角括弧内の文字の記述順はマッチングには関係ありません。<br/>
例えば <code>[Tt]he</code> という正規表現は大文字 <code>T</code> または小文字 <code>t</code> の後に <code>h</code>, <code>e</code> が続く文字列を表します。</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">正規表現の動作確認をする</a></p>

<p>文字集合内でのピリオドは文字としてのピリオドを表します。<br/>
<code>ar[.]</code> という正規表現は <code>a</code> という文字のあとに <code>r</code> が続き、さらに <code>.</code> という文字が続く文字列を表します。</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">正規表現の動作確認をする</a></p>

<h3 id="toc_7">2.2.1 否定文字集合</h3>

<p>通常キャレットは文字列の開始を意味するメタ文字ですが、角括弧内で最初に使用されると<br/>
文字集合を否定する意味を持つようになります。<br/>
例えば <code>[^c]ar</code> という正規表現は <code>c</code> 以外の任意の文字列の後に<br/>
<code>a</code>, <code>r</code> が続く文字列を表します。</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">正規表現の動作確認をする</a></p>

<h2 id="toc_8">2.3 繰り返し</h2>

<p><code>+</code>, <code>*</code>, <code>?</code> はパターンが何回続くのかを指定するためのメタ文字になります。<br/>
これらのメタ文字は異なるシチュエーションで異なる振る舞いをします。</p>

<h3 id="toc_9">2.3.1 アスタリスク</h3>

<p>シンボル <code>*</code> は直前の文字が 0 個以上続くパターンにマッチします。<br/>
<code>a*</code> という正規表現は小文字の <code>a</code> が 0 個以上続くことを意味します。<br/>
しかし文字集合またはクラスの後に現れた場合はその文字集合すべてが続くことを意味します。<br/>
例えば <code>[a-z]*</code> という正規表現は行内の任意の小文字の列を表します。</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">正規表現の動作確認をする</a></p>

<p>シンボル <code>*</code> はメタ文字 <code>.</code> と合わせて <code>.*</code> のように使用することで<br/>
任意の文字列を表現できます。<br/>
またスペースを表す <code>\s</code> と併用することで空白文字を表現できます。<br/>
例えば <code>\s*cat\s*</code> という正規表現は 0 個以上のスペースの後に<br/>
小文字の <code>c</code>, <code>a</code>, <code>t</code> が続き、その後に 0 個以上のスペースが続きます。</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">正規表現の動作確認をする</a></p>

<h3 id="toc_10">2.3.2 プラス記号</h3>

<p>シンボル <code>+</code> は直前の文字が 1 個以上続くパターンにマッチします。<br/>
例えば <code>c.+t</code> という正規表現は小文字の <code>c</code> の後に<br/>
任意の 1 文字以上が続き、さらに <code>t</code> が続くことを意味します。<br/>
この <code>t</code> は、その文における最後の <code>t</code> がマッチします。</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">正規表現の動作確認をする</a></p>

<h3 id="toc_11">2.3.3 疑問符</h3>

<p>正規表現におけるメタ文字 <code>?</code> は直前の文字がオプションであることを意味します。<br/>
すなわち直前の文字が 0 個または 1 個現れることを意味します。<br/>
例えば <code>[T]?he</code> という正規表現は大文字の <code>T</code> が 0 個または 1 個出現し、<br/>
その後に小文字の <code>h</code>, <code>e</code> が続くことを意味します。</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">正規表現の動作確認をする</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">正規表現の動作確認をする</a></p>

<h2 id="toc_12">2.4 括弧</h2>

<p>この<code>t</code>は、その文における最後の<code>t</code>であることが明確である必要があります。</p>

<p>正規表現における括弧は数量子とも呼ばれますが、文字列がいくつ現れるかを示すために使用されます。<br/>
例えば、<code>[0-9]{2,3}</code> という正規表現は 2 桁以上 3 桁以下の数字<br/>
（0 から 9 の数字で表された文字列）にマッチします。</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">正規表現の動作確認をする</a></p>

<p>2つ目の数値は省略できます。<br/>
例えば <code>[0-9]{2,}</code> という正規表現は 2 桁以上の数字を意味します。<br/>
カンマも省略することができ、その場合 <code>[0-9]{3}</code> という正規表現はちょうど 3 桁の数字を意味します。</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">正規表現の動作確認をする</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">正規表現の動作確認をする</a></p>

<h2 id="toc_13">2.5 文字グループ</h2>

<p>文字グループは括弧 <code>(...)</code> 内にパターンを記述してグループ分けをするために使用します。<br/>
前述の通り、正規表現においては数量子を文字の後に置いた場合は<br/>
その直前の文字の繰り返しを意味します。しかし、文字グループの後に数量子を置いた場合は<br/>
文字グループ全体が繰り返すことを意味します。<br/>
例えば、 <code>(ab)*</code> という正規表現は &quot;ab&quot; という文字列の 0 個以上の繰り返しにマッチします。<br/>
文字グループ内では選言 <code>|</code> も使用することができます。<br/>
例えば、<code>(c|g|p)ar</code> という正規表現は小文字の <code>c</code>, <code>g</code>, <code>p</code> のいずれかの後に<br/>
<code>a</code> が続き、さらに <code>r</code> が続くことを意味します。</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">正規表現の動作確認をする</a></p>

<h2 id="toc_14">2.6 選言</h2>

<p>正規表現における縦棒 <code>|</code> は選言として使用されます。<br/>
選言は複数の正規表現からなる条件式のようなものです。<br/>
もしかすると文字集合と選言が同じものと感じるかもしれません。<br/>
この 2 つの大きな違いは文字集合は文字単位で評価されるのに対して選言は正規表現単位で評価されます。<br/>
例えば <code>(T|t)he|car</code> という正規表現は大文字の <code>T</code> または小文字の <code>t</code> の後に<br/>
小文字の <code>h</code>, <code>e</code> が続くか、または小文字の <code>c</code> の後に <code>a</code>, <code>r</code> が続くことを意味します。</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">正規表現の動作確認をする</a></p>

<h2 id="toc_15">2.7 特殊文字をエスケープする</h2>

<p>バックスラッシュ <code>\</code> は正規表現内で次に来る文字をエスケープするために使用されます。<br/>
これを使うと予約語 <code>{ } [ ] / \ + * . $ ^ | ?</code> を<br/>
記号として指定できるようになります。<br/>
例えば <code>.</code> という正規表現は改行を除く任意の文字として使用されますが、<br/>
<code>(f|c|m)at\.?</code> という正規表現では <code>.</code> 自体にマッチします。<br/>
この正規表現は小文字の <code>f</code>, <code>c</code> または <code>m</code> の後に小文字の <code>a</code>, <code>t</code> が続き、<br/>
さらに <code>.</code> が 0 個または 1 個続きます。</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">正規表現の動作確認をする</a></p>

<h2 id="toc_16">2.8 アンカー</h2>

<p>正規表現内でマッチング文字列の開始または終了であることをチェックするために<br/>
アンカーを使うことができます。<br/>
アンカーには 2 種類あり、1 つ目が開始を表すキャレット <code>^</code>、<br/>
2 つ目が終了を表すドル記号 <code>$</code> です。</p>

<h3 id="toc_17">2.8.1 キャレット</h3>

<p>キャレット <code>^</code> は文字列の開始かどうかを調べるために使用します。<br/>
次の正規表現 <code>^a</code> は入力文字列 <code>abc</code> に対して（a が開始文字列なら）<code>a</code> にマッチします。<br/>
しかし <code>^b</code> という正規表現は前の文字列に対してはどれにもマッチしません。<br/>
&quot;b&quot; は <code>abc</code> という入力文字列の開始ではないからです。<br/>
他の例を見てみます。<code>^(T|t)he</code> は大文字の <code>T</code> または小文字の <code>t</code> から始まる文字列で<br/>
その後に小文字の <code>h</code>, <code>e</code> が続くことを意味します。</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">正規表現の動作確認をする</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">正規表現の動作確認をする</a></p>

<h3 id="toc_18">2.8.2 ドル記号</h3>

<p>ドル記号 <code>$</code> は文字列の終了かどうかを調べるために使用します。<br/>
例えば <code>(at\.)$</code> という正規表現は小文字の <code>a</code> の後に<br/>
小文字の <code>t</code> が続き、最後は <code>.</code> で終わることを意味しています。</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">正規表現の動作確認をする</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">正規表現の動作確認をする</a></p>

<h2 id="toc_19">3. 文字集合の短縮表記</h2>

<p>正規表現ではよく使われる文字集合に対して短縮表記が提供されており、<br/>
便利なショートカットとして使用できます。<br/>
短縮表記には次のようなものがあります。</p>

<table>
<thead>
<tr>
<th style="text-align: center">短縮表記</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>改行を除く任意の文字</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>英数字にマッチ: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>英数字以外にマッチ: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>数字にマッチ: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>数字以外にマッチ: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>スペースにマッチ: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>スペース以外にマッチ: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. 前後参照</h2>

<p>先読みと後読み（前後参照とも呼ばれます）は <strong>非キャプチャグループ</strong><br/>
（パターンのマッチングはするがマッチングリストには含まれない）という<br/>
特殊な扱いがなされる機能です。<br/>
前後参照はあるパターンが別のあるパターンよりも先行または後続して現れることを示すために使用されます。<br/>
例えば入力文字列 <code>$4.44 and $10.88</code> に対して <code>$</code> に続く全ての数字を取得することを考えます。<br/>
そのためには <code>(?&lt;=\$)[0-9\.]*</code> という正規表現を使用します。<br/>
これは <code>$</code> に続き <code>.</code> を含む全ての数字を指すことになります。<br/>
次のような前後参照が正規表現で使用されます。</p>

<table>
<thead>
<tr>
<th style="text-align: center">記号</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>肯定的な先読み</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>否定的な先読み</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>肯定的な後読み</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>否定的な後読み</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 肯定的な先読み</h3>

<p>肯定的な先読みはあるパターンが注目しているパターンよりも後続していることを示すための機能です。<br/>
マッチングの結果には注目しているパターンだけが含まれます。<br/>
肯定的な先読みを定義するには括弧を使用します。<br/>
その括弧の中で疑問符と等号を合わせて <code>(?=...)</code> のようにします。<br/>
先読みのパターンは括弧の中の等号の後に記述します。<br/>
例えば <code>(T|t)he(?=\sfat)</code> という正規表現は小文字の <code>t</code> か大文字の <code>T</code> のどちらかの後に <code>h</code>, <code>e</code> が続きます。<br/>
括弧内で肯定的な先読みを定義していますが、これは <code>The</code> または <code>the</code> の後に<br/>
<code>fat</code> が続くことを表しています。</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">正規表現の動作確認をする</a></p>

<h3 id="toc_22">4.2 否定的な先読み</h3>

<p>否定的な先読みはあるパターンが後続しない全てのマッチング文字列を取得するために使用します。<br/>
否定的な先読みは肯定的な先読みと同じように定義しますが、 <code>=</code> の代わりに<br/>
<code>!</code> を使うところが唯一の違いで、<code>(?!...)</code> と記述します。<br/>
次の正規表現 <code>(T|t)he(?!\sfat)</code> について考えてみます。<br/>
これはスペースを挟んで <code>fat</code> が後続することがない全ての <code>The</code> または <code>the</code> を得ることができます。</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">正規表現の動作確認をする</a></p>

<h3 id="toc_23">4.3 肯定的な後読み</h3>

<p>肯定的な後読みは特定のパターンが先行するような文字列を得るために使用します。<br/>
定義の仕方は <code>(?&lt;=...)</code> とします。<br/>
例えば <code>(?&lt;=(T|t)he\s)(fat|mat)</code> という正規表現は<br/>
<code>The</code> または <code>the</code> の後に続く全ての <code>fat</code> または <code>mat</code> が取得できます。</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">正規表現の動作確認をする</a></p>

<h3 id="toc_24">4.4 否定的な後読み</h3>

<p>否定的な後読みは特定のパターンが先行しない全ての文字列を得るために使用します。<br/>
定義の仕方は <code>(?&lt;!...&gt;)</code> とします。<br/>
例えば <code>(?&lt;!(T|t)he\s)(cat)</code> は <code>The</code> または <code>the</code> に続いていない全ての <code>cat</code> が取得できます。</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">正規表現の動作確認をする</a></p>

<h2 id="toc_25">5. フラグ</h2>

<p>フラグは修飾子とも呼ばれ、正規表現の結果を修正するために使用されます。<br/>
フラグは任意の順序・組み合わせで使用でき、正規表現では必要不可欠な機能です。</p>

<table>
<thead>
<tr>
<th style="text-align: center">フラグ</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>大文字・小文字を区別しない: マッチングで大文字・小文字が区別されなくなる</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>グローバル検索: 入力文字列の全マッチ列を検索する</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>複数行: 複数行をマッチさせるためのアンカー</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 大文字・小文字を区別しない</h3>

<p>修飾子 <code>i</code> は大文字・小文字を区別したくないときに使用します。<br/>
例えば <code>/The/gi</code> という正規表現は大文字の <code>T</code> の後に小文字の <code>h</code>, <code>e</code> が続くという意味ですが、<br/>
最後の <code>i</code> で大文字・小文字を区別しない設定にしています。<br/>
文字列内の全マッチ列を検索したいのでフラグ <code>g</code> も渡しています。</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">正規表現の動作確認をする</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">正規表現の動作確認をする</a></p>

<h3 id="toc_27">5.2 グローバル検索</h3>

<p>修飾子 <code>g</code> はグローバル検索（最初のマッチ列を検索する代わりに全マッチ列を検索する）を<br/>
行うために使用します。<br/>
例えば <code>/.(at)/g</code> という正規表現は、改行を除く任意の文字列の後に<br/>
小文字の <code>a</code>, <code>t</code> が続きます。正規表現の最後にフラグ <code>g</code> を渡すことで、<br/>
最初のマッチだけではなく（これがデフォルトの動作です）、入力文字列内の全マッチ列を検索するようにしています。</p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">正規表現の動作確認をする</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">正規表現の動作確認をする</a></p>

<h3 id="toc_28">5.3 複数行</h3>

<p>修飾子 <code>m</code> は複数行でマッチさせたいときに使用します。<br/>
前述で <code>(^, $)</code> という入力文字列の開始と終了を示すためのアンカーについて説明しましたが、<br/>
フラグ <code>m</code> は複数行でマッチさせるためのアンカーとして使用できます。<br/>
例えば <code>/at(.)?$/gm</code> という正規表現は小文字の <code>a</code>, <code>t</code> に続き、改行を除く<br/>
任意の文字が 0 個または 1 個続くという意味ですが、<br/>
フラグ <code>m</code> を渡すことで入力文字列の各行でパターンを検索させることができます。</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">正規表現の動作確認をする</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">正規表現の動作確認をする</a></p>

<h2 id="toc_29">貢献する</h2>

<ul>
<li>イシューを発行する</li>
<li>修正をプルリクエストする</li>
<li>ドキュメントを普及させる</li>
<li>作者に直接連絡を取る: <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> または <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">ライセンス</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629883.html">
                
                  <h1><p align="center"></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-text">&lt;br/&gt;
&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/bYwl7Vf.png&quot; alt=&quot;Learn Regex&quot;&gt;
&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt;
    &lt;a href=&quot;https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square&quot;/&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://twitter.com/ziishaned&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;
</code></pre>
</p>
<h2 id="toc_0">Fordítások:</h2>

<ul>
<li><a href="media/15998025629883/README.md">English</a></li>
<li><a href="media/15998025629883/README-es.md">Español</a></li>
<li><a href="media/15998025629883/README-fr.md">Français</a></li>
<li><a href="media/15998025629883/README-pt_BR.md">Português do Brasil</a></li>
<li><a href="media/15998025629883/README-cn.md">中文版</a></li>
<li><a href="media/15998025629883/README-ja.md">日本語</a></li>
<li><a href="media/15998025629883/README-ko.md">한국어</a></li>
<li><a href="media/15998025629883/README-tr.md">Turkish</a></li>
<li><a href="media/15998025629883/README-gr.md">Greek</a></li>
<li><a href="media/15998025629883/README-hu.md">Magyar</a></li>
<li><a href="media/15998025629883/README-pl.md">Polish</a></li>
<li><a href="media/15998025629883/README-ru.md">Русский</a></li>
<li><a href="media/15998025629883/README-vn.md">Tiếng Việt</a></li>
<li><a href="media/15998025629883/README-fa.md">فارسی</a></li>
</ul>

<h2 id="toc_1">Mi az a reguláris kifejezés?</h2>

<blockquote>
<p>A reguláris kifejezés karakterek vagy szimbólumok egy csoportja, amelyet egy szövegből adott minták megtalálására használnak.</p>
</blockquote>

<p>A reguláris kifejezés egy olyan minta, amely illeszkedik egy adott karakterláncra<br/>
balról jobbra. Magát a &quot;Regular expression&quot; kifejezést általában rövidítve lehet<br/>
megtalálni, mint &quot;regex&quot; vagy &quot;regexp&quot;. A reguláris kifejezést használják szövegrészek<br/>
lecserélésére egy szövegben, űrlapok validálására, szövegrészek kiválasztására<br/>
mintaegyezés alapján egy hosszabb szövegből és így tovább.</p>

<p>Képzeld el, hogy egy alkalmazást írsz és szeretnél szabályokat állítani a felhasználónév<br/>
kiválasztásához. A felhasználónév csak betűket, számokat, aláhúzásjelet és kötőjelet<br/>
tartalmazhat. Szeretnénk limitálni a karakterek maximális számát is a felhasználónévben,<br/>
hogy ne legyen csúnya. A felhasználónév validálására a következő reguláris kifejezést<br/>
használjuk:</p>

<p><br/><br/><br/>
<p align="center"><br/>
  <img src="../img/regexp-hu.png" alt="Regular expression"><br/>
</p></p>

<p>A feljebbi reguláris kifejezés elfogadja a <code>john_doe</code>, <code>jo-hn_doe</code> és a<br/>
<code>john12_as</code> karakterláncokat. Nem fog egyezni a <code>Jo</code>-ra mert ez nagybetűt<br/>
tartalmaz és túl rövid is.</p>

<h2 id="toc_2">Tartalomjegyzék</h2>

<ul>
<li><a href="#1-bevezet%C3%A9s">Bevezetés</a></li>
<li><a href="#2-meta-karakterek">Meta karakterek</a>
<ul>
<li><a href="#21-full-stop">Full stop</a></li>
<li><a href="#22-karakter-oszt%C3%A1lyok">Karakter osztályok</a></li>
<li><a href="#221-neg%C3%A1lt-karakter-oszt%C3%A1lyok">Negált karakter osztályok</a></li>
<li><a href="#23-ism%C3%A9tl%C3%A9sek">Ismétlések</a></li>
<li><a href="#231-a-csillag">A csillag</a></li>
<li><a href="#232-a-plusz">A plusz</a></li>
<li><a href="#233-a-k%C3%A9rd%C5%91jel">A kérdőjel</a></li>
<li><a href="#24-a-kapcsos-z%C3%A1r%C3%B3jelek">A kapcsos zárójelek</a></li>
<li><a href="#25-karakter-csoportok">Karakter csoportok</a></li>
<li><a href="#26-altern%C3%A1l%C3%A1s">Alternálás</a></li>
<li><a href="#27-speci%C3%A1lis-karakter-escape-el%C3%A9se">Speciális karakter escape-elése</a></li>
<li><a href="#28-horgonyok">Horgonyok</a></li>
<li><a href="#281-kalap">Kalap</a></li>
<li><a href="#282-doll%C3%A1r">Dollár</a></li>
</ul></li>
<li><a href="#3-shorthand-karakter-oszt%C3%A1lyok">Shorthand Karakter osztályok</a></li>
<li><a href="#4-lookaround">Lookaround</a>
<ul>
<li><a href="#41-positive-lookahead">Positive Lookahead</a></li>
<li><a href="#42-negative-lookahead">Negative Lookahead</a></li>
<li><a href="#43-positive-lookbehind">Positive Lookbehind</a></li>
<li><a href="#44-negative-lookbehind">Negative Lookbehind</a></li>
</ul></li>
<li><a href="#5-flag-ek">Flag-ek</a>
<ul>
<li><a href="#51-kis-nagybet%C5%B1-%C3%A9rz%C3%A9ketlen">Kis-nagybetű érzéketlen</a></li>
<li><a href="#52-glob%C3%A1lis-keres%C3%A9s">Globális keresés</a></li>
<li><a href="#53-t%C3%B6bbsoros">Többsoros</a></li>
</ul></li>
</ul>

<h2 id="toc_3">1. Bevezetés</h2>

<p>A reguláris kifejezés egy karakterminta, amit keresésre használunk egy<br/>
szövegben. Például a <code>the</code> reguláris kifejezés a következőt jelenti: egy <code>t</code> betű,<br/>
amit <code>h</code> követ, amit egy <code>e</code> követ.</p>

<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Teszteld a reguláris kifejezést</a></p>

<p>Az <code>123</code> reguláris kifejezés illeszkedik a <code>123</code> karakterláncra. A reguláris kifejezés<br/>
minden egyes karaktere össze lesz hasonlítva a bevitt karakterlánc minden elemével<br/>
egymás után. A reguláris kifejezések alap esetben kis-nagybetű érzékenyek, tehát a<br/>
<code>The</code> reguláris kifejezés nem fog illeszkedni a <code>the</code> karakterláncra.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_4">2. Meta karakterek</h2>

<p>A meta karakterek a reguláris kifejezések építőkockái. A meta karakterek speciális<br/>
módon értelmezendőek. Némelyik meta karakternek speciális jelentése van és<br/>
szögletes zárójelek közé vannak téve. A meta karakterek a következők:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Meta karakter</th>
<th>Leírás</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>A pont illeszkedik minden egyes karakterre kivéve a sortörést.</td>
</tr>
<tr>
<td style="text-align: center">[ ]</td>
<td>Karakter osztály. Minden karakterre illeszkedik ami a szögletes zárójelek közt van.</td>
</tr>
<tr>
<td style="text-align: center">[^ ]</td>
<td>Negált karakter osztály. Minden karakterre illeszkedik ami nincs a szögletes zárójelek közt.</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td>Illeszkedik az őt megelőző szimbólum 0 vagy több ismétlődésére.</td>
</tr>
<tr>
<td style="text-align: center">+</td>
<td>Illeszkedik az őt megelőző szimbólum 1 vagy több ismétlődésére.</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td>Opcionálissá teszi az őt megelőző szimbólumot.</td>
</tr>
<tr>
<td style="text-align: center">{n,m}</td>
<td>Kapcsos zárójelek. Illeszkedik az őt megelőző szimbólum minimum &quot;n&quot; de nem több mint &quot;m&quot; ismétlődésére.</td>
</tr>
<tr>
<td style="text-align: center">(xyz)</td>
<td>Karakter csoport. Illeszkedik az xyz karakterekre pontosan ilyen sorrendben.</td>
</tr>
<tr>
<td style="text-align: center">&#124;</td>
<td>Alternáció. Illeszkedik a szimbólum előtt és után álló karakterekre is.</td>
</tr>
<tr>
<td style="text-align: center">&#92;</td>
<td>Escape-li a következő karaktert. A segítségével lefoglalt karakterekre is lehet illeszkedni <code><a href=""> </a> { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align: center">^</td>
<td>A karakterlánc elejére illeszkedik.</td>
</tr>
<tr>
<td style="text-align: center">$</td>
<td>A karakterlánc végére illeszkedik.</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.1 Full stop</h2>

<p>A full stop <code>.</code> a legegyszerűbb meta karakter példa. A <code>.</code> meta karakter illeszkedik<br/>
minden egyes karakterre. Nem fog illeszkedni a kocsi vissza és a sortörés karakterekre.<br/>
Például a <code>.ar</code> reguláris kifejezés jelentése: minden karakter, amit <code>a</code> aztán <code>r</code> követ.</p>

<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_6">2.2 Karakter osztályok</h2>

<p>A szögletes zárójelekkel határozzuk meg a karakter osztályokat. A szögletes<br/>
zárójelek közt kötőjel karakterrel határozhatunk meg karakter tartományokat.<br/>
A karaktertartomány sorrendje nem számít. Például a <code>[Tt]he</code> reguláris kifejezés<br/>
jelentése: nagybetűs <code>T</code> vagy kisbetűs <code>t</code> amit egy <code>h</code> majd egy <code>e</code> betű követ.</p>

<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Teszteld a reguláris kifejezést</a></p>

<p>Egy pont a karakter osztályon belül egyébként szó szerint pont-ot jelent. A<br/>
<code>ar[.]</code> reguláris kifejezés jelentése: kisbetűs <code>a</code> amit egy <code>r</code> aztán egy<br/>
pont <code>.</code> karakter követ.</p>

<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_7">2.2.1 Negált karakter osztályok</h3>

<p>Általában a kalap szimbólum egy karakterlánc elejét jelenti, de ha egy nyitó<br/>
szögletes zárójel után áll, akkor negálja a karakter osztályt. Például a <br/>
<code>[^c]ar</code> reguláris kifejezés jelentése: minden karakter a <code>c</code> kivételével<br/>
ami után <code>a</code> aztán egy <code>r</code> betű áll.</p>

<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_8">2.3 Ismétlések</h2>

<p>A következő meta karaktereket <code>+</code>, <code>*</code> vagy <code>?</code> arra használjuk, hogy meghatározzuk,<br/>
hányszor fordulhat elő az al-minta. Ezek a meta karakterek máshogy viselkednek<br/>
adott helyzetekben.</p>

<h3 id="toc_9">2.3.1 A csillag</h3>

<p>A <code>*</code> szimbólum az őt megelőző karakter nulla vagy több ismétlődésére illeszkedik.<br/>
A <code>a*</code> reguláris kifejezés jelentése: nulla vagy több ismétlődése az őt megelőző <code>a</code><br/>
karakternek. De ha egy karakter osztály után áll akkor az egész karakterosztály<br/>
ismétlődését keresi. Például, a <code>[a-z]*</code> reguláris kifejezés jelentése: bármennyi<br/>
kisbetűs betű egy sorban.</p>

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Teszteld a reguláris kifejezést</a></p>

<p>A <code>*</code> szimbólum használható a <code>.</code> meta karakterrel <code>.*</code>, ez illeszkedik<br/>
bármilyen karakterláncra. A <code>*</code> szimbólum használható a whitespace karakterrel <code>\s</code><br/>
együtt, hogy illeszkedjen egy whitespace-ekből álló karakterláncra. Például a<br/>
<code>\s*cat\s*</code>kifejezés jelentése: nulla vagy több szóköz, amit egy kisbetűs <code>c</code>,<br/>
aztán egy kisbetűs <code>a</code>, aztán egy kisbetűs <code>t</code>, amit még nulla vagy több szóköz követ.</p>

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_10">2.3.2 A plusz</h3>

<p>A <code>+</code> szimbólum illeszkedik az őt megelőző karakter egy vagy több ismétlődésére.<br/>
Például a <code>c.+t</code> kifejezés jelentése: kisbetűs <code>c</code> betű, amit legalább egy vagy<br/>
több <code>t</code> követ. Itt tisztázni kell hogy a <code>t</code> az utolsó <code>t</code> a mondatban.</p>

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_11">2.3.3 A kérdőjel</h3>

<p>A reguláris kifejezésben a <code>?</code> meta karakter opcionálissá teszi az őt<br/>
megelőző karaktert. Ez a szimbólum az őt megelőző karakter nulla vagy egy<br/>
példányára illeszkedik. Például a <code>[T]?he</code> kifejezés jelentése: opcionális a<br/>
nagybetűs <code>T</code>, amit egy kisbetűs <code>h</code>, majd egy kisbetűs <code>e</code> követ.</p>

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_12">2.4 A kapcsos zárójelek</h2>

<p>A reguláris kifejezésben a kapcsos zárójeleket annak meghatározására használjuk,<br/>
hogy egy karakter vagy egy karakter csoport hányszor ismétlődhet. Például a<br/>
<code>[0-9]{2,3}</code> kifejezés jelentése: minimum 2 de nem több mint 3 karakter a <code>[0-9]</code><br/>
karaktertartományon belül.</p>

<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Teszteld a reguláris kifejezést</a></p>

<p>Kihagyhatjuk a második számot. Például a <code>[0-9]{2,}</code> kifejezés jelentése:<br/>
2 vagy több számra illeszkedik. Ha a vesszőt is kitöröljük <code>[0-9]{3}</code>: Pontosan<br/>
3 számra illeszkedik.</p>

<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_13">2.5 Karakter csoportok</h2>

<p>A karakter csoport al-minták csoportja amik zárójelek közé <code>(...)</code> vannak írva.<br/>
Ahogy előbb már megbeszéltük, ha egy karakter után ismétlő karaktert rakunk, az<br/>
ismételni fogja az előtte lévő karaktert. De ha egy ismétlő karaktert egy karakter<br/>
csoport után rakunk, az ismételni fogja az egész csoportot. Például a <code>(ab)*</code><br/>
kifejezés illeszkedik nulla vagy több ismétlődésére az <code>ab</code> karaktereknek.<br/>
Használhatunk alternáló meta karaktert <code>|</code> is a csoporton belül. Például a <code>(c|g|p)ar</code><br/>
kifejezés jelentése: kisbetűs <code>c</code>, <code>g</code> vagy <code>p</code> karakter, amit egy <code>a</code> aztán<br/>
egy <code>r</code> karakter követ.</p>

<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_14">2.6 Alternálás</h2>

<p>A reguláris kifejezésben a függőleges vonalat <code>|</code> alternálásra (választásra)<br/>
használjuk. Az alternálás olyan, mint egy feltétel több kifejezés közt. Most<br/>
azt gondolhatod, hogy a karakter osztály és az alternáció ugyan úgy működik.<br/>
De a fő különbség köztük, hogy a karakter osztály a karakterek szintjén működik,<br/>
az alternáció viszont a kifejezés szintjén. Például a <code>(T|t)he|car</code> kifejezés<br/>
jelentése: nagybetűs <code>T</code> karakter vagy kisbetűs <code>t</code> karakter, amit egy <code>h</code> és<br/>
egy <code>e</code> követ, VAGY kisbetűs <code>c</code> aztán <code>a</code> aztán <code>r</code> karakter.</p>

<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_15">2.7 Speciális karakter escape-elése</h2>

<p>A visszaper <code>\</code> a reguláris kifejezésekben a következő karakter escape-elésére<br/>
való. Ez enged nekünk szimbólumokat vagy lefoglalt karaktereket <code>{ } [ ] / \ + * . $ ^ | ?</code><br/>
megadni. Egy speciális karakter egyező karakterként való megadásához tedd elé<br/>
a <code>\</code> karaktert.</p>

<p>Például a <code>.</code> kifejezést az összes karakter, kivéve a sortörés illeszkedéséhez<br/>
használjuk. A <code>(f|c|m)at\.?</code> kifejezés jelentése: kisbetűs <code>f</code>, <code>c</code> vagy <code>m</code>, amit<br/>
egy kisbetűs <code>a</code> aztán egy kisbetűs <code>t</code>, amit egy opcionális <code>.</code> karakter követ.</p>

<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_16">2.8 Horgonyok</h2>

<p>A reguláris kifejezésekben horgonyokat használunk, hogy megnézzük, az illeszkedő<br/>
szimbólum a kezdő vagy a záró szimbóluma-e a karakterláncnak. A horgonyoknak két<br/>
fajtájuk van: Az első a Kalap <code>^</code>, ami megnézi, hogy az egyező karakter a karakterlánc<br/>
kezdő kerektere-e és a második a Dollár <code>$</code>, ami azt vizsgálja, hogy az egyező<br/>
karakter a karakterlánc utolsó karaktere-e.</p>

<h3 id="toc_17">2.8.1 Kalap</h3>

<p>A kalap <code>^</code> szimbólumot arra használjuk, hogy megnézzük, hogy az egyező karakter<br/>
a karakterlánc kezdő kerektere-e. Ha megadjuk a következő kifejezést: <code>^a</code>,<br/>
akkor illeszkedik a <code>abc</code> karakterlánc <code>a</code> karakterére, mert az za első. De ha<br/>
megadjuk, hogy: <code>^b</code>, ez nem fog illeszkedni az <code>abc</code> egyik részére sem, mert<br/>
nem <code>b</code> a kezdő karakter. Nézzünk meg egy másik kifejezést. <code>^(T|t)he</code> jelentése:<br/>
nagybetűs <code>T</code> vagy kisbetűs <code>t</code> a kezdő karaktere a karakterláncnak, amit kisbetűs<br/>
<code>h</code>, majd kisbetűs <code>e</code> követ.</p>

<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_18">2.8.2 Dollár</h3>

<p>A dollár <code>$</code> szimbólumot arra használjuk, hogy megnézzük, hogy az egyező<br/>
karakter a karakterlánc utolsó karaktere-e. Például a <code>(at\.)$</code> kifejezés<br/>
jelentése: egy kisbetűs <code>a</code>, amit egy kisbetűs <code>t</code>, amit egy <code>.</code> követ. És<br/>
ennek az egésznek a karakterlánc végén kell lennie.</p>

<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_19">3. Shorthand Karakter osztályok</h2>

<p>A gyakran használt karakter osztályokra a reguláris kifejezésnek vannak<br/>
rövidítései, amikkel kényelmesebben tudunk használni általános kifejezéseket.<br/>
A shorthand karakter osztályok a következők:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Rövidítés</th>
<th>Leírás</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.</td>
<td>Minden karakter a sortörésen kívül.</td>
</tr>
<tr>
<td style="text-align: center">\w</td>
<td>Az alfanumerikus karakterekre illeszkedik: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align: center">\W</td>
<td>A nem alfanumerikus karakterekre illeszkedik: <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align: center">\d</td>
<td>Számra illeszkedik: <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align: center">\D</td>
<td>Nem számra illeszkedik: <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align: center">\s</td>
<td>Whitespace karakterre illeszkedik: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align: center">\S</td>
<td>Nem whitespace karakterre illeszkedik: <code>[^\s]</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">4. Lookaround</h2>

<p>A lookbehind (hátranézés) és a lookahead (előrenézés) speciális típusai a<br/>
<strong><em>nem tárolt csoport</em></strong> oknak, amiket illeszkedésre használnak, de nincsenek<br/>
benne az illeszkedési listában. Az előrenézést akkor használjuk, ha feltételezzük,<br/>
hogy ezt a mintát egy másik minta előzi meg, vagy követi. Például kell nekünk<br/>
az összes szám ami előtt <code>$</code> karakter áll a következő karakterláncból: <code>$4.44 and $10.88</code>.<br/>
Ezt a mintát fogjuk használni: <code>(?&lt;=\$)[0-9\.]*</code>, aminek a jelentése: Szedd ki az<br/>
összes számot ami <code>.</code> karaktert tartalmaz és megelőzi egy <code>$</code> karakter. A<br/>
következő lookaround-okat használhatjuk:</p>

<table>
<thead>
<tr>
<th style="text-align: center">Szimbólum</th>
<th>Leírás</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">?=</td>
<td>Positive Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?!</td>
<td>Negative Lookahead</td>
</tr>
<tr>
<td style="text-align: center">?&lt;=</td>
<td>Positive Lookbehind</td>
</tr>
<tr>
<td style="text-align: center">?&lt;!</td>
<td>Negative Lookbehind</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">4.1 Positive Lookahead</h3>

<p>A pozitív előrenézés azt mondja, hogy a kifejezés első részét az előrenézés<br/>
kifejezésnek kell követnie. Az illeszkedés csak azt a szöveget tartalmazza, amire<br/>
a kifejezés első része illeszkedett. Pozitív előrenézést zárójelekkel definiálunk.<br/>
A zárójelek közt van a kérdőjel egy egyenlőségjellel, így: <code>(?=...)</code>. Az előrenézés<br/>
kifejezést az egyenlőségjel után írjuk a zárójelek közé. Például a <code>(T|t)he(?=\sfat)</code><br/>
jelentése: opcionális kisbetűs <code>t</code> vagy nagybetűs <code>T</code>, amit egy <code>h</code> aztán egy <code>e</code><br/>
követ. A zárójelek közt definiáljuk a pozitív előrenézést ami megmondja a reguláris<br/>
kifejezés motornak, hogy illeszkedjen a <code>The</code> vagy <code>the</code> karakterláncokra, amelyeket<br/>
a <code>fat</code> karakterlánc követ.</p>

<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_22">4.2 Negative Lookahead</h3>

<p>A negatív előrenézést akkor használjuk, ha az olyan illeszkedések kellenek,<br/>
amelyeket nem követ egy bizonyos minta. A negatív előrenézést ugyanúgy<br/>
definiáljuk mint a pozitív előrenézést, az egyetlen különbség, hogy az<br/>
egyenlőségjel <code>=</code> helyett negálást <code>!</code> használunk: <code>(?!...)</code>. Nézzük meg<br/>
a következő kifejezést: <code>(T|t)he(?!\sfat)</code>, jelentése: szedd ki az összes<br/>
<code>The</code> vagy <code>the</code> szót, amelyeket nem követ a <code>fat</code> szó (amit még megelőz<br/>
egy szóköz).</p>

<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_23">4.3 Positive Lookbehind</h3>

<p>A pozitív hátranézést akkor használjuk, ha kell az összes illeszkedés, amit<br/>
egy megadott minta előz meg. A pozitív hátranézés így van jelölve: <code>(?&lt;=...)</code>.<br/>
A <code>(?&lt;=(T|t)he\s)(fat|mat)</code> jelentése: szedd ki az összes <code>fat</code> vagy <code>mat</code> szót<br/>
amelyek a <code>The</code> vagy a <code>the</code> szavak után vannak.</p>

<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_24">4.4 Negative Lookbehind</h3>

<p>A negatív hátranézést akkor használjuk, ha kell az összes illeszkedés, amit nem<br/>
egy megadott minta előz meg. Jelölése: <code>(?&lt;!...)</code>. Például a <code>(?&lt;!(T|t)he\s)(cat)</code><br/>
kifejezés jelentése: szedd ki az összes olyan <code>cat</code> szót, amelyik nem a <code>The</code> vagy<br/>
a <code>the</code> szavak után van.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_25">5. Flag-ek</h2>

<p>A flag-eket módosítónak hívják, mert módosítják a reguláris kifejezés<br/>
kimenetét. Ezeket a flag-eket bármilyen sorban vagy kombinációban lehet<br/>
használni, a RegExp szerves részét képezik.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Flag</th>
<th>Leírás</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">i</td>
<td>Kis-nagybetű érzéketlen: Beállítja, hogy az illeszkedés kis-nagybetű érzéketlen legyen.</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td>Globális keresés: A bemeneti szövegben mindenütt keresi az illeszkedéseket.</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td>Többsoros: A horgonyok az összes sorra működnek.</td>
</tr>
</tbody>
</table>

<h3 id="toc_26">5.1 Kis-nagybetű érzéketlen</h3>

<p>Az <code>i</code> módosító beállítja, hogy az illeszkedés ne legyen kis-nagybetű érzékeny.<br/>
Például a <code>/The/gi</code> kifejezés jelentése: nagybetűs <code>T</code> amit kisbetűs <code>h</code>, majd <code>e</code><br/>
követ. A kifejezés végén az <code>i</code> megmondja a reguláris kifejezés motornak, hogy<br/>
hagyja figyelmen kívül a betűk méretét. Ahogy látod, megadtuk a <code>g</code> flag-et, mert<br/>
az egész bemeneti szövegben akarjuk keresni az illeszkedéseket.</p>

<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_27">5.2 Globális keresés</h3>

<p>A <code>g</code> módosítót arra használjuk, hogy globálisan keressünk illeszkedéseket.<br/>
(Megkeresi az összes előfordulást, nem áll meg az első egyezés után). Például<br/>
a <code>/.(at)/g</code> kifejezés jelentése: minden karakter, kivéve a sortörést, amelyet<br/>
<code>a</code> és <code>t</code> követ. Mivel megadtuk a <code>g</code> flag-et, az összes ilyenre fog illeszkedni,<br/>
nem csak az elsőre (ami az alapértelmezett viselkedés). </p>

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Teszteld a reguláris kifejezést</a></p>

<h3 id="toc_28">5.3 Többsoros</h3>

<p>Az <code>m</code> módosítót a többsoros illeszkedésekhez használjuk. Ahogy előzőleg beszéltük,<br/>
a horgonyokat <code>(^, $)</code> arra használjuk, hogy megnézzük, a minta az eleje, vagy a vége-e<br/>
a vizsgált karakterláncnak. De ha azt szeretnénk, hogy a horgonyok az összes soron<br/>
működjenek, használjuk az <code>m</code> módosítót. Például a <code>/at(.)?$/gm</code> kifejezés jelentése:<br/>
kisbetűs <code>a</code> karakter, amit egy kisbetűs <code>t</code> követ, amit opcionálisan bármi követhet,<br/>
kivéve sortörés. És az <code>m</code> flag miatt a reguláris kifejezés motor az összes sor<br/>
végéig keres illeszkedést.</p>

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Teszteld a reguláris kifejezést</a></p>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Teszteld a reguláris kifejezést</a></p>

<h2 id="toc_29">Hozzájárulás</h2>

<ul>
<li>Jelents hibákat</li>
<li>Nyiss pull request-eket fejlesztésekkel</li>
<li>Hírdesd az igét</li>
<li>Érj el közvetlenül itt: <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> vagy <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL"/></a></li>
</ul>

<h2 id="toc_30">Licenc</h2>

<p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_2.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_4.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15998025630555.html">高效 PyCharm 使用技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630642.html">群晖NAS安装配置typecho博客教程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630684.html">Linux vim 编辑器的神级配置 vimrc</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630725.html">正则表达式工具 RegexBuddy 使用指南</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630768.html">使用Docker搭建MySQL服务</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
