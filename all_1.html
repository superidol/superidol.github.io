<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15998025631446.html">
                
                  <h1>Git 常用技巧 （高级用法）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><strong>git 的一些「高级」用法</strong></h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312211952.jpg" alt=""/></p>

<h2 id="toc_1"><strong>导航 —— 跳到之前的分支</strong></h2>

<pre class="line-numbers"><code class="language-text">git checkout -
</code></pre>

<h2 id="toc_2"><strong>查看历史</strong></h2>

<pre class="line-numbers"><code class="language-text"># 每个提交在一行内显示
git log --oneline

# 在所有提交日志中搜索包含「homepage」的提交
git log --all --grep=&#39;homepage&#39;

# 获取某人的提交日志
git log --author=&quot;Maxence&quot;
</code></pre>

<h2 id="toc_3"><strong>之前重置了一个不想保留的提交，但是现在又想要回滚？</strong></h2>

<pre class="line-numbers"><code class="language-text"># 获取所有操作历史
git reflog

# 重置到相应提交
git reset HEAD@{4}
# ……或者……
git reset --hard &lt;提交的哈希值&gt;
</code></pre>

<h2 id="toc_4"><strong>我把本地仓库搞得一团糟，应该怎么清理？</strong></h2>

<pre class="line-numbers"><code class="language-text">git fetch origin
git checkout master
git reset --hard origin/master
</code></pre>

<h2 id="toc_5"><strong>查看我的分支和 master 的不同</strong></h2>

<pre class="line-numbers"><code class="language-text">git diff master..my-branch
</code></pre>

<h2 id="toc_6"><strong>定制提交</strong></h2>

<pre class="line-numbers"><code class="language-text"># 编辑上次提交
git commit --amend -m &quot;更好的提交日志&quot;

# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit

# 空提交 —— 可以用来重新触发 CI 构建
git commit --allow-empty -m &quot;chore: re-trigger build&quot;
</code></pre>

<p>​   <strong>squash 提交</strong></p>

<p>​   比方说我想要 rebase 最近 3 个提交：</p>

<p>​   - git rebase -i HEAD~3<br/>
​   - 保留第一行的 pick，剩余提交替换为 squash 或 s<br/>
​   - 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）</p>

<pre class="line-numbers"><code class="language-text">pick 64d26a1 feat: add index.js
s 45f0259 fix: update index.js
s 8b15b0a fix: typo in index.js
</code></pre>

<h2 id="toc_7"><strong>修正</strong></h2>

<p>比方说想在提交 fed14a4c 加上一些内容。</p>

<p><img src="Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7(%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95).assets/4a407484dfb44ea0ad31738ddf673099.jpg" alt=""/></p>

<p><strong>git 提交分支</strong></p>

<pre class="line-numbers"><code class="language-text">git add .
git commit --fixup HEAD~1
# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1

git rebase -i HEAD~3 --autosquash
# 保存并退出文件（VI 中输入 `:wq`）
</code></pre>

<h2 id="toc_8"><strong>rebase 的时候在每个提交上执行命令</strong></h2>

<p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase --exec 命令在每个提交上执行命令。</p>

<pre class="line-numbers"><code class="language-text"># 在最近 3 个提交上运行 `npm test` 命令
git rebase HEAD~3 --exec &quot;npm test&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212414.jpg" alt=""/></p>

<h2 id="toc_9"><strong>暂存</strong></h2>

<p>​   暂存不止是 git stash 和 git stash pop ;)</p>

<pre class="line-numbers"><code class="language-text"># 保存所有正在追踪的文件
git stash save &quot;日志信息&quot;

# 列出所有的暂存项
git stash list

# 获取并删除暂存项
git stash apply stash@{1}
git stash drop stash@{1}
# ……或使用一条命令……
git stash pop stash@{1}
</code></pre>

<h2 id="toc_10"><strong>清理</strong></h2>

<pre class="line-numbers"><code class="language-text"># 移除远程仓库上不存在的分支
git fetch -p

# 移除所有包含 `greenkeeper` 的分支
git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &#39;s/^.\{9\}//&#39; | xargs git push origin --delete
</code></pre>

<h2 id="toc_11"><strong>GitHub = Git + Hub</strong></h2>

<p>我把 Hub 当成 git 的一个封装来用。你如果也想这么做，可以设置一个别名：alias git=&#39;hub&#39;</p>

<pre class="line-numbers"><code class="language-text"># 打开浏览器访问仓库 url（仅限 GitHub 仓库）git browse
</code></pre>

<hr/>

<h2 id="toc_12"><strong>额外福利：我最喜爱的 git 别名</strong></h2>

<pre class="line-numbers"><code class="language-text">alias g=&#39;git&#39;
alias glog=&#39;git log --oneline --decorate --graph&#39;
alias gst=&#39;git status&#39;
alias gp=&#39;git push&#39;
alias ga=&#39;git add&#39;alias gc=&#39;git commit -v&#39;

# 
alias yolo=&#39;git push --force&#39;

# 每周站会汇报工作时用
git-standup() {
    AUTHOR=${AUTHOR:=&quot;`git config user.name`&quot;}

    since=yesterday
    if [[ $(date +%u) == 1 ]] ; then
        since=&quot;2 days ago&quot;
    fi

    git log --all --since &quot;$since&quot; --oneline --author=&quot;$AUTHOR&quot;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025629044.html">
                
                  <h1>Git版本管理完全指南（包含常见头疼错误解决方案）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">第一部分 命令行</h1>

<p><strong>1、分支操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git branch 创建分支
2. git checkout -b 创建并切换到新建的分支上
3. git checkout 切换分支
4. git branch 查看分支列表
5. git branch -v 查看所有分支的最后一次操作
6. git branch -vv 查看当前分支
7. git brabch -b 分支名 origin/分支名 创建远程分支到本地
8. git branch --merged 查看别的分支和当前分支合并过的分支
9. git branch --no-merged 查看未与当前分支合并的分支
10. git branch -d 分支名 删除本地分支
11. git branch -D 分支名 强行删除分支
12. git branch origin :分支名 删除远处仓库分支
13. git merge 分支名 合并分支到当前分支上
</code></pre>

<p><strong>2、暂存操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git stash 暂存当前修改
2. git stash apply 恢复最近的一次暂存
3. git stash pop 恢复暂存并删除暂存记录
4. git stash list 查看暂存列表
5. git stash drop 暂存名(例：stash@{0}) 移除某次暂存
6. git stash clear 清除暂存
</code></pre>

<p><strong>3、回退操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git reset --hard HEAD^ 回退到上一个版本
2. git reset --hard ahdhs1(commit_id) 回退到某个版本
3. git checkout -- file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)
4. git reset HEAD file 撤回暂存区的文件修改到工作区
</code></pre>

<p><strong>4、标签操作</strong></p>

<pre class="line-numbers"><code class="language-text">1. git tag 标签名 添加标签(默认对当前版本)
2. git tag 标签名 commit_id 对某一提交记录打标签
3. git tag -a 标签名 -m &#39;描述&#39; 创建新标签并增加备注
4. git tag 列出所有标签列表
5. git show 标签名 查看标签信息
6. git tag -d 标签名 删除本地标签
7. git push origin 标签名 推送标签到远程仓库
8. git push origin --tags 推送所有标签到远程仓库
9. git push origin :refs/tags/标签名 从远程仓库中删除标签
</code></pre>

<p><strong>5、其它操作</strong></p>

<p>常规操作</p>

<pre class="line-numbers"><code class="language-text">1. git push origin test 推送本地分支到远程仓库
2. git rm -r --cached 文件/文件夹名字 取消文件被版本控制
3. git reflog 获取执行过的命令
4. git log --graph 查看分支合并图
5. git merge --no-ff -m &#39;合并描述&#39; 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录
6. git check-ignore -v 文件名 查看忽略规则
7. git add -f 文件名 强制将文件提交
8. git reflog 打印所有的日志,假如：ABC三个节点，回退到B后，仍旧打印所有日志
</code></pre>

<p>git创建项目仓库</p>

<pre class="line-numbers"><code class="language-text">1、git init 初始化
2、git remote add origin url 关联远程仓库
3、git pull
4、git fetch 获取远程仓库中所有的分支到本地
</code></pre>

<p>忽略已加入到版本库中的文件</p>

<pre class="line-numbers"><code class="language-text">1、git update-index --assume-unchanged file 忽略单个文件
2、git rm -r --cached 文件/文件夹名字 (. 忽略全部文件)
</code></pre>

<p>取消忽略文件</p>

<pre class="line-numbers"><code class="language-text">git update-index --no-assume-unchanged file
</code></pre>

<p>拉取、上传免密码</p>

<pre class="line-numbers"><code class="language-text">git config --global credential.helper store
</code></pre>

<h1 id="toc_1">第二部分 版本管理</h1>

<p>GitFlow 是由 Vincent Driessen 提出的一个 git操作流程标准。包含如下几个关键分支：</p>

<pre class="line-numbers"><code class="language-text">1. master：主分支develop：主开发分支，包含确定即将发布的代码；
2. feature：新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突；
3. release：发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复；
4. hotfix：热修复分支，紧急修 bug 的时候用。
</code></pre>

<p>GitFlow 的优势有如下几点：</p>

<pre class="line-numbers"><code class="language-text">1. 并行开发：GitFlow可以很方便的实现并行开发。每个新功能都会建立一个新的 feature分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature分支才会合并到主开发分支上（也就是我们经常说的develop分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个feature 分支并完成新功能开发。然后再切回之前的 feature 分支即可继续完成之前功能的开发。
2. 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。
3. 发布阶段：当一个新 feature 开发完成的时候，它会被合并到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature 。
4. 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的 tag，而不会影响到你正在开发的新 feature。
</code></pre>

<blockquote>
<p>然后就是 GitFlow 最经典的几张流程图，一定要理解:</p>
</blockquote>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223014" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p><strong>feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上，等待发布</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223020" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>当需要发布时，我们从 develop 分支创建一个 release 分支</p>

<p>然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会<strong>不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223022" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>发布结束后，这个<strong>release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223025" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<p>master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。</p>

<p>hotfix 分支的作用是紧急修复一些 Bug。它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分支上。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200805223027" alt="Git版本管理完全指南（包含常见头疼错误解决方案）"/></p>

<h1 id="toc_2">第三部分 Git常见错误汇总</h1>

<p><strong>常见错误1、windows使用git时出现：warning:LF will be replaced by CRLF</strong></p>

<p>windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</p>

<ol>
<li>$ rm -rf .git // 删除.git</li>
<li>$ git config --global core.autocrlf false //禁用自动转换</li>
</ol>

<p>然后重新执行：</p>

<ol>
<li>$ git init</li>
<li>$ git add .</li>
</ol>

<p><strong>常见错误2、git push origin master出错：error:failed to push sonme refs to...</strong></p>

<p>很明显是：</p>

<p>本地没有update到最新版本的项目（git上有README.md文件没下载下来）</p>

<p>本地直接push所以会出错。</p>

<p>【解决过程】</p>

<blockquote>
<p>看到提示里面，感觉是本地的代码不是最新的。</p>

<p>所以觉得应该是类似于svn中的，先update一下，再去commit，估计就可以了。</p>

<p>所以先去pull试试：</p>

<p>git pull --rebase origin master</p>
</blockquote>

<p>解决！</p>

<p><strong>常见错误3、fatal: remote origin already exists.</strong></p>

<p>解决办法如下：</p>

<blockquote>
<p>1、先输入$ git remote rm origin</p>

<p>2、再输入$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:djqiang/gitdemo.git 就不会报错了！</p>

<p>3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section &#39;remote.origin&#39;. 我们需要修改gitconfig文件的内容</p>

<p>4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc</p>

<p>5、找到一个名为gitconfig的文件，打开它把里面的[remote &quot;origin&quot;]那一行删掉就好了！</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144649.html">
                
                  <h1>IP 基础知识全家桶，45 张图一套带走</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>前段时间，有读者希望我写一篇关于 IP 分类地址、子网划分等的文章，他反馈常常混淆，摸不着头脑。</p>

<p>那么，说来就来！而且要盘就盘全一点，顺便挑战下小林的图解功力，所以就来个 <strong>IP 基础知识全家桶</strong>。</p>

<p>吃完这个 IP 基础知识全家桶，包你撑着肚子喊出：“<strong>真香！</strong>”</p>

<p>不多说，直接上菜，共分为<strong>三道菜</strong>：</p>

<ul>
<li>首先是前菜 「 IP 基本认识 」</li>
<li>其次是主菜 「IP 地址的基础知识」</li>
<li>最后是点心 「IP 协议相关技术」</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234816.jpg" alt="IP 基础知识全家桶"/>IP 基础知识全家桶</p>

<hr/>

<h2 id="toc_1">正文</h2>

<h3 id="toc_2">前菜 —— IP 基本认识</h3>

<p>IP 在 TCP/IP 参考模型中处于第三层，也就是<strong>网络层</strong>。</p>

<p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234834.jpg" alt="IP 的作用"/>IP 的作用</p>

<blockquote>
<p>网络层与数据链路层有什么关系呢？</p>
</blockquote>

<p>有的小伙伴分不清 IP（网络层） 和 MAC （数据链路层）之间的区别和关系。</p>

<p>其实很容易区分，在上面我们知道 IP 的作用是主机之间通信用的，而 <strong>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p>

<p>举个生活的栗子，小林要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。</p>

<p>飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。</p>

<p>在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。</p>

<p>整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234835.jpg" alt="IP 的作用与 MAC 的作用"/>IP 的作用与 MAC 的作用</p>

<p>如果小林只有行程表而没有车票，就无法搭乘交通工具到达目的地。相反，如果除了车票而没有行程表，恐怕也很难到达目的地。因为小林不知道该坐什么车，也不知道该在哪里换乘。</p>

<p>因此，只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。与此类似，<strong>计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。</strong></p>

<p>还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。其实，在网络中数据包传输中也是如此，<strong>源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</strong></p>

<hr/>

<h3 id="toc_3">主菜 —— IP 地址的基础知识</h3>

<p>在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。</p>

<p>IP 地址（IPv4 地址）由 <code>32</code> 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。</p>

<p>而人类为了方便记忆采用了<strong>点分十进制</strong>的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 <code>4</code> 组，每组以「<code>.</code>」隔开，再将每组转换成十进制。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234836.jpg" alt="点分十进制"/>点分十进制</p>

<p>那么，IP 地址最大值也就是</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234837.jpg" alt="img"/></p>

<p>也就说，最大允许 43 亿台计算机连接到网络。</p>

<p>实际上，IP 地址并不是根据主机台数来配置的，而是以网卡。像服务器、路由器等设备都是有 2 个以上的网卡，也就是它们会有 2 个以上的 IP 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234838.jpg" alt="每块网卡可以分配一个以上的IP地址"/>每块网卡可以分配一个以上的IP地址</p>

<p>因此，让 43 亿台计算机全部连网其实是不可能的，更何况 IP 地址是由「网络标识」和「主机标识」这两个部分组成的，所以实际能够连接到网络的计算机个数更是少了很多。</p>

<blockquote>
<p>可能有的小伙伴提出了疑问，现在不仅电脑配了 IP， 手机、IPad 等电子设备都配了 IP 呀，照理来说肯定会超过 43 亿啦，那是怎么能够支持这么多 IP 的呢？</p>
</blockquote>

<p>因为会根据一种可以更换 IP 地址的技术 <code>NAT</code>，使得可连接计算机数超过 43 亿台。 <code>NAT</code> 技术后续会进一步讨论和说明。</p>

<h4 id="toc_4">IP 地址的分类</h4>

<p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。</p>

<p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234839.jpg" alt="IP 地址分类"/>IP 地址分类</p>

<p>上图中黄色部分为分类号，用以区分 IP 地址类别。</p>

<blockquote>
<p>什么是 A、B、C 类地址？</p>
</blockquote>

<p>其中对于 A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。这很好理解，好比小林是 A 小区 1 栋 101 号，你是 B 小区 1 栋 101 号。</p>

<p>我们可以用下面这个表格， 就能很清楚的知道 A、B、C 分类对应的地址范围、最大主机个数。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234840.jpg" alt="img"/></p>

<blockquote>
<p>A、B、C 分类地址最大主机个数是如何计算的呢？</p>
</blockquote>

<p>最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234841.jpg" alt="img"/></p>

<p>为什么要减 2 呢？</p>

<p>因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234842.jpg" alt="img"/></p>

<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于广播</li>
<li>主机号全为 0 指定某个网络</li>
</ul>

<p>因此，在分配过程中，应该去掉这两种情况。</p>

<blockquote>
<p>广播地址用于什么？</p>
</blockquote>

<p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p>

<p>学校班级中就有广播的例子，在准备上课的时候，通常班长会喊：“上课， 全体起立！”，班里的同学听到这句话是不是全部都站起来了？这个句话就有广播的含义。</p>

<p>当主机号全为 1 时，就表示该网络的广播地址。例如把 <code>172.20.0.0/16</code> 用二进制表示如下：</p>

<p>10101100.00010100.00000000.00000000</p>

<p>将这个地址的<strong>主机部分全部改为 1</strong>，则形成广播地址：</p>

<p>10101100.00010100.<code>11111111.11111111</code></p>

<p>再将这个地址用十进制表示，则为 <code>172.20.255.255</code>。</p>

<p>广播地址可以分为本地广播和直接广播两种。</p>

<ul>
<li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li>
<li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234843.jpg" alt="本地广播与直接广播"/>本地广播与直接广播</p>

<blockquote>
<p>什么是 D、E 类地址？</p>
</blockquote>

<p>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234844.jpg" alt="img"/></p>

<blockquote>
<p>多播地址用于什么？</p>
</blockquote>

<p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p>

<p>还是举班级的栗子，老师说：“最后一排的同学，上来做这道数学题。”，老师指定的是最后一排的同学，也就是多播的含义了。</p>

<p>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234845.jpg" alt="单播、广播、多播通信"/>单播、广播、多播通信</p>

<p>多播使用的 D 类地址，其前四位是 <code>1110</code> 就表示是多播地址，而剩下的 28 位是多播的组编号。</p>

<p>从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：</p>

<ul>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li>
</ul>

<blockquote>
<p>IP 分类的优点</p>
</blockquote>

<p>不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。</p>

<p>其余分类判断方式参考如下图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234846.jpg" alt="IP 分类判断"/>IP 分类判断</p>

<p>所以，这种分类地址的优点就是<strong>简单明了、选路（基于网络地址）简单</strong>。</p>

<blockquote>
<p>IP 分类的缺点</p>
</blockquote>

<p><em>缺点一</em></p>

<p><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</p>

<p><em>缺点二</em></p>

<p>A、B、C类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p>

<ul>
<li>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</li>
<li>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li>
</ul>

<p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决。</p>

<h4 id="toc_5">无分类地址 CIDR</h4>

<p>正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 <code>CIDR</code>。</p>

<p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p>

<blockquote>
<p>怎么划分网络号和主机号的呢？</p>
</blockquote>

<p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得 IP 地址更加具有灵活性。</p>

<p>比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234847.jpg" alt="img"/></p>

<p>还有另一种划分网络号与主机号形式，那就是<strong>子网掩码</strong>，掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p>

<p><strong>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234848.jpg" alt="img"/></p>

<blockquote>
<p>为什么要分离网络号和主机号？</p>
</blockquote>

<p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>

<p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234849.jpg" alt="IP地址的网络号"/>IP地址的网络号</p>

<blockquote>
<p>怎么进行子网划分？</p>
</blockquote>

<p>在上面我们知道可以通过子网掩码划分出网络号和主机号，那实际上子网掩码还有一个作用，那就是<strong>划分子网</strong>。</p>

<p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。形式如下：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234850.jpg" alt="img"/></p>

<ul>
<li>未做子网划分的 ip 地址：网络地址＋主机地址</li>
<li>做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）</li>
</ul>

<p>假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。</p>

<p>C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知<strong>从 8 位主机号中借用 2 位作为子网号</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234851.jpg" alt="img"/></p>

<p>由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11，具体划分如下图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234852.jpg" alt="img"/></p>

<p>划分后的 4 个子网如下表格：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234853.jpg" alt="img"/></p>

<h4 id="toc_6">公有 IP 地址与私有 IP 地址</h4>

<p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234854.jpg" alt="img"/></p>

<p>平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP 地址。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址和我学校的可以是一样的。</p>

<p>就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101 号，我小区家也可以叫 1 栋 101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP 地址），是国家统一分配的，不能两个小区都叫中山路 666。</p>

<p>所以，公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234855.jpg" alt="公有 IP 地址与私有 IP 地址"/>公有 IP 地址与私有 IP 地址</p>

<blockquote>
<p>公有 IP 地址由谁管理呢？</p>
</blockquote>

<p>私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 <code>ICANN</code> 组织管理，中文叫「互联网名称与数字地址分配机构」。</p>

<p>IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234856.jpg" alt="img"/></p>

<ul>
<li>ARIN 北美地区</li>
<li>LACNIC 拉丁美洲和一些加勒比群岛</li>
<li>RIPE NCC 欧洲、中东和中亚</li>
<li>AfriNIC 非洲地区</li>
<li>APNIC 亚太地区</li>
</ul>

<p>其中，在中国是由 CNNIC 的机构进行管理，它是中国国内唯一指定的全局 IP 地址管理的组织。</p>

<h4 id="toc_7">IP 地址与路由控制</h4>

<p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。</p>

<p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。</p>

<p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有<strong>相同网络地址</strong>的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p>

<p>下面以下图的网络链路作为例子说明：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234857.jpg" alt="IP 地址与路由控制"/>IP 地址与路由控制</p>

<ol>
<li>主机 A 要发送一个 IP 包，其源地址是 <code>10.1.1.30</code> 和目标地址是 <code>10.1.2.10</code>，由于没有在主机 A 的路由表找到与目标地址 <code>10.1.2.10</code> 的网络地址，于是包被转发到默认路由（路由器 <code>1</code> ）</li>
<li>路由器 <code>1</code> 收到 IP 包后，也在路由器 <code>1</code> 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 <code>10.1.0.2</code> 这台路由器 <code>2</code></li>
<li>路由器 <code>2</code> 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 <code>2</code> 的 <code>10.1.2.1</code> 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机</li>
</ol>

<blockquote>
<p>环回地址是不会流向网络</p>
</blockquote>

<p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</p>

<p>计算机使用一个特殊的 IP 地址 <strong>127.0.0.1 作为环回地址</strong>。与该地址具有相同意义的是一个叫做 <code>localhost</code> 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p>

<h4 id="toc_8">IP 分片与重组</h4>

<p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是 1500 字节等。</p>

<p>每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</p>

<p>其中，我们最常见数据链路是以太网，它的 MTU 是 <code>1500</code> 字节。</p>

<p>那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。</p>

<p>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</p>

<p>假设发送方发送一个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234858.jpg" alt="分片与重组"/>分片与重组</p>

<p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 <code>MSS</code> 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p>

<h4 id="toc_9">IPv6 基本认识</h4>

<p>IPv4 的地址是 32 位的，大约可以提供 42 亿个地址，但是早在 2011 年 IPv4 地址就已经被分配完了。</p>

<p>但是 IPv6 的地址是 <code>128</code> 位的，这可分配的地址数量是大的惊人，说个段子 <strong>IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址。</strong></p>

<p>但 IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相比于 IPv4 能带来更好的网络体验。</p>

<p>但是因为 IPv4 和 IPv6 不能相互兼容，所以不但要我们电脑、手机之类的设备支持，还需要网络运营商对现有的设备进行升级，所以这可能是 IPv6 普及率比较慢的一个原因。</p>

<blockquote>
<p>IPv6 的亮点</p>
</blockquote>

<p>IPv6 不仅仅只是可分配的地址变多了，它还有非常多的亮点。</p>

<ul>
<li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，真是<strong>便捷到即插即用</strong>啊。</li>
<li>IPv6 包头包首部长度采用固定的值 <code>40</code> 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li>
<li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li>
<li><strong>…</strong> （由你发现更多的亮点）</li>
</ul>

<blockquote>
<p>IPv6 地址的标识方法</p>
</blockquote>

<p>IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。</p>

<p>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234859.jpg" alt="IPv6 地址表示方法"/>IPv6 地址表示方法</p>

<p>如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234900.jpg" alt="Pv6 地址缺省表示方"/>Pv6 地址缺省表示方</p>

<blockquote>
<p>IPv6 地址的结构</p>
</blockquote>

<p>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</p>

<p>IPv6 的地址主要有以下类型地址：</p>

<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234901.jpg" alt="IPv6地址结构"/>IPv6地址结构</p>

<blockquote>
<p>IPv6 单播地址类型</p>
</blockquote>

<p>对于一对一通信的 IPv6 地址，主要划分了三类单播地址，每类地址的有效范围都不同。</p>

<ul>
<li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4 没有此类型</li>
<li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于 IPv4 的私有 IP</li>
<li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于 IPv4 的公有 IP</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234902.jpg" alt=" IPv6 中的单播通信"/>IPv6 中的单播通信</p>

<h4 id="toc_10">IPv4 首部与 IPv6 首部</h4>

<p>IPv4 首部与 IPv6 首部的差异如下图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234903.jpg" alt="IPv4 首部与 IPv6 首部的差异"/>IPv4 首部与 IPv6 首部的差异</p>

<p>IPv6 相比 IPv4 的首部改进：</p>

<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>

<hr/>

<h3 id="toc_11">点心 —— IP 协议相关技术</h3>

<p>跟 IP 协议相关的技术也不少，接下来说说与 IP 协议相关的重要且常见的技术。</p>

<ul>
<li>DNS 域名解析</li>
<li>ARP 与 RARP 协议</li>
<li>DHCP 动态获取 IP 地址</li>
<li>NAT 网络地址转换</li>
<li>ICMP 互联网控制报文协议</li>
<li>IGMP 因特网组管理协</li>
</ul>

<h4 id="toc_12">DNS</h4>

<p>我们在上网的时候，通常使用的方式是域名，而不是 IP 地址，因为域名方便人类记忆。</p>

<p>那么实现这一技术的就是 <strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。</p>

<blockquote>
<p>域名的层级关系</p>
</blockquote>

<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>

<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>

<p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>

<p>根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。</p>

<p>所以域名的层级关系类似一个树状结构：</p>

<ul>
<li>根 DNS 服务器</li>
<li>顶级域 DNS 服务器（com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234904.jpg" alt="DNS 树状结构"/>DNS 树状结构</p>

<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p>

<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>

<blockquote>
<p>域名解析的工作流程</p>
</blockquote>

<p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：</p>

<ol>
<li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com%EF%BC%8C%E5%88%99%E5%AE%83%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>

<p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234905.jpg" alt="域名解析的工作流程"/>域名解析的工作流程</p>

<p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong>。</p>

<h4 id="toc_13">ARP</h4>

<p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。</p>

<p>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 <strong>ARP 协议</strong>，求得下一跳的 MAC 地址。</p>

<blockquote>
<p>那么 ARP 又是如何知道对方 MAC 地址的呢？</p>
</blockquote>

<p>简单地说，ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234906.jpg" alt="ARP 广播"/>ARP 广播</p>

<ul>
<li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li>
</ul>

<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。</p>

<p>不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p>

<blockquote>
<p>RARP 协议你知道是什么吗？</p>
</blockquote>

<p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是<strong>已知 MAC 地址求 IP 地址</strong>。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>

<p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p>

<ul>
<li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li>
</ul>

<p>最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234907.jpg" alt="RARP"/>RARP</p>

<h4 id="toc_14">DHCP</h4>

<p>DHCP 在生活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。</p>

<p>接下来，我们来看看我们的电脑是如何通过 4 个步骤的过程，获取到 IP 的。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234908.jpg" alt="DHCP 工作流程"/>DHCP 工作流程</p>

<p>先说明一点，DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p>

<p>这 4 个步骤：</p>

<ul>
<li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>

<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</p>

<p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p>

<ul>
<li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li>
<li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li>
</ul>

<p>可以发现，DHCP 交互中，<strong>全程都是使用 UDP 广播通信</strong>。</p>

<blockquote>
<p>咦，用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p>
</blockquote>

<p>所以，为了解决这一问题，就出现了 <strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234909.jpg" alt=" DHCP 中继代理"/>DHCP 中继代理</p>

<ul>
<li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li>
<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li>
</ul>

<p>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p>

<h4 id="toc_15">NAT</h4>

<p>IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。</p>

<p>于是，提出了一种<strong>网络地址转换 NAT</strong> 的方法，再次缓解了 IPv4 地址耗尽的问题。</p>

<p>简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234910.jpg" alt="NAT"/>NAT</p>

<blockquote>
<p>那不是 N 个私有 IP 地址，你就要 N 个公有 IP 地址？这怎么就缓解了 IPv4 地址耗尽的问题？这不瞎扯吗？</p>
</blockquote>

<p>确实是，普通的 NAT 转换没什么意义。</p>

<p>由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。</p>

<p>因此，可以把 IP 地址 + 端口号一起进行转换。</p>

<p>这样，就用一个全球 IP 地址就可以了，这种转换技术就叫<strong>网络地址与端口转换 NAPT。</strong></p>

<p>很抽象？来，看下面的图解就能瞬间明白了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234911.jpg" alt="NAPT"/>NAPT</p>

<p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。</p>

<p>此时，<strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p>

<p>于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。</p>

<p>这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。</p>

<blockquote>
<p>NAT 那么牛逼，难道就没缺点了吗？</p>
</blockquote>

<p>当然有缺陷，肯定没有十全十美的方案。</p>

<p>由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：</p>

<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>

<blockquote>
<p>如何解决 NAT 潜在的问题呢？</p>
</blockquote>

<p>解决的方法主要有两种方法。</p>

<p><em>第一种就是改用 IPv6</em></p>

<p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。</p>

<p><em>第二种 NAT 穿透技术</em></p>

<p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p>

<p>也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。</p>

<p>说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。</p>

<h4 id="toc_16">ICMP</h4>

<p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p>

<p>里面有个关键词 —— <strong>控制</strong>，如何控制的呢？</p>

<p>网络包在复杂的网络传输环境里，常常会遇到各种问题。</p>

<p>当遇到问题的时候，总不能死个不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p>

<blockquote>
<p>ICMP 功能都有啥？</p>
</blockquote>

<p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>

<p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234912.jpg" alt="ICMP 目标不可达消息"/>ICMP 目标不可达消息</p>

<p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p>

<p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p>

<p>因此，从路由器 <code>2</code> 返回的 ICMP 包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机 <code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p>

<blockquote>
<p>ICMP 类型</p>
</blockquote>

<p>ICMP 大致可以分为两大类：</p>

<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234913.jpg" alt="常见的 ICMP 类型"/>常见的 ICMP 类型</p>

<h4 id="toc_17">IGMP</h4>

<p>ICMP 跟 IGMP 是一点关系都没有的，就好像周杰与周杰伦的区别，大家不要混淆了。</p>

<p>在前面我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234914.jpg" alt="组播模型"/>组播模型</p>

<p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p>

<ul>
<li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li>
<li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li>
</ul>

<blockquote>
<p>IGMP 工作机制</p>
</blockquote>

<p>IGMP 分为了三个版本分别是，IGMPv1、IGMPv2、IGMPv3。</p>

<p>接下来，以 <code>IGMPv2</code> 作为例子，说说<strong>常规查询与响应和离开组播组</strong>这两个工作机制。</p>

<p><em>常规查询与响应工作机制</em></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234915.jpg" alt=" IGMP 常规查询与响应工作机制"/>IGMP 常规查询与响应工作机制</p>

<ol>
<li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li>
<li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li>
<li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li>
</ol>

<p><em>离开组播组工作机制</em></p>

<p>离开组播组的情况一，网段中仍有该组播组：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234916.jpg" alt=" IGMPv2 离开组播组工作机制 情况1"/>IGMPv2 离开组播组工作机制 情况1</p>

<ol>
<li>主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）</li>
<li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。</li>
<li>主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。</li>
</ol>

<p>离开组播组的情况二，网段中没有该组播组：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20201105234917.jpg" alt=" IGMPv2 离开组播组工作机制 情况2"/>IGMPv2 离开组播组工作机制 情况2</p>

<ol>
<li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报文。</li>
<li>路由器收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个）。此时在该网段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询。</li>
<li>一定时间后，路由器认为该网段中已经没有 224.1.1.1 组播组成员了，将不会再向这个网段转发该组播地址的数据包。</li>
</ol>

<hr/>

<h2 id="toc_18">巨人的肩膀</h2>

<p>[1] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</p>

<p>[2] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</p>

<p>[3] 图解TCP/IP.竹下隆史.人民邮电出版社</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025630955.html">
                
                  <h1>iPad 数字笔记完全指南</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">「后浪」的「笔记方式」</h2>

<p>大概两年以前，我就写过一篇 iPad Pro 笔记指南。在那篇文章中，我详细说明了如何使用 iPad Pro 记笔记这件事。</p>

<p>但那时 iPad 的笔记系统还仅仅只有 iPad Pro 一家，而没想到两年后，iPad 的笔记系统就已经渗透到每一个型号的 iPad 中。</p>

<p>而也仅仅才两年而已，在最近 B 站的刷屏的演讲《后浪》中，iPad Pro 甚至给了一个特写镜头和一个环境描写，而画面中的女主正在使用 iPad Pro 记笔记学习一门语言。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122030.png" alt="img"/></p>

<p>也就是说，只过去了两年，在一片「iPad 记笔记就是一个噱头的」的噪音中，它已经成为了越来越多的学生、文字工作者的首选。</p>

<p>而随着全线 iPad 家族都支持 Apple Pencil 的今天，iPad 记笔记本身也发生着巨大的变化，所以这也是我为什么写这篇文章的原因。</p>

<p>我希望可以给所有想使用 iPad 记笔记的人一个参考。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122239.png" alt="img"/>（王同学笔记作品）</p>

<p>只可惜，因为我自己早已经不是「学生」，所以在学生笔记记录上，发言权较少。</p>

<p>不过，这次我找到了两位学霸帮忙，他们分别是复旦大学临床医学李书琪同学以及复旦大学德语专业的王同学。</p>

<p>两位同学在最近一次的笔记评选大赛中脱颖而出，所以我认为让这两位学霸「言传身教」再合适不过，所以这篇文章很多内容是以她们的分享为基础。</p>

<p>当然，我也会加入一些我平时工作中的笔记场景，给职场的各位参考。</p>

<p>在文章开始之前，在这里放一个思维导图，帮助你快速找到想要看的内容。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122240.jpg" alt="img"/></p>

<h2 id="toc_1">数字笔记 VS 传统笔记</h2>

<p>其实在我看来，很多人之所以对于数字笔记心存芥蒂，归根到底还是不愿意「重新适应」。</p>

<p>如果你一开始就是用 iPad 记笔记，其实并不会觉得有各种麻烦。如果你已经习惯了传统笔记的记录方式，那么自然你就会觉得不适应。但很多人，会错误地把这种不适应，看作是 iPad 的问题。</p>

<p>但其实，如果调转过来，你一开始使用 iPad 记笔记，然后使用传统笔和纸，你会发现传统纸笔也会伴随着大量的问题，比如功能单一、无法修改等等各种各样的「不适应」。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122241.jpg" alt="img"/>（王同学笔记作品）</p>

<p>归根到底，这是一种取舍。</p>

<p>其实很多人对于 iPad 记笔记抗拒的最重要原因在于「没有书写的质感」。直白地说，在 iPad 上写写画画并没有那种在纸张上写字带来的「阻尼感」。</p>

<p>的确，由于 iPad 本身表面是一个「光滑」的玻璃，所以很容易让自己的字写的「飞起来」。尤其是像我这种字本身就十分难看的人来说，这个问题会被直接放大。但其实这件事有两个解决方案：</p>

<p><strong>1. 多练习。</strong>是的，如果你一开始不适应，那么就慢慢适应。很多人可能会担心这种适应时间会非常漫长，其实真的远比想象得更快。</p>

<p>我有一段时间，意识到自己的打字手法不对，影响键入效率，同时还让自己的手指很容易处于一种不健康的状态，所以决定开始重新练习。</p>

<p>本来以为十几年的习惯改起来肯定是需要几个月，但是没有想到几个星期就可以。举这个例子是想要说明，即使我们认为十几年的固有习惯都可以很快修改。</p>

<p>所以，如果你一开始不适应在「玻璃上」记笔记，基本上经过一定时间的书写，将会完全掌握这种节奏。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122242.jpeg" alt="img"/>（李书琪笔记作品）</p>

<p><strong>2. 贴膜。</strong>当然这里特指的是类纸膜。我自己本身是一个电子产品「邋遢」户，这意味着我从来不喜欢给自己的电子产品贴膜，所以我的 iPad Pro 从来都是不贴膜使用。</p>

<p>但是如果还是很看重这种纸笔的书写质感，只要购买「类纸膜」即可。类纸膜非常的便宜，好的也就是一百元不到即可。</p>

<p>类纸膜将会可以使你的 iPad Pro 直接变成真实的纸张质感，和你在纸上写字完全没有区别。</p>

<p>但是类纸膜，有两个重要缺陷你需要知道。</p>

<p>首先是类纸膜会让你的屏幕清晰度直线下降。这一点也不夸张，我自己使用过一段时间类纸膜，最后实在是认为这是浪费 iPad Pro 这块屏幕，所以放弃。</p>

<p>其次是类纸膜会对 Apple Pencil 的笔尖有着非常大的磨损，当然这件事可以通过置换笔尖来解决。</p>

<p>结论是，除非你真的很看重这种所谓「书写质感」，否则非常不建议类纸膜。</p>

<p>那么当你跨过这道「书写质感」的门槛，那么接下来你将会拥抱的就是所有 iPad 记笔记的优势。</p>

<p><strong>内容多样。</strong>iPad 目前主流笔记软件中，包含着非常丰富的笔记功能。</p>

<p>首先在「笔」本身的选择上就选择多样。你可以选择不同粗细、笔迹、颜色的笔来针对笔记的不同内容。</p>

<p>这一点对于一些需要绘图的学科来说可以说非常重要，比如李书琪同学因为医学专业，需要绘制很多人体图来进行说明和记忆，此时电子笔记可以变化为非常丰富的绘画工具。</p>

<p>而如果你此时想要通过传统笔记来实现这一点，你还需要配合着非常多的绘画工具才行。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122243.jpg" alt="img"/>李书琪笔记作品</p>

<p>如果你和我一样是一个手残，画的不好看，那么你就更应该使用 iPad 记笔记。因为iPad 记笔记可以允许你直接插入图片，所以你可以直接拍下对应的图，直接插在笔记中所需要的位置即可。</p>

<p>当然，我们记笔记终究是为了看，那么数字笔记的阅读体验也将会对传统笔记来说有着非常高的效率。</p>

<p><strong>轻便是最明显的感受。</strong>随着日积月累，我们的笔记越来越厚，无论什么专业，几本大本子肯定是少不了，所以这就要求我们复习的时候要携带非常厚重的内容。</p>

<p>有的时候，少带几本，看的时候需要会是一件很恼人的事情，但是 iPad 的存储容量是几乎没有上限的，按照目前 iPad 的容量选择，你甚至可以带上「一车笔记」。而且每次打开，就是所有的笔记供你选择。</p>

<p><strong>检索高效是核心。</strong>当笔记越来越多的时候，如何找到自己想要的知识点就很重要。而目前几乎所有的主流笔记软件，都已经完全支持了所谓的「笔记搜索」。仅仅是通过搜索对应的关键字，就可以快速地找到自己想要的内容。</p>

<p><strong>可修改是另一个隐含要素。</strong>因为电子笔记是数字化的，所以就意味着你可以随时修改。随着我们的知识水平提高，笔记中就会出现很多「小儿科」的内容，此时我们就可以在此基础上制作一个「精简版」。</p>

<p>iPad 记笔记可以直接删减原有的内容，而在传统的纸质笔记上，就只有「从来一遍」。</p>

<p>或多或少，我们可能都经历过丢笔记的事。这是一件非常痛心的事，因为这意味着白费了我们的心血和精力。但是因为数字笔记都可以实现云备份，所以就算是设备丢了，但是笔记都会在。</p>

<p>所以，不管怎么看，iPad 记笔记相对传统笔记都有着绝对的优势。只要你能够在一开始尝试适应，那么收获的将会是一种更为「现代」的记笔记方式。</p>

<h2 id="toc_2">「大本」和「小本」</h2>

<p>所以现在你可能决定下定决心，开始准备使用 iPad 记笔记。但是你还没有一台 iPad，那么这一部分就是来说明不同 iPad 记笔记的体验。</p>

<p>目前，有四套 iPad 笔记方式可以选择。</p>

<h3 id="toc_3">iPad（第七代） + Apple Pencil 第一代</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122244.jpg" alt="img"/></p>

<p>这是「最具有性价比」的笔记选择。目前 iPad （第七代）的入门价格仅仅是 2499 元。那么配合上一根 Apple Pencil 第一代的价格，也就是 3000 元刚出头。</p>

<p>这一套组合基本上可以实现 iPad 系列 70% 的笔记记录体验。不足的地方在于，由于 iPad 10.2 寸是非贴合的屏幕，并且屏幕的刷新率不高，所以在笔记的记录体验上，会和更高级的 iPad Pro 有着肉眼可见的差距。但是话说回来，它所需要的价格基本上是 iPad Pro 的一半不到，所以这也是为什么我说性价比很高的原因。</p>

<p>10.2 寸本身也属于「中号笔记本」。可以保证一页笔记中，就有着充足的信息量。也可以在书写过程中，降低翻页的频率从而保证跟上课堂节奏。</p>

<h3 id="toc_4">iPad Air + Apple Pencil 第一代</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122245.jpg" alt="img"/></p>

<p>这是「更护眼」的笔记选择。相对于 iPad （第七代）来说，iPad Air 核心上当然是芯片的升级，来到了 A12 。不过对于记笔记来说，更关键的是屏幕本身的升级。虽然，在屏幕本身的大小、分辨率上和 iPad 第七代区别不大。但是 iPad Air 具备抗反射涂层，这意味着在有复杂光线的环境中，iPad Air 本身反光情况会大大降低，这样可以避免在记笔记中反光刺眼的情况。</p>

<p>而另一个关键是，iPad Air 是配备了原彩显示。这项功能可以让 iPad Air 的屏幕随着环境色温的变化而进行冷暖变化，这样可以「更护眼」。再配上全贴合屏幕更加真实的书写体验，所以这是为什么我说 iPad Air 是更加护眼的选择。</p>

<p>尤其是很多家长，可能会非常在乎孩子的视力，那么相对来说，iPad Air 就会更适合一些。</p>

<h3 id="toc_5">iPad Pro + Apple Pencil 第二代</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122246.jpg" alt="img"/></p>

<p>这是「最好」的笔记选择。</p>

<p>iPad 一直都是平板的标杆，那么 iPad Pro 是标杆中的标杆。所以这也就意味着 iPad Pro 拥有最好的笔记记录体验。这种最好渗透在各个方面，比如 ProMotion 自适应刷新率带来的跟手感、比如顶级的 LCD 屏幕带来的细腻度、比如第二代 Apple Pencil 磁吸设计的自由方便。</p>

<p>如果你是一个对预算不敏感的用户，直接上 iPad Pro，就可以获得最好的 iPad 记笔记体验。在尺寸选择上，对于学生来说我更推荐 11 寸。因为 11 寸的手感轻便，可以放进大多数的背包中。相对来说 12.9 寸就会显得非常笨重。使用起来，需要一定的空间，这对于大学教室相对拥挤的空间来说，是个不小的挑战。</p>

<h3 id="toc_6">iPad mini + Apple Pencil 第一代</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122247.jpg" alt="img"/></p>

<p>这是一个针对「特殊需求」的笔记套装选择。首先需要承认的是，iPad mini 的尺寸只有 7.9 英寸，所以它的笔记记录体验会有着很明显的「局限性」。如果你经常严肃的记录一些信息量非常丰富的笔记就会显得不适合。但是如果平时记笔记的需求是一个「记事本」，那么 iPad mini 是非常合适的。我经常跟一些采访，就更愿意使用 iPad mini 记笔记。因为 iPad mini 更加小巧，没有攻击性。而且对于被采访人对话的简要信息量来说，「纸张」大小也够用。</p>

<p>最后单独说说 Apple Pencil 。</p>

<p>目前 Apple Pencil 已经出了两代，体验最好的自然是 Apple Pencil 第二代。因为磁吸设计基本上已经把充电过程省略不说，还方便收纳。</p>

<p>但是需要说明的是，Apple Pencil 第二代只可以在 iPad Pro 上使用，其它任何型号的 iPad 都不可以使用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122248.jpg" alt="img"/></p>

<p>对了，第一代 Apple Pencil 有两个小细节很多人可能不知道。一个是 Apple Pencil 是有自己的充电转换接口的，并不一定要插在 iPad 上充电，那只是用来应急的；另一个是 Apple Pencil 第一代的笔盒里是有备用的笔尖的，别丢。</p>

<p>总的来说，目前基本上各个预算区间，都可以选到不错的 iPad 记笔记组合，但考虑到 iPad 记笔记都是学生群体为主，还是希望大家量力而行，在自己的家庭经济范围内购买产品。</p>

<h2 id="toc_7">双雄对决</h2>

<p>在选择了合适的硬件以后，我们接下来就需要选择合适的软件。对于 iPad 来说，软件生态才是它的核心。</p>

<p>我其实市面上主流的不同平台笔记设备都有使用过，比如和 iPad 对标的 Surface Pro 系列，或者是华为的 MatePad Pro 系列。</p>

<p>坦率地说，硬件上也许还可以勉强一战，但是到了软件上，则是完全另一回事。</p>

<p>这才是为什么 iPad 成为主流数字笔记的真正原因。</p>

<p>目前，iPad 上记笔记已经是「双雄逐鹿」的局面，甚至你可能还没有 iPad，但是已经听过它们的大名，也就是 GoodNotes 5 和 Notability。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122249.jpg" alt="img"/>（GoodNotes 5）</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122250.png" alt="img"/>（Notability）</p>

<p>这两款软件，基本上涵盖了市面上电子笔记的所有功能。而且二者本身的功能重合度也很高，所以其实选择这其中任何一款软件都可以成为你长久使用的笔记工具。</p>

<p>你现在在 B 站搜索这两款软件，就会有非常多的详细对比视频和使用技巧，可见这两款软件是有多受欢迎。</p>

<p>这一部分，我将会从它们之间的差异性入手，让你可以了解到哪些功能更适合自己，帮助你在二者之间做出自己的选择。</p>

<p>当然，你可能会说，我有钱任性，两个软件我都买。其实我非常不建议你这样做，因为这样每次记笔记你都会面临着「用哪一个」的选择，反而耽误时间。所以还不如强迫自己选择一个后，深入地使用，积累更多的使用经验。</p>

<p>在具体比较之前，需要说明的是，这里的比较只是展示差异，并不是谁会比谁更好。</p>

<p>而所有的比较都是二者相对，其实两款软件的本身体验是绝对的素质够用。并不是某一个点不好，而是相对另一个稍弱，仅此而已。</p>

<h3 id="toc_8">笔记管理</h3>

<p>在笔记管理方面，GoodNotes 5 更加相对科学。因为 GoodNotes 5 基本上沿用的就是 iPad 本身的文件管理方式。</p>

<p>在打开的界面就是「文件夹」，相对的文件夹里又可以是文件夹。所以你完全可以根据自己的喜好，习惯对自己的笔记进行科学的管理，比如分学科、分章节，这样使用起来非常的清晰明了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122251.jpg" alt="img"/>（左：GoodNotes 5 右：Notability）</p>

<p>但是 Notability 采用的是层级的展现方式，相比较下来，没有 GoodNotes 5 直观。无论是在分类还是在查找上，都显得有一些笨拙。</p>

<p>而且从笔记本的自定义角度来说，GoodNotes 5 不仅自带的模版更加耐看，而且还提供更加丰富的自定义形式，所以如果你是一个在乎颜值的人，这一点需要你关注。</p>

<h3 id="toc_9">书写体验</h3>

<p>这里就有一些见仁见智了。</p>

<p>比如我一直认为 GoodNotes 的写字更加好看，其实好长一段时间里我都是这么认为的。</p>

<p>从我自己的体验上来看，似乎 GoodNotes 是针对用户的笔迹进行优化的，所以甚至是让我有了一种比我在纸上写字还好看的错觉。</p>

<p>但是直到有一天有一个人跟我说，他认为 Notability 写字更好看，才意识到可能并不是所有人都这么认为。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122252.jpg" alt="img"/>（GoodNotes 5 钢笔笔迹）</p>

<p>从我自己的体验上来看，GoodNotes 5 的钢笔体验写字最舒服，写出来的字笔画更自然。但是 Notability 写字更加顺滑，所以很多时候会略显飘逸。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122253.jpg" alt="img"/>（Notability 二级点选菜单）</p>

<p>书写选择上，二者都提供了非常丰富的书写样式、粗细、颜色等等。</p>

<p>但是在切换不同的笔迹时 GoodNotes 5 大部分操作在一级菜单中就可以切换，而 Notability 需要点击切换。</p>

<p>相对来说，如果你是一个笔记绘画需求更多的，那无疑使用 GoodNotes 是更好的选择。</p>

<h3 id="toc_10">文本转换</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122254.png" alt="img"/></p>

<p>两款软件都提供了文本转换功能，即把你的手写笔迹直接转换为文本。</p>

<p>在这个功能上 Notability 有着明显的优势。因为 Notability 的文本转换不仅仅是正确率更高，而且转化以后可以直接作为结果使用在笔记中。</p>

<p>而对于 GoodNotes ，虽然可以转换为文字，但是转换以后想要插入到文本中，还需要拷贝再粘贴。</p>

<h3 id="toc_11">录音体验</h3>

<p>Notability 提供了很好的录音功能。这项功能的喜爱对于很多学生可能是习惯因人而异，但是对于记者来说可以说是一定了。</p>

<p>有录音就可以保证后期报道的准确性，而且 Notability 还提供了一个「笔记录音回放」。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122255.jpg" alt="img"/></p>

<p>可以点击任意一个笔记，回放当时录制的对应段落。这在后期写稿件的时候，非常高效。</p>

<p>当然，对于学生来说，这一点对于一些说话飞快，记笔记只能记录一个大概的老师来说也是一个刚需功能。</p>

<p>而相对 GoodNotes 5 来说，录音功能基本上就是缺失，所以这一点也是两款软件的最大区别，如果你对于录音有着明确需求，那么选择 Notability 就完全没错。</p>

<h3 id="toc_12">文件插入</h3>

<p>从文件插入的效率来说，GoodNotes 更好更方便。因为点击插入的时候，直接会在第一层级就显示一些文件。但是对于 Notability 是需要二次点击来实现的。</p>

<p>话又说回来，两者都可以通过分屏、或者悬浮相册来直接拖入文件。但是相对的，Notability 支持的文件格式更多一些，比如 Gif 在 Notability 是可以自由的播放的，但是 GoodNotes 是不支持的。</p>

<p>在插入 PDF 方面，我认为 GoodNotes 远好于 Notability 。因为插入不仅方便，而且批注清晰明了，再配合文件夹管理，更系统。</p>

<p>所以总结来看：</p>

<p>GoodNotes 是一款高颜值、追求书写体验、阅读体验的笔记。</p>

<p>Notability 是一款功能丰富、有录音支持为核心的笔记。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122256.jpeg" alt="img"/></p>

<p>我自己因为更看重书写体验，尤其是可以让我觉得我的字变得好看和工整，所以基本上都是使用 GoodNotes 居多。</p>

<h2 id="toc_13">技巧和心得</h2>

<h3 id="toc_14">设备之间的云同步</h3>

<p>这也是电子笔记一个非常重要的优势。目前无论是 GoodNotes 5 还是 Notability 都可以云同步笔记。这样做有两个好处，一个是你的笔记永远不会丢。</p>

<p>如果你是一个学科非常复杂的学生，尤其是进入大学以后，那么你会发现如果一个学科一个笔记本，需要的笔记本数量将会非常多。</p>

<p>而且就算你能都配好，翻找起来也非常麻烦，经常是弄不好就丢掉了一个笔记。但是使用云同步以后，就可以保证自己的笔记永远不会丢。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122257.jpeg" alt="img"/></p>

<p>大部分笔记软件都是可以跨平台的。尤其是 GoodNotes 5 这一款软件，它不仅仅是 iOS 设备，包括甚至是 macOS 都有对应的软件。</p>

<p>这样一来，笔记在 iPad 做好以后，你可以使用不同的设备随时查看，例如可以在碎片时间上使用 iPhone 直接阅读。这对一些需要随时记忆的学科有很大的帮助。</p>

<p>而 GoodNotes 5 还支持导入 PDF，所以很多时候我们可以直接把对应的课件直接导入使用。</p>

<h3 id="toc_15">利用好分屏功能</h3>

<p>从 iOS 13 开始 iPad 已经有了一个非常系统的分屏系统。这些分屏操作虽然看起来相对复杂，但是只要尝试几次就可以尽数掌握。</p>

<p>而且这两款笔记软件都对 Apple 的生态支持非常友好，只要系统层级上有什么好的功能就会立刻跟进，比如 GoodNotes 5 甚至是直接支持在软件内直接分屏不同的笔记，这样可以非常方便的让自己对照使用。</p>

<p>分屏的方式也非常简单，只要按住对应的软件向一侧滑动即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122258.jpg" alt="img"/></p>

<p>除了分屏以外，还可以使用悬浮窗口。也就是可以让某一个软件，像是一个 iPhone 一样直接悬浮在界面上。</p>

<p>之所以使用 iPhone 这个词，不仅仅是因为显示面积大小，还有操作方式。因为你完全可以把这个窗口理解为一个 iPhone 的多任务方式。</p>

<p>你可以直接多个软件一起堆叠，然后使用下面的触控栏进行切换，向上滑动还可以直接进入多任务直接选择的界面，非常方便。这种悬浮窗口对于「即时」需要的软件很有用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122259.jpeg" alt="img"/></p>

<p>比如我们想要向笔记内导入一些文件或者是照片，就可以直接把「文件」应用或者是「照片」应用直接悬浮在上面，直接在使用拖拽即可。</p>

<h3 id="toc_16">使用套索工具</h3>

<p>套索工具也是一个两款软件中 ，都具有并且使用频率很高的软件。套索工具最大的用处就是「重构笔记」。当我们在课堂上记录笔记，只能按照老师讲解的时间线。</p>

<p>但是可能在课后总结的时候，你需要对这些知识进行梳理和归纳。此时只需要使用套索工具，就可以自由的让不同区域的笔记自由移动。当然，这对一些对排版有要求的用户也是个关键功能。</p>

<h3 id="toc_17">利用模版和捷径</h3>

<p>对于不同学科有时候需要的笔记是不同的，最简单的笔记的线条就有着不同的用途。所以你可以实现制作好对应的模版，这样在使用的时候不需要再花时间进行自定义。</p>

<p>不仅如此，如果我们可以配合上一个捷径功能，例如设置对应的时间打开固定的笔记本。这样在每次对应课程开始的时候就可以直接进入记笔记的状态。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122300.png" alt="img"/></p>

<h3 id="toc_18">最快的记录方式</h3>

<p>如果遇到相对突发的笔记需求，iPad 记笔记还提供了一个「隐藏杀手」功能，这就是双击屏幕直接进入备忘录笔记页面。其实 Apple 本身的备忘录就已经是一个很强大而且免费的记笔记软件了。只不过功能相对的没有那么丰富。</p>

<p>但是如果遇到紧急情况，需要立刻开始记笔记，可以直接使用 Apple Pencil 双击屏幕立刻开始，就省去了解锁点击软件的麻烦。但此功能需要设置，在下面的菜单中：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122301.png" alt="img"/></p>

<h3 id="toc_19">保存网页资料</h3>

<p>如果你在网页中遇到很多非常有用的知识，其实截图保存是很傻的一种方式。在 Safari 中，其实可以直接把网页直接整个保存为一个 PDF 文件，然后这个 PDF 文件就可以导入到笔记中进行学习。</p>

<p>一般来说，建议可以在 GoodNotes 5 中给每一个学科都设立一个文件夹。然后文件夹里再新建两个文件夹，一个是专门记笔记，一个是专门收集这些资料。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122302.png" alt="img"/></p>

<h2 id="toc_20">利用缩略图</h2>

<p>在 GoodNotes 5 中，我们可以对于完成的笔记进行充分的整理。这其中缩略图有着非常重要的作用。</p>

<p>首先我们可以通过直接点击界面中的按钮进入缩略图界面，缩略图界面可以让我们从全局掌控笔记内容。并且在这个页面还有着非常丰富的功能选择。</p>

<p>例如我们可以使用选择不同的缩略图种类，比如可以直接只显示收藏夹。我们在记笔记的时候，对于重要知识点可以进行收藏，这样以后可以直接在收藏夹中直接看到这些重点知识。</p>

<p>或者也可以直接观看大纲，对于一些有层级的文件来说好用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122303.png" alt="img"/></p>

<p>当然，我们还可以直接从全局的角度「操作笔记」，比如移动位置，或者是在不同页面的前后直接插入新的笔记丰富内容。</p>

<h3 id="toc_21">绘制形状</h3>

<p>绘制不同的形状对于一些理科科目来说可以说很刚需。最直接的就是点击软件里的对应形状标志。</p>

<p>但是也有快捷的方式，两款软件只要在绘制以后停留一段时间就可以立刻把刚才的绘制变为「形状」，比如把你绘制的歪歪扭扭的线变为直线。</p>

<h3 id="toc_22">真实需求：作答试卷</h3>

<p>如开头所说，很多学生会获得一些电子作业。有的直接是 PDF 文档，有的可能是 Word 文档。</p>

<p>但是不管什么文档，都可以使用对应的打开软件制作为 PDF 文件，然后把 PDF 文档直接导入到 GoodNotes 5 之中，直接可以在对应的空白处作答。</p>

<p>作答以后，直接再用 PDF 的形式导出然后分享给老师即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122304.gif" alt="img"/></p>

<p>这里特别分享，家长可以使用限制模式让孩子在使用 iPad 做作业的界面时只能在作业界面。</p>

<p>这个功能可以在辅助功能中打开，这对一些自控能力很差的孩子来说，很有帮助。有助于集中他们的注意力。</p>

<h3 id="toc_23">特殊需求：设置用笔姿势</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122225.jpeg" alt="img"/></p>

<p>每个人写字的姿势是千变万化的，为了更好的捕捉你的书写，在 GoodNotes 5 中是可以设置不同的手写姿势的。</p>

<p>所以即使是「左手」写字，斜着写字都可以有着对应的选择，虽然这是一个大众忽略的需求，但是有就意味着对那些小众用户是个「关键功能」。</p>

<h3 id="toc_24">使用免打扰和飞行模式</h3>

<p>很多人认为使用 iPad 记笔记很「危险」。因为 iPad 本身是一个太适合「娱乐」的工具，看电影、玩游戏都是它的强项，所以为了避免干扰，如果是在使用 iPad 学习时，我一般都会直接打开飞行模式或者是免打扰。</p>

<p>如果你需要不断的查资料，那么飞行模式可能会断网。但是免打扰模式，最好是一定打开，这样就可以屏蔽掉所有乱七八糟的通知。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200509122217.jpeg" alt="img"/></p>

<p>不过话说回来，说 iPad 记笔记容易分心的人，好像他们在记笔记的时候没有刷手机一样。毕竟，还是人本身的自控力更重要。</p>

<p>归根到底，iPad 记笔记是一种学习的工具，不要因为过于注重工具而本末倒置。尤其是我经常碰到一些人买一个软件都纠结几天，而这两款软件的差价也才十几块而已。</p>

<p>当然，没有 iPad ，一样可以学好。但是有 iPad，是学的更方便，毕竟人生苦短，多出来的时间，可以做更多的事。</p>

<h2 id="toc_25">尾声</h2>

<p>在以前，我一直认为 iPad 记笔记仅仅是某一类人的选择。但是随着疫情的出现，我们惊讶地发现，当我们的教育、工作需要转为线上时，我们传统的「纸笔」已经完全无法运转。</p>

<p>尤其是当我看到家长用保鲜膜代替纸张覆盖在 iPad 上写作业作为一个搞笑视频在社交网络发酵时，我却笑不出声。因为其实今天已经有了非常好的数字笔记体验，而很多人却因为「偏见」的原因无法接受，导致方法不够普及。</p>

<p>所以，如果从这个角度来看，iPad 系列作为纸笔的现代化演绎，将会和传统 PC 一样，成为人类未来工具的重要一环。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144732.html">
                
                  <h1>json.dumps与json.dump的区别 json.loads与json.load的区别</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>json.dumps是将一个Python数据类型列表进行json格式的编码解析，<br/>
示例如下：</p>

<pre class="line-numbers"><code class="language-ruby">&gt;&gt;&gt; import json #导入python 中的json模块
&gt;&gt;&gt; l = [‘iplaypython’,[1,2,3], {‘name’:’xiaoming’}] #创建一个l列表
&gt;&gt;&gt; encoded_json = json.dumps(l) # 将l列表，进行json格式化编码
&gt;&gt;&gt; print repr(l)
&gt;&gt;&gt; print encoded_json #输出结果
</code></pre>

<p>这样我们就将一个list列表对象，进行了json格式的编码转换。</p>

<p>解码python json格式，可以用这个模块的json.loads()函数的解析方法，<br/>
示例如下：</p>

<pre class="line-numbers"><code class="language-ruby">&gt;&gt;&gt; decode_json = json.loads(encoded_json)
&gt;&gt;&gt; print type(decode_json) #查看一下解码后的对象类型
&gt;&gt;&gt; print decode_json #输出结果
</code></pre>

<p>将python json格式解码成Python数据风格</p>

<p>json.dump和json.dumps很不同，json.dump主要用来json文件读写，和json.load函数配合使用。<br/>
json.dump(x,f)，x是对象，f是一个文件对象，这个方法可以将json字符串写入到文本文件中。</p>

<pre class="line-numbers"><code class="language-kotlin">import json
data = [{&quot;a&quot;:&quot;aaa&quot;,&quot;b&quot;:&quot;bbb&quot;,&quot;c&quot;:[1,2,3,(4,5,6)]},33,&#39;tantengvip&#39;,True]
data2 = json.dumps(data)
print(data2)
f = open(&#39;./tt.txt&#39;,&#39;a&#39;)
json.dump(data2,f)
</code></pre>

<p>这样就生成了一个tt.txt文件，保存了json格式的数据。dumps还提供pritty print，格式化的输出。</p>

<p>json.load加载json格式文件 下面是从txt文件中读取了json数据。</p>

<pre class="line-numbers"><code class="language-bash">f = open(&#39;./tt.txt&#39;,&#39;r&#39;)
hehe = json.load(f)
print(hehe)
</code></pre>

<p>总结：<br/>
json.dumps : dict转成str json.dump是将python数据保存成json</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15838967255217.html">
                
                  <h1>Linux vim 编辑器的神级配置 vimrc</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">使用的配置</h2>

<pre class="line-numbers"><code class="language-linux">https://github.com/amix/vimrc
</code></pre>

<h2 id="toc_1">安装很简单</h2>

<pre class="line-numbers"><code class="language-linux">git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime
sh ~/.vim_runtime/install_awesome_vimrc.sh
</code></pre>

<h2 id="toc_2">ack 插件</h2>

<p>常用命令</p>

<pre class="line-numbers"><code class="language-linux">系统需要安装 ack-grep, ubuntu安装命令：sudo apt-get install ack-grep
</code></pre>

<ol>
<li>全局查找文件(ctrlp插件)<br/>
  <code>ctrl + f</code>  --打开全局文件搜索面板<br/>
  <code>Esc</code> --退出全局文件搜索面板</li>
<li>tab(标签)相关<br/>
  <code>gt</code> --后一个标签<br/>
  <code>gT</code> --前一个标签<br/>
  <code>num</code> + gt --跳转至第num个标签<br/>
  <code>,tl</code> --上一次的标签<br/>
  <code>:q</code> --关闭标签<br/>
  <code>:Te</code> --新建标签，并打开当前文件目录<br/>
  <code>,tn</code> --新建空白标签</li>
<li>目录树(NERD_tree插件)<br/>
  <code>,nn</code> --打开目录树<br/>
  <code>,nn</code> --关闭目录树</li>
<li>窗口相关<br/>
  <code>ctrl + w + q</code> --关闭窗口<br/>
  <code>:q</code> --关闭窗口，窗口只有一个tab的情况<br/>
  <code>ctrl + w + w</code> --切换窗口<br/>
  <code>:sp</code> --竖直方向上拆分当前窗口<br/>
  <code>:vsp</code> --水平方向上拆分当前窗口</li>
<li>如何打开一个工程<br/>
  在某个工程的根目录下输入打开vim，则该vim窗口的文件操作默认为整个工程，比如全局搜索文件或字段</li>
<li>全局搜索字段(ack插件)<br/>
  <code>,g</code> --打开全局字段搜索面板，默认大小写敏感，-i 不区分大小写，-w 全词匹配<br/>
  <code>q</code> --退出全局字段搜索面板</li>
<li>当前文件所在的目录<br/>
  <code>:E</code> --打开当前目录，一般用于切换当前目录的文件<br/>
  <code>:Te</code> --新建标签并打开当前目录，一般用于打开当前目录下的其它文件<br/></li>
<li>查看最近打开的文件列表<br/>
  <code>,f</code> --打开面板<br/>
  <code>q</code> --退出面板</li>
<li>当前文件下搜索<br/>
  <code>*</code>--按下即可搜索光标所在的单词或当前选中的内容，不区分大小写<br/>
  <code>gd</code> --光标移动至单词，按下即可搜索该单词，区分大小写<br/>
  <code>/</code> --输入单词向下搜索<br/>
  <code>?</code> --输入单词向上搜索，一般用于查log，配合G跳转至文件底部使</li>
<li>显示行修改标志<br/>
  <code>,d</code> --显示与不显示逐一切换</li>
<li>光标停留的位置记录<br/>
  <code>ctrl + o</code> --上一个时间点光标停留的位置<br/>
  <code>ctrl + i</code> --下一个时间点光标停留的位置</li>
<li>文件刷新，即重新载入<br/>
  <code>:e</code> --重新载入<br/>
  <code>:e!</code> --放弃当前修改，强制重新载入<br/>
  <code>:e file_dir</code> --载入 file_dir 路径下的某个文件</li>
<li>粘贴0号寄存器的内容<br/>
  <code>ctrl + r + 0</code> --比如y复制选中的内容后粘贴到命令输入框</li>
<li>折叠命令<br/>
  <code>za</code> --打开或关闭当前折叠<br/>
  <code>zM</code> --关闭所有折叠<br/>
  <code>zR</code> --打开所有折叠</li>
<li>跳出双引号继续编辑<br/>
  有些时候输入完字符串需要移动光标至双引号外继续输入<br/>
  <code>&quot;</code> --在 &quot; 处输入 &quot; ，即可将光标跳转至当前双引号之外</li>
<li>文件路径<br/>
  <code>:f</code> --查看当前文件路径</li>
<li>变量名补全<br/>
  <code>ctrl + n</code> --自动补全变量名，再次输入匹配下一个</li>
<li>代码块补全，只需输入部分代码，然后按tab键<br/>
  lua为例：<br/>
  <code>if + tab</code> --if代码块<br/>
  <code>forp + tab</code> --for i,v in pairs() do end 代码块<br/>
  <code>fori + tab</code> --for i,v in ipairs() do end 代码块<br/>
  <code>fun + tab</code> --函数模板代码块</li>
<li>代码检错<br/>
  <code>:ALEToggle</code> --启动检错</li>
<li>代码注释<br/>
  <code>gcc</code> --注释当前行，再次输入则撤销注释<br/>
  <code>num + gcc</code> --注释num行<br/>
  <code>gc</code> --注释选中部分</li>
<li>取消搜索高亮<br/>
  <code>:nohl</code></li>
<li>多窗口显示<br/>
  <code>:sp</code> --水平切分窗口<br/>
  <code>:vsp</code> --垂直切分窗口<br/>
## vim 编辑相关</li>
<li>范围命令
<code>w</code> --光标所在的位置至单词末尾的部分或一个单词，包括单词后的空格
<code>iw</code> --光标所在位置的一个单词，不包括单词后的空格
<code>aw</code> --光标所在位置的一个单词，包括单词后的空格
<code>b</code> --与 w 相反
<code>e</code> --end of word，至单词结尾
<code>$</code> --至当前行结尾
<code>0</code> --至当前行开头</li>
<li>操作命令
<code>d</code>: delete
<code>dd</code> --删除当前行
<code>diw</code> --删除光标所在单词
<code>dw</code> --正向删除一个单词（光标后的部分）
<code>db</code> --逆向删除一个单词（光标前的部分）
<code>d$</code> --删除光标所在的位置至本行末尾
<code>d0</code> --删除光标所在的位置至本行首部
<code>c</code>: change, 与 d 的区别只在于操作后进入插入状态
<code>y</code>: yank, 与 d 的区别在于跟范围命令组合后全部为复制操作</li>
<li>操作命令（少与范围命令组合）
<code>~</code> --大小写字母转换
<code>s</code> --删除一个字母，删除后进入插入模式
<code>x</code> --删除一个字母，删除后处于命令模式
<code>r</code> --即replace，修改替换一个字母，并且替换过后仍然处于命令模式
<code>R</code> --修改替换无限多个在字母</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144677.html">
                
                  <h1>Linux实用工具-vnc</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>VNC服务配置概述</p>

<p>VNC (Virtual Network Computing)是虚拟网络计算机的缩写。VNC 是一款优秀的远程控制工具软件，是基于UNIX和Linux操作系统的免费的开源软件（也可以支持Windows等操作系统），远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美。本文简单介绍在Ubuntu的Linux发行版下VNC服务的配置和使用。</p>

<p>假设系统信息如下：</p>

<pre class="line-numbers"><code class="language-css">服务端：Ubuntu 11.04 \n \l
客户端：Ubuntu 11.04 \n \l
</code></pre>

<p>其他系统中配置的过程和原理大致类似。</p>

<h1 id="toc_0">1、服务端</h1>

<h2 id="toc_1">(1)安装vnc服务程序</h2>

<pre class="line-numbers"><code class="language-bash">#sudo apt-get install vnc4server
</code></pre>

<p>这里，有可能还需要安装&quot;vnc4-common&quot;。</p>

<h2 id="toc_2">(2)设置连接vnc服务的密码</h2>

<pre class="line-numbers"><code class="language-bash">#vncpasswd
</code></pre>

<p>这样会提示你输入密码，客户通过这个密码来进行连接，这里密码假设为12345678。</p>

<h2 id="toc_3">(3)配置启动桌面</h2>

<h3 id="toc_4">配置方法1</h3>

<pre class="line-numbers"><code class="language-bash">#cp /etc/X11/Xsession ~/.vnc/xstartup
</code></pre>

<p>这里配置的是客户连接之后，在客户端显示什么样的图形桌面。这里直接使用vnc服务器所在系统的桌面环境配置了。如果不进行配置，那么客户端登陆的时候就只能启动默认的窗口管理器非常简单不好用。</p>

<h3 id="toc_5">配置方法2</h3>

<pre class="line-numbers"><code class="language-bash">#vim ~/.vnc/xstartup
</code></pre>

<p>修改内容如下：</p>

<pre class="line-numbers"><code class="language-bash">#!/bin/sh
# Uncomment the following two lines for normal desktop:
unset SESSION_MANAGER
#exec /etc/X11/xinit/xinitrc
exec /etc/X11/Xsession
[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup
[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources
</code></pre>

<p>这里，注意如果用&quot;exec /etc/X11/xinit/xinitrc&quot;替代&quot;exec /etc/X11/Xsession&quot;则需要修改&quot;xinitrc&quot;文件的权限，如：&quot;chmod 755 /etc/X11/xinit/xinitrc&quot;，否则客户端无法启动图形桌面环境。</p>

<h2 id="toc_6">(4)启动vnc服务</h2>

<pre class="line-numbers"><code class="language-css">#vncserver :1
</code></pre>

<p>这样在1号窗口桌面上面启动vncserver，客户端会根据这个号码来连接指定桌面的窗口。</p>

<h2 id="toc_7">(5)修改系统按键映射</h2>

<pre class="line-numbers"><code class="language-bash">#gconf-editor
</code></pre>

<p>找到“Apps-&gt;Metacity-&gt;Global keybingdings”中的“show desktop”，将其默认值D改为D。</p>

<p>这里，客户端已经可以通过vnc远程登陆服务器，但是在客户端的vnc远程桌面客户程序窗口下按下字母”d”时，会被错误的当做返回桌面的快捷方式(Super+d)，导致”d”无法输入，所以需要用这里的方式修改。而产生这个现象的原因是：ubuntu 11.04里把Windows键定义为Super键，当客户端通过客户端软件远程登陆到这个server的时候。</p>

<h2 id="toc_8">(6)终止指定桌面号上的vnc服务</h2>

<pre class="line-numbers"><code class="language-css">#vncserver -kill :1
</code></pre>

<p>这里使用&quot;:1&quot;分配桌面号码，并且将相应桌面上面的vncserver终止。</p>

<p>更多信息参见 <code>man vncserver</code> 。</p>

<h1 id="toc_9">2、客户端</h1>

<p>(1)安装一个vnc客户端：</p>

<pre class="line-numbers"><code class="language-bash">#apt-get install gvncviewer
</code></pre>

<p>这里，也可以安装其他客户端程序&quot;xvnc4viewer&quot;来替代gvncviewer等。</p>

<p>(2)连接指定机器上面的指定桌面号：</p>

<pre class="line-numbers"><code class="language-css">#gvncviewer 10.1.10.39:1
</code></pre>

<p>当然，这里的机器（也就是前面安装vnc服务的机器10.1.10.39）上面应该事先启动好&quot;vncserver :1&quot;。</p>

<p>输入密码之后，至此，vnc客户端所在的机器便可以通过vnc实现对vnc服务所在机器进行远程桌面控制了。</p>

<h1 id="toc_10">3、其他</h1>

<p>待添加。</p>

<p>参考资料</p>

<ul>
<li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaike.baidu.com%2Fview%2F160932.htm">http://baike.baidu.com/view/160932.htm</a></li>
<li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fhuangro.iteye.com%2Fblog%2F621608">http://huangro.iteye.com/blog/621608</a></li>
</ul>

<p>以上只是对vnc配置和使用的简单描述，更多信息以及其中可能会有的错误的纠正，可通过下述方式联系，谢谢。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628522.html">
                
                  <h1>Linux系统/etc目录和文件的介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Linux目录结构特点</strong></p>

<ol>
<li>linux系统的所有目录是一个有层次的倒着的梳妆目录结构。根是所有目录的顶点，linux目录一切从根开始。</li>
<li>不听目录下的数据可以跨越不同的磁盘分区火不同的磁盘设备，设备可以随意挂载到任意目录上使用。</li>
<li>所有的目录的是安装一定类型有龟裂的组织和命名的。</li>
<li>没有挂载到目录上的磁盘，相当于没有门和串户的监狱，不能被使用。磁盘等设备de需要挂载菜能正常使用。</li>
<li>盖章点是磁盘访问的人口，是一个目录</li>
<li>相对路径与绝对路径</li>
</ol>

<p><strong>Linux目录结构</strong></p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# tree -L 1 /
/
├── bin             #普通用户的二进制命令
├── boot            #系统内核及引导程序目录
├── dev             #设备文件目录
├── etc             #软件配置和启动程序目录
├── home            #普通用户家目录
├── lib             #库文件目录(命令、软件)
├── lib64           #64位库文件目录(命令、软件)
├── lost+found      #系统崩溃数据存放的目录
├── media
├── mnt             #设备临时挂载目录
├── opt             #第三方程序
├── proc            #操作系统进程和内核信息目录
├── root            #root家目录
├── sbin            #系统管理员命令
├── selinux         
├── srv
├── sys
├── tmp             #文件临时存放目录(回收站)
├── usr             #应用程序目录
└── var             #日志目录
#查看命令的路径
[root@test ~]# which ls
alias ls=&#39;ls --color=auto&#39;
    /bin/ls
</code></pre>

<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>/bin</td>
<td>该目录为binaries,是常用二进制命令所在的目录。列入：ls、cp、mkdir、rm等命令；/bin目录和/usr/bin类似</td>
</tr>
<tr>
<td>/boot</td>
<td>Linux的内核级系统引导程序所需的文件目录，安装系统分区的时候一般单独分一个boot分区。</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件目录，比如声卡、磁盘、光驱等等外接设备。</td>
</tr>
<tr>
<td>/etc</td>
<td>(1)二进制软件安装包(yum,rpm)等的配置文件默认路径，例如:/etc/exports、/etc/fstab、/etc/resolv.conf (2)服务启动命令存放的目录，主要在/etc/init.d/下。例如：/etc/init.d/sshd、/etc/init.d/iptables</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录默认数据库存放目录</td>
</tr>
<tr>
<td>/lib</td>
<td>启动系统和运行命令所需要的共享库文件和内核模块存放目录，分为/lib和/lib64两种。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题，可能会有文件被移到这个目录中，可能需要手工方式修复，移到文件到原来的位置上。</td>
</tr>
<tr>
<td>/mnt</td>
<td>一般是用于临时挂载存储设备的挂载点，比如有cdrom，u盘等目录。直接插入光驱无法使用，需要先挂载后使用。</td>
</tr>
<tr>
<td>/opt</td>
<td>表示的是可选择的意思，有邪软件包会被安装在这里，也就是自定义软件包。我们自己编译的软件包，就可以安装在这个目录；通过源码包安装的软件，可以通过./configure --prefix=/opt/指定目录。</td>
</tr>
<tr>
<td>/proc</td>
<td>操作系统运行时，进程信息及内核信息(cpu、硬盘信息、内存信息)存放在这里。/proc目录是虚拟文件系统的挂载点，proc并不是真正的文件系统，它的定义可以参见/etc/fstab。系统运行很多信息都在这个目录下。 /proc/loadavg #系统负载信息 /proc/meminfo #系统内存信息 /proc/cpuinfo #系统CPU信息 /proc/mounts #系统挂载信息</td>
</tr>
<tr>
<td>/root</td>
<td>Linux超级权限用户root的加目录:root类似win32管理员admininstrator</td>
</tr>
<tr>
<td>/sbin</td>
<td>大多是涉及系统管理的命令存放，是超级权限用户root的可执行命令存放地，这个目录和/usr/X11R6/sbin或/usr/loacl/sbin目录是相似的;系统级命令，一般最好要通过sudo让普通用户执行这些命令，常见命令有fdisk、reboot、fsck、halt</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录，有时用户运行程序时候，会产生临时文件。/tmp就用来存放临时文件的，权限比较特殊。/var/tmp目录和这个目录相似，这个目录可以被用作Linux系统的回收站使用。</td>
</tr>
<tr>
<td>/usr</td>
<td>这是系统存放程序的目录，比如命令，帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux官方提供的软件包时，安装在这里。 /user/local：默认软件安装目录 /usr/src:长袖源码目录</td>
</tr>
<tr>
<td>/var</td>
<td>日志目录</td>
</tr>
</tbody>
</table>

<hr/>

<p><strong>Linux系统重要文件</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align: center">网卡配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0 #第一块网卡逻辑设备名，第二块为eth1
HWADDR=00:0c:29:6a:a3:b4 #以太网硬件地址MAC地址
TYPE=Ethernet #上网类型，目前基本上是以太网
UUID=282f8f61-2b18-4cdb-8ba5-62c8131abd20 #通用唯一识别码
ONBOOT=yes  #开机启动激活网卡设备yes(启动) no(不启动)
NM_CONTROLLED=yes #是否通过networkmanager管理网卡设备
BOOTPROTO=none  #启动协议，获取配置方式，有none|bootp|dhcp 三个选项
IPADDR=10.0.0.7 #IP地址
NETMASK=255.255.255.0 #子网掩码
DNS2=202.106.0.20   #DNS2
GATEWAY=10.0.0.2    #网关
DNS1=10.0.0.2       #DNS1
USERCTL=no          #是否支持用户控制
PEERDNS=yes         #网卡配置DNS 会覆盖/etc/resolv.conf文件的DNS
IPV6INIT=no         #是否支持IPv6
</code></pre>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/resolv.conf</td>
<td style="text-align: center">系统DNS客户端配置文件</td>
</tr>
</tbody>
</table>

<p>DNS,全称Domain Name System，一个网站运行中起到至关重要的作用，它的主要作用是负责吧网站域名解析为对应的IP地址。</p>

<p>DNS系统解析功能：</p>

<ul>
<li> (1)DNS 系统负责A记录解析，就是域名到IP。</li>
<li> (2)设置CNAME别名记录，这别名解析功能常被CDN加速服务商应用</li>
<li> (3)设置MX邮件记录，这个记录功能，在购买或搭建邮件服务时会经常被用到</li>
<li> (4)设置PTR 记录，反向解析，即吧IP地址解析为对应域名和A记录的解析相反，邮寄服务等业务会用到</li>
</ul>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/resolv.conf

nameserver 10.0.0.2
nameserver 202.106.0.20
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network</td>
<td style="text-align: center">主机名配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test
</code></pre>

<p>修改方法：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test1 #永久修改
[root@test ~]# hostname test1 临时修改
#企业环境永久修改生效需要重启服务器基本的是永久加上临时二个方法配合使用需要操作两次，为了不重启
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.local</td>
<td style="text-align: center">存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>/etc/rc.local是用于存放开机自启动程序命令的文件(chkconfig常用来管理yum/rpm安装的程序服务的开机自启动)如果是开发的自己程序需要开机启动命令放入/etc/rc.local来实现开机自启动，Linux开机会吧/etc/rc.local里面的内容全部执行一遍。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/hosts</td>
<td style="text-align: center">局域网或者本地DNS解析工具</td>
</tr>
</tbody>
</table>

<p>应用场景：</p>

<ol>
<li>域名对应服务所在的服务器出现IP变化时候</li>
<li>进行本地测试</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/fstab</td>
<td>配置开机实现设备自动挂载程序命令的文件</td>
</tr>
</tbody>
</table>

<p>添加新的磁盘后实现开机自动挂载设备：cat /etc/fstab共六列如下：</p>

<p>例：sysfs /sys sysfs defaults 0 0</p>

<ol>
<li>第一列sysfs (挂载的设备名称)</li>
<li>第二列/sys(挂载的目录)</li>
<li>第三列sysfs(挂载的文件系统格式)</li>
<li>第四列defaults(挂载参数)</li>
<li>第五列0(是否备份:0为不备份，1为备份)</li>
<li>第六列0(是否开机做磁盘检测，0为不检测数字1,2的为检测磁盘)，工作场景通常的设为了，为了避免重启无法启动。</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.loacl</td>
<td>存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>企业中主要应用：脚本和自主开发程序启动命令存放处，实现开机程序自动启动和运行。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/inittab</td>
<td>系统运行级别的配置文件</td>
</tr>
</tbody>
</table>

<p>0 - halt (Do NOT set initdefault to this)： (<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%85%B3%E6%9C%BA%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{关机模式}"/>)</p>

<p>1 - Single user mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{单用户模式}"/>)</p>

<p>2 - Multiuser, without NFS (The same as 3, if you do not have networking):(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FNFS%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{没有网络文件系统NFS的多用户模式}"/>)</p>

<p>3 - Full multiuser mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{完整的多用户模式}"/>)</p>

<p>4 - unused：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%9C%AA%E4%BD%BF%E7%94%A8%7D" alt="\color{green}{未使用}"/>)</p>

<p>5 - X11：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{桌面模式}"/>)</p>

<p>6 - reboot (Do NOT set initdefault to this)：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E9%87%8D%E5%90%AF%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{重启模式}"/>)</p>

<p>查看当前的运行级别：runlevel</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# runlevel 
N 3
#N是上一次运行级别，3是当前运行级别
</code></pre>

<p>切换运行级别：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# init 5
[root@test ~]# runlevel 
3 5
#init 命令接后面的数字级别
</code></pre>

<p>开机启动流程图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234025.png" alt="img"/></p>

<p>Linux系统启动配置文件：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/grub.conf 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda3
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.32-754.30.2.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-754.30.2.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-754.30.2.el6.x86_64.img
title CentOS 6 (2.6.32-696.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-696.el6.x86_64.img
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile及/etc/bashrc(~/.bashrc)</td>
<td>配置系统的环境变量/别名文件</td>
</tr>
</tbody>
</table>

<p>企业环境设置案例：</p>

<pre class="line-numbers"><code class="language-shell">#环境变量设置：
vim /etc/profile

#set java environment
JAVA_HOME=/usr/local/java/jdk1.8.0_161
JRE_HOME=$JAVA_HOME/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
#重新加载/etc/profile文件，让配置生效
source /etc/profile
#测试安装是否成功
java -version

#系统别名设置:
# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
#让系统别名永久生效，需要配置到的文件
</code></pre>

<p>环境变量文件生效顺序图：/etc/bashrc &gt; ~/.bashrc &gt; ~/bash_profile &gt; /etc/profile</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234032.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile.d</td>
<td>用户登录后执行的脚本所在目录</td>
</tr>
</tbody>
</table>

<ol>
<li>在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，而这些脚本文件是用来设置一些变量和运行一些初始化过程的。其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</li>
<li>/etc/profile.d 下的脚本之所以能自动执行，是因为在/etc/profile 中有一个for循环语句来调用这些脚本。</li>
</ol>

<pre class="line-numbers"><code class="language-shell">vi /etc/profile
# /etc/profile
 
for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r &quot;$i&quot; ]; then
        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then
            . &quot;$i&quot;
        else
            . &quot;$i&quot; &gt;/dev/null
        fi
    fi
done
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/issue和/etc/issue.net</td>
<td>配置在用户登录终端前显示信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
.............................................................................
[root@test ~]# cat /etc/issue.net 
CentOS release 6.10 (Final)
Kernel \r on an \m
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/init.d</td>
<td>软件启动和程序所在的目录</td>
</tr>
</tbody>
</table>

<p>/etc/init.d目录在Linux系统中可是大名鼎鼎。它只负责一件事情，但却涉及到全系统。它包含系统中各种服务的start/stop脚本，从acpid到x11-common，其重要性可见一斑。在/etc/init.d的可执行程序的优先级会高于/etc/systemd/system/下的service文件，如果同时存在的话。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/motd</td>
<td>配置用户登录系统之后显示提示内容的文件</td>
</tr>
</tbody>
</table>

<p>配置案例：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/motd 
[root@test ~]# vim /etc/motd
test computer
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234041.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/redhat-release</td>
<td>声明Red Hat版本和名称信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/redhat-release 
CentOS release 6.10 (Final)
</code></pre>

<p>禁止转载，如需转载请通过简信或评论联系作者。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177589969474.html">
                
                  <h1>Linux系统/etc目录和文件的介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Linux目录结构特点</strong></p>

<ol>
<li>linux系统的所有目录是一个有层次的倒着的梳妆目录结构。根是所有目录的顶点，linux目录一切从根开始。</li>
<li>不听目录下的数据可以跨越不同的磁盘分区火不同的磁盘设备，设备可以随意挂载到任意目录上使用。</li>
<li>所有的目录的是安装一定类型有龟裂的组织和命名的。</li>
<li>没有挂载到目录上的磁盘，相当于没有门和串户的监狱，不能被使用。磁盘等设备de需要挂载菜能正常使用。</li>
<li>盖章点是磁盘访问的人口，是一个目录</li>
<li>相对路径与绝对路径</li>
</ol>

<p><strong>Linux目录结构</strong></p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# tree -L 1 /
/
├── bin             #普通用户的二进制命令
├── boot            #系统内核及引导程序目录
├── dev             #设备文件目录
├── etc             #软件配置和启动程序目录
├── home            #普通用户家目录
├── lib             #库文件目录(命令、软件)
├── lib64           #64位库文件目录(命令、软件)
├── lost+found      #系统崩溃数据存放的目录
├── media
├── mnt             #设备临时挂载目录
├── opt             #第三方程序
├── proc            #操作系统进程和内核信息目录
├── root            #root家目录
├── sbin            #系统管理员命令
├── selinux         
├── srv
├── sys
├── tmp             #文件临时存放目录(回收站)
├── usr             #应用程序目录
└── var             #日志目录
#查看命令的路径
[root@test ~]# which ls
alias ls=&#39;ls --color=auto&#39;
    /bin/ls
</code></pre>

<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>/bin</td>
<td>该目录为binaries,是常用二进制命令所在的目录。列入：ls、cp、mkdir、rm等命令；/bin目录和/usr/bin类似</td>
</tr>
<tr>
<td>/boot</td>
<td>Linux的内核级系统引导程序所需的文件目录，安装系统分区的时候一般单独分一个boot分区。</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件目录，比如声卡、磁盘、光驱等等外接设备。</td>
</tr>
<tr>
<td>/etc</td>
<td>(1)二进制软件安装包(yum,rpm)等的配置文件默认路径，例如:/etc/exports、/etc/fstab、/etc/resolv.conf (2)服务启动命令存放的目录，主要在/etc/init.d/下。例如：/etc/init.d/sshd、/etc/init.d/iptables</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录默认数据库存放目录</td>
</tr>
<tr>
<td>/lib</td>
<td>启动系统和运行命令所需要的共享库文件和内核模块存放目录，分为/lib和/lib64两种。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题，可能会有文件被移到这个目录中，可能需要手工方式修复，移到文件到原来的位置上。</td>
</tr>
<tr>
<td>/mnt</td>
<td>一般是用于临时挂载存储设备的挂载点，比如有cdrom，u盘等目录。直接插入光驱无法使用，需要先挂载后使用。</td>
</tr>
<tr>
<td>/opt</td>
<td>表示的是可选择的意思，有邪软件包会被安装在这里，也就是自定义软件包。我们自己编译的软件包，就可以安装在这个目录；通过源码包安装的软件，可以通过./configure --prefix=/opt/指定目录。</td>
</tr>
<tr>
<td>/proc</td>
<td>操作系统运行时，进程信息及内核信息(cpu、硬盘信息、内存信息)存放在这里。/proc目录是虚拟文件系统的挂载点，proc并不是真正的文件系统，它的定义可以参见/etc/fstab。系统运行很多信息都在这个目录下。 /proc/loadavg #系统负载信息 /proc/meminfo #系统内存信息 /proc/cpuinfo #系统CPU信息 /proc/mounts #系统挂载信息</td>
</tr>
<tr>
<td>/root</td>
<td>Linux超级权限用户root的加目录:root类似win32管理员admininstrator</td>
</tr>
<tr>
<td>/sbin</td>
<td>大多是涉及系统管理的命令存放，是超级权限用户root的可执行命令存放地，这个目录和/usr/X11R6/sbin或/usr/loacl/sbin目录是相似的;系统级命令，一般最好要通过sudo让普通用户执行这些命令，常见命令有fdisk、reboot、fsck、halt</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录，有时用户运行程序时候，会产生临时文件。/tmp就用来存放临时文件的，权限比较特殊。/var/tmp目录和这个目录相似，这个目录可以被用作Linux系统的回收站使用。</td>
</tr>
<tr>
<td>/usr</td>
<td>这是系统存放程序的目录，比如命令，帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux官方提供的软件包时，安装在这里。 /user/local：默认软件安装目录 /usr/src:长袖源码目录</td>
</tr>
<tr>
<td>/var</td>
<td>日志目录</td>
</tr>
</tbody>
</table>

<hr/>

<p><strong>Linux系统重要文件</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align: center">网卡配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0 #第一块网卡逻辑设备名，第二块为eth1
HWADDR=00:0c:29:6a:a3:b4 #以太网硬件地址MAC地址
TYPE=Ethernet #上网类型，目前基本上是以太网
UUID=282f8f61-2b18-4cdb-8ba5-62c8131abd20 #通用唯一识别码
ONBOOT=yes  #开机启动激活网卡设备yes(启动) no(不启动)
NM_CONTROLLED=yes #是否通过networkmanager管理网卡设备
BOOTPROTO=none  #启动协议，获取配置方式，有none|bootp|dhcp 三个选项
IPADDR=10.0.0.7 #IP地址
NETMASK=255.255.255.0 #子网掩码
DNS2=202.106.0.20   #DNS2
GATEWAY=10.0.0.2    #网关
DNS1=10.0.0.2       #DNS1
USERCTL=no          #是否支持用户控制
PEERDNS=yes         #网卡配置DNS 会覆盖/etc/resolv.conf文件的DNS
IPV6INIT=no         #是否支持IPv6
</code></pre>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/resolv.conf</td>
<td style="text-align: center">系统DNS客户端配置文件</td>
</tr>
</tbody>
</table>

<p>DNS,全称Domain Name System，一个网站运行中起到至关重要的作用，它的主要作用是负责吧网站域名解析为对应的IP地址。</p>

<p>DNS系统解析功能：</p>

<ul>
<li> (1)DNS 系统负责A记录解析，就是域名到IP。</li>
<li> (2)设置CNAME别名记录，这别名解析功能常被CDN加速服务商应用</li>
<li> (3)设置MX邮件记录，这个记录功能，在购买或搭建邮件服务时会经常被用到</li>
<li> (4)设置PTR 记录，反向解析，即吧IP地址解析为对应域名和A记录的解析相反，邮寄服务等业务会用到</li>
</ul>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/resolv.conf

nameserver 10.0.0.2
nameserver 202.106.0.20
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network</td>
<td style="text-align: center">主机名配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test
</code></pre>

<p>修改方法：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test1 #永久修改
[root@test ~]# hostname test1 临时修改
#企业环境永久修改生效需要重启服务器基本的是永久加上临时二个方法配合使用需要操作两次，为了不重启
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.local</td>
<td style="text-align: center">存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>/etc/rc.local是用于存放开机自启动程序命令的文件(chkconfig常用来管理yum/rpm安装的程序服务的开机自启动)如果是开发的自己程序需要开机启动命令放入/etc/rc.local来实现开机自启动，Linux开机会吧/etc/rc.local里面的内容全部执行一遍。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/hosts</td>
<td style="text-align: center">局域网或者本地DNS解析工具</td>
</tr>
</tbody>
</table>

<p>应用场景：</p>

<ol>
<li>域名对应服务所在的服务器出现IP变化时候</li>
<li>进行本地测试</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/fstab</td>
<td>配置开机实现设备自动挂载程序命令的文件</td>
</tr>
</tbody>
</table>

<p>添加新的磁盘后实现开机自动挂载设备：cat /etc/fstab共六列如下：</p>

<p>例：sysfs /sys sysfs defaults 0 0</p>

<ol>
<li>第一列sysfs (挂载的设备名称)</li>
<li>第二列/sys(挂载的目录)</li>
<li>第三列sysfs(挂载的文件系统格式)</li>
<li>第四列defaults(挂载参数)</li>
<li>第五列0(是否备份:0为不备份，1为备份)</li>
<li>第六列0(是否开机做磁盘检测，0为不检测数字1,2的为检测磁盘)，工作场景通常的设为了，为了避免重启无法启动。</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.loacl</td>
<td>存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>企业中主要应用：脚本和自主开发程序启动命令存放处，实现开机程序自动启动和运行。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/inittab</td>
<td>系统运行级别的配置文件</td>
</tr>
</tbody>
</table>

<p>0 - halt (Do NOT set initdefault to this)： (<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%85%B3%E6%9C%BA%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{关机模式}"/>)</p>

<p>1 - Single user mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{单用户模式}"/>)</p>

<p>2 - Multiuser, without NFS (The same as 3, if you do not have networking):(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FNFS%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{没有网络文件系统NFS的多用户模式}"/>)</p>

<p>3 - Full multiuser mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{完整的多用户模式}"/>)</p>

<p>4 - unused：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%9C%AA%E4%BD%BF%E7%94%A8%7D" alt="\color{green}{未使用}"/>)</p>

<p>5 - X11：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{桌面模式}"/>)</p>

<p>6 - reboot (Do NOT set initdefault to this)：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E9%87%8D%E5%90%AF%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{重启模式}"/>)</p>

<p>查看当前的运行级别：runlevel</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# runlevel 
N 3
#N是上一次运行级别，3是当前运行级别
</code></pre>

<p>切换运行级别：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# init 5
[root@test ~]# runlevel 
3 5
#init 命令接后面的数字级别
</code></pre>

<p>开机启动流程图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234025.png" alt="img"/></p>

<p>Linux系统启动配置文件：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/grub.conf 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda3
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.32-754.30.2.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-754.30.2.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-754.30.2.el6.x86_64.img
title CentOS 6 (2.6.32-696.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-696.el6.x86_64.img
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile及/etc/bashrc(~/.bashrc)</td>
<td>配置系统的环境变量/别名文件</td>
</tr>
</tbody>
</table>

<p>企业环境设置案例：</p>

<pre class="line-numbers"><code class="language-shell">#环境变量设置：
vim /etc/profile

#set java environment
JAVA_HOME=/usr/local/java/jdk1.8.0_161
JRE_HOME=$JAVA_HOME/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
#重新加载/etc/profile文件，让配置生效
source /etc/profile
#测试安装是否成功
java -version

#系统别名设置:
# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
#让系统别名永久生效，需要配置到的文件
</code></pre>

<p>环境变量文件生效顺序图：/etc/bashrc &gt; ~/.bashrc &gt; ~/bash_profile &gt; /etc/profile</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234032.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile.d</td>
<td>用户登录后执行的脚本所在目录</td>
</tr>
</tbody>
</table>

<ol>
<li>在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，而这些脚本文件是用来设置一些变量和运行一些初始化过程的。其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</li>
<li>/etc/profile.d 下的脚本之所以能自动执行，是因为在/etc/profile 中有一个for循环语句来调用这些脚本。</li>
</ol>

<pre class="line-numbers"><code class="language-shell">vi /etc/profile
# /etc/profile
 
for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r &quot;$i&quot; ]; then
        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then
            . &quot;$i&quot;
        else
            . &quot;$i&quot; &gt;/dev/null
        fi
    fi
done
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/issue和/etc/issue.net</td>
<td>配置在用户登录终端前显示信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
.............................................................................
[root@test ~]# cat /etc/issue.net 
CentOS release 6.10 (Final)
Kernel \r on an \m
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/init.d</td>
<td>软件启动和程序所在的目录</td>
</tr>
</tbody>
</table>

<p>/etc/init.d目录在Linux系统中可是大名鼎鼎。它只负责一件事情，但却涉及到全系统。它包含系统中各种服务的start/stop脚本，从acpid到x11-common，其重要性可见一斑。在/etc/init.d的可执行程序的优先级会高于/etc/systemd/system/下的service文件，如果同时存在的话。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/motd</td>
<td>配置用户登录系统之后显示提示内容的文件</td>
</tr>
</tbody>
</table>

<p>配置案例：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/motd 
[root@test ~]# vim /etc/motd
test computer
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234041.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/redhat-release</td>
<td>声明Red Hat版本和名称信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/redhat-release 
CentOS release 6.10 (Final)
</code></pre>

<p>禁止转载，如需转载请通过简信或评论联系作者。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15839100648693.html">
                
                  <h1>MAC 安装好后的一些配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">改变vim配色：安装colorscheme</h1>

<blockquote>
<ol>
<li>在当前用户目录 ~/ 下的 .vim 目录(如果没有，mkdir ~/.vim进行新建该目录)。在 ~/.vim/ 下新建一个叫 colors 的目录，将配色方案.vim文件便放到该目录下。</li>
<li>编辑vim的配置文件.vimrc  (vi .vimrc)在其中添加下面2行</li>
</ol>
</blockquote>

<pre class="line-numbers"><code class="language-text">set t_Co=256 
colorscheme desert
</code></pre>

<h1 id="toc_1">使用 Solarized 配色方案的方法</h1>

<pre class="line-numbers"><code class="language-text">$ git clone git://github.com/altercation/solarized.git
</code></pre>

<blockquote>
<ul>
<li>Terminal 的话，在 solarized/osx-terminal.app-colors-solarized 下双击 Solarized Dark ansi.terminal 和 Solarized Light ansi.terminal 就会自动导入两种配色方案 Dark 和 Light 到 Terminal.app 里。</li>
<li>iTerm2 的话，到 solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm 里。</li>
<li>vim </li>
</ul>
</blockquote>

<pre class="line-numbers"><code class="language-text">    $ cd solarized
    $ cd vim-colors-solarized/colors
    $ mkdir -p ~/.vim/colors
    $ cp solarized.vim ~/.vim/colors/
    $ vi ~/.vimrc
    syntax on
    set background=dark
    colorscheme solarized
</code></pre>

<h1 id="toc_2">Mac 访达标题栏显示详细目录</h1>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
killall Finder
</code></pre>

<h1 id="toc_3">禁止.DS_Store生成</h1>

<p>打开 “终端”，执行下列命令，重启Mac生效：</p>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE
</code></pre>

<h1 id="toc_4">恢复.DS_Store生成</h1>

<pre class="line-numbers"><code class="language-text">defaults delete com.apple.desktopservices DSDontWriteNetworkStores
</code></pre>

<h1 id="toc_5">删除现有的.DS_Store</h1>

<blockquote>
<p>对已经生成的文件还需要你手动删除：</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">sudo find / -name &quot;.DS_Store&quot; -depth -exec rm {} \;
</code></pre>

<h1 id="toc_6">Mac Launchpad(启动台）图标大小调整</h1>

<blockquote>
<p>1 、调整每一列显示图标数量，10表示每一列显示10个，比较不错，可根据个人喜好进行设置。 <br/>
<code>defaults write com.apple.dock springboard-rows -int 10</code><br/>
2、调整多少行显示图标数量 <br/>
<code>defaults write com.apple.dock springboard-rows -int 8</code><br/>
3、重置Launchpad<br/>
<code>defaults write com.apple.dock ResetLaunchPad -bool TRUE</code><br/>
4、重启Dock<br/>
<code>killall Dock</code><br/>
恢复默认设置的方法。<br/>
 以下是恢复默认大小的命令（在Terminal执行即可）：</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">defaults write com.apple.dock springboard-rows Default
defaults write com.apple.dock springboard-columns Default
defaults write com.apple.dock ResetLaunchPad -bool TRUE
killall Dock
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16177589969532.html">**用好VSCode这13款插件和8个快捷键**</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025628955.html">1000行MySQL学习笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144586.html">[Chrome浏览器F12开发者工具简单使用]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025629001.html">[Pycharm 常用快捷键]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144704.html">[如何在 Linux 中减少/缩小 LVM 大小（逻辑卷调整）]</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
