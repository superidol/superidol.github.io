<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15998025631113.html">
                
                  <h1>VS Code 代码编辑器入门指南：核心组件与概念</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">什么是代码编辑器</h2>

<p>如果此前对「代码编辑器」没有任何概念，我们可以和文本编辑器（写作工具）进行类比，就是<strong>为了更好更方便进行代码编写开发</strong>的工具。</p>

<p>提到代码编辑器，不少「工龄」较长的程序员第一反应都会是 Notepad++，这款代码编辑器发布于 2003 年并更新至今，非常经典。因为使用惯性和轻量的特点它目前依旧很受欢迎。不过在 2020 年的今天，有更多好用的代码编辑器值得向你推荐。目前比较受欢迎的代码编辑器主要有 <a href="https://code.visualstudio.com/">VS Code</a>、<a href="https://atom.io/">Atom</a> 和 <a href="https://www.sublimetext.com/">Sublime text</a> 。它们各有特点也都有不少死忠粉，新手在初期都可以尝试。</p>

<p>另外你或许还经常人提起 IDE (Intergreated Development Environment)，和代码编辑器相比 IDE 更关注开箱即用的体验、对代码的智能理解和对大型项目的支持，因此相对「笨重」；代码编辑器则更加轻量，侧重于文件，对于语言和工作流的支持也更自由。</p>

<h2 id="toc_1">为什么选择 VS Code</h2>

<blockquote>
<p>Visual Studio Code（简称 VS Code）是一个由微软开发，同时支持 Windows 、 Linux 和 macOS 等操作系统且开放源代码的代码编辑器，它支持测试，并内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。 ——维基百科</p>
</blockquote>

<p>瑞士计算机科学家 Erich Gamma （《设计模式》作者、 Eclipse 主要开发者之一） 2011 年从 IBM 来到微软后起初负责组建团队开发一款线上开发工具（Manaco），后来他们在这个工具的基础上开发了如今的 VS Code 并于 2015 年发布。VS Code 定位为一个 <strong>高性能轻量级的编辑器</strong>，为了保证主进程的稳定，插件系统运行在主进程之外，所有个性化功能都由插件系统完成，在 IDE 和编辑器之间找到一个比较理想的平衡。</p>

<p>在微软所有开源项目中，VS Code 是目前最受欢迎的一个。经过不同工具之间的比较，我最终选择 VS Code 的原因包括：</p>

<ul>
<li>完全免费且开源，更新迭代稳定</li>
<li>跨平台编辑器，满足日常在不同系统中的使用</li>
<li>占用系统资源比较少，大文件打开速度快</li>
<li>插件丰富，扩展性极强</li>
<li>使用人数多且社区活跃，碰到问题和需求容易找到解决方案</li>
</ul>

<h2 id="toc_2">从 0 到 1 开始使用 VS Code</h2>

<h3 id="toc_3">下载与安装</h3>

<p>VS Code 有两个不同版本：稳定版（Stable）每月更新；预览版（Insiders）每个工作日更新。两个版本可同时安装互不影响，在 <a href="https://code.visualstudio.com/Download">官网</a> 即可选择自己需要的平台和版本，本文使用的版本为稳定版 1.44.1。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182244.png" alt="img"/></p>

<p>客户端安装完成后，如希望通过终端启动 VS Code，可以按下 <code>shift+command+p</code> 调出命令面板，在搜索框内输入<code>shell command</code> 后找到并点击「Shell Command: Install &#39;code&#39; command in PATH」即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182245.png" alt="img"/></p>

<p>VS Code 默认是英文界面，这里<strong>并不建议</strong>把默认语言修改为中文，因为在学习大量英文相关教程和说明时使用英文界面或许更容易操作。另外，VS Code 绝大多数插件都没有汉化，使用起来会中英混杂。</p>

<p>如果需要使用中文，依旧可以通过 <code>shift+command+p</code> 调取命令面板，然后在搜索框中输入 <code>display</code> 找到并点击「Configure Display Language」，这时会显示目前可以选择的语言或者安装其它语言。选择「Install additional languages...」后会跳转到相关语言插件，选择中文语言包安装并进行安装。安装完成后再次找到「Configure Display Language」后选择「zh-cn」后重启即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182246.png" alt="img"/></p>

<h3 id="toc_4">欢迎界面</h3>

<p>打开 VS Code 后，未修改默认配置的情况下首先会看到「欢迎页面」。如下图，欢迎页面有五部分内容。首次使用不妨先花点时间浏览「学习」部分内容，其中交互式演练场（interactive playground）是新手了解 VS Code 好资料。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182247.png" alt="img"/></p>

<h3 id="toc_5">VS Code 主题与图标</h3>

<p>在个性化设置部分点击「Color theme」可以选择一个你喜欢的主题。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182248.png" alt="img"/></p>

<p>除了主题之外，你还可以为 VS Code 选择一套自己喜欢的文件图标。点击左下角的「设置」图标，选择「file icon theme」。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182249.png" alt="img"/></p>

<p>然后选择「Install additional File icon theme...」会弹出可以安装的 icon 插件列表，例如 Material Icom Theme，点击安装后选择使用即可。</p>

<h2 id="toc_6">核心概念与组件</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182250.png" alt="img"/></p>

<p>上面这张图展示了默认配置情况下 VS Code 的基本界面。</p>

<ol>
<li>编辑器：在这里码字写代码</li>
<li>侧边栏：可以类比为 macOS 的扩展坞，姑且称为「组件坞」，这里会展示各种组件和插件图标。</li>
<li>组件内容：击侧边栏不同的组件后这里会展示相应显示组件内容。</li>
<li>面板：包括问题显示、输出、调试控制台和终端四个组件。问题面板会显示代码中的警告和问题，输出面板会呈现命令和插件的运行结果，调试控制台用来进行代码调试，终端则可以帮助我们直接在 VS Code 中进行命令行操作。</li>
<li>状态栏：可以类比为 macOS 的菜单栏 + 通知中心，这里会展示和文档及项目相关的简单信息以及部分插件提供的信息。</li>
</ol>

<h3 id="toc_7">侧边栏及常用组件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182251.png" alt="img"/></p>

<p>默认情况下，侧边栏显示的五个组件分别是：资源管理器、跨文件搜索、源代码管理、启动和调试和扩展管理。随着后期安装插件的增多，侧边栏可以显示的组件数量也会越来越多，不过你可以通过右击侧边栏选择隐藏那些用不到的组件还可以拖动组件图标进行排序。</p>

<p>侧边栏显示的默认组件中「资源管理器」和「跨文件搜索」就是字面功能，分别用来浏览管理文件和进行内容查找替换，我们会在下篇中配合具体应用场景进行更详细的介绍。源代码管理和调试分别用于 git 一系列操作和 debug，如果你并非程序员，没有这方面的需求也可以选择将其隐藏。</p>

<h3 id="toc_8">扩展管理及插件</h3>

<p>这一部分需要详细介绍「扩展管理」组件和「插件」这个概念。</p>

<p>如文章开头所言，VS Code 中为了保证主进程的稳定所有个性化功能的实现都将通过插件来完成，在下文的应用场景部分我们也会用到大量插件。我们可以把插件理解为 macOS 中的应用，而扩展管理则是 VS Code 的应用商店。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182252.png" alt="img"/></p>

<p>如上图，在组件显示部分可以看到已经安装的插件和推荐插件，所有你想找的东西都可以尝试在搜索框进行搜索。点击感兴趣的插件后会显示插件详情，其中包括详细介绍、作者和更新日志等内容。</p>

<p>需要说明的是，由于 VS Code 的扩展插件数量实在过于庞大，在浏览插件的时候系统已提供了一些过滤操作，点击 <code>···</code> 可以选择只查看安装的插件或者流行的插件等等。</p>

<p>更方便的是你还可以直接在插件搜索框中输入 <code>@</code> 来进行快速过滤。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182253.png" alt="img"/></p>

<p>为了更方便的找到需要的插件，VS Code 支持按照类别进行查找，目前支持的类别如下图所示，包括语言支持、代码片段和主题等。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182254.png" alt="img"/></p>

<p>目前在官方的插件商店中，我们可以看到共有 12 类 20000 余款插件。如果你想开发自己的插件，可以进一步参考 <a href="https://code.visualstudio.com/api">官方插件 API</a> 。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182255.png" alt="img"/></p>

<h3 id="toc_9">命令面板</h3>

<p>VS Code 作为一个代码编辑器，它本身有两个比较极客的设计思想。一个是基于文本（命令）的交互界面，另一个是基于文本的系统设置。基于文本的交互界面就是这里提到的命令面板，系统设置将会稍后介绍。</p>

<p>命令面板的存在提供了一种全新的使用逻辑，熟练使用后可以极大提高效率，因此对命令面板有基本了解是上手 VS Code 的关键。其实在上文安装命令行启动以及设置中文支持时我们都用过它，<code>shift+command+p</code> 就是调用命令面板的一种基本方式。</p>

<p>命令面板的高效在于其<strong>可以通过输入框中的第一个字符</strong>来触发不同功能。</p>

<p>如下图所示，当你按下 <code>shift+command+p</code> 时，命令面板的输入框会自动出现一个 <code>&gt;</code> 它意味着此时命令面板认为你想要搜索相关命令并执行。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182256.png" alt="img"/></p>

<p>当删除 <code>&gt;</code> 后会看到命令面板切换到了「访问最近文件」状态。如果你想在调用命令面板时直接访问最近文件，快捷键是 <code>command+p</code>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182257.png" alt="img"/></p>

<p>如果此时输入 <code>?</code> 会触发命令面板的「帮助」功能，我们可以看到支持哪些操作。下图中显示的切换文件、<code>&gt;</code>执行命令、<code>@</code>符号跳转等我们在后续的应用场景中都会提及。其他单词缩写也代表了对应的操作，例如<code>edt</code>接空格可以管理打开的编辑器，<code>term</code>接空格可以打开或管理终端。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182258.png" alt="img"/></p>

<h3 id="toc_10">修改设置</h3>

<p>在下篇介绍中，我们会涉及到更改默认设置的内容，因此有必要了解 VS Code 更改设置的方法。</p>

<p>VS Code 目前已经有了比较完善的图形化设置界面，只需要使用 <code>command+,</code> 就可以调用。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182259.png" alt="img"/></p>

<p>如上图所示，设置面板已经列出了用户常用配置内容，你可以寻找自己想要改变的东西，但是这里更加推荐直接在搜索框里搜索。此外，VS Code 的配置分为用户（User）和工作区（workspaces）两个层级，其中用户配置会对全局生效，工作区配置只会对当前所在的项目（目录）生效且优先级更高。</p>

<p>除了图形化界面以外，VS Code 的所有配置其实都写在 json 格式的一个文本文件中。你可以非常方便的调出该文件进行设置，只需要在命令面板中输入<code>open sett</code> 然后选择 JSON 即可。如果是针对工作区的设置，json 文件将会保存在工作区<code>.vscode</code>目录下。</p>

<p>在 json 文件中，你可以直接编写设置，也可以点击行号前的「笔形」图标查看可以更改的内容。之所以有必要了解如何通过配置文件更改设置是因为部分插件提供的复杂设置只能通过修改 json 文件完成。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182300.png" alt="img"/></p>

<h3 id="toc_11">工作区</h3>

<p>工作区（workspace）是另一个需要了解的核心概念，它对应在 VS Code 中如何进行文件管理。</p>

<p>上文我们提到相比于 IDE 着重于项目管理，代码编辑器更加侧重于文件本身，VS Code 所有操作就是基于当前目录、子目录和其中的文件进行的。在下篇内容中我们会讲到很多操作和插件都会基于所在目录生成相关的配置文件，而这些文件通常都会被保存到所在目录的<code>.vscode</code>文件夹中。<code>.vscode</code> 文件夹中的各种配置决定了不同目录被打开时 VS Code 会启动哪些插件和配置。</p>

<p>随着项目逐渐发展，单一文件夹往往无法满足我们的开发需求，VS Code 通过工作区这个概念解决了同时操作多个文件夹的问题。简而言之，当你使用 VS Code 打开一个文件夹后可以在命令面板中搜索运行 <code>add folder to workspace</code>，然后选择想要打开的其它文件夹，此时就会显示一个尚未保存的工作区。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182301.png" alt="img"/></p>

<p>当所有文件夹添加完成后在命令面板执行 <code>save workspace as</code> 选择我们的工作区名字和要保存的位置，就可以对该工作区进行保存。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182302.png" alt="img"/></p>

<p>这时我们会看到一个名字后缀为<code>code-workspace</code>的文件，其本质依旧是一个 json 格式的配置文件。其中包括了文件夹的相对路径以及针对工作区的其它设置。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182303.png" alt="img"/></p>

<p>此外，记住两个目录切换的快捷键也会大大提高效率，<code>ctrl+r</code> 可以快速查看并切换最近打开的文件夹，<code>ctrl+w</code> 则可以快速在所有打开的 VS Code 窗口中进行切换。</p>

<h3 id="toc_12">语言支持</h3>

<p>作为一个代码编辑器，VS Code 提供了统一的 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> 和 <a href="https://code.visualstudio.com/api/extension-guides/debugger-extension">Code Debugging Protocol API</a>，所有语言支持都能够借助这两个 API 在 VS Code 上得到类似 IDE 的开发和调试体验。</p>

<p>程序员可能最关心的内容就是对编程语言的支持，但初学者最不需要担心的其实也是这部分内容。到目前为止常用的主流编程语言在 VS Code 中都得到了很不错的支持，你需要的往往只是安装对应语言插件和进行一点基本配置。这些语言包括基础的 Markdown 和 JSON，以 HTML、CSS 和 JavaScript 为代表的多种前端语言和以 Python、Java、Go、C#、PHP 等为代表的大量后端语言。对于一些在程序员群体中相对使用人数较少的编程语言，例如 R 和 Julia 等也都有插件提供支持。下图为官网展示的几个流行语言插件。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182304.png" alt="img"/></p>

<p>如果想查看自己使用的编程语言是否支持，可以在 <a href="https://marketplace.visualstudio.com/">插件商店</a> 中查找。此外，当你用 VS Code 打开一个文件时，系统会根据文件名后缀自动提示你安装与之相关的语言插件，非常方面。</p>

<p>这一部分我们也会在下篇中结合具体的应用场景进行介绍。</p>

<h3 id="toc_13">常用快捷键</h3>

<p>提倡使用使用快捷键，主要目的是提高效率尽量让双手不离开键盘。快捷键的使用开始看似是一件更浪费时间的事情，但是随着肌肉记忆和熟练度增加效率将会大大提高。</p>

<p>如果你是从其它编辑器切换到 VS Code 完全可以移植之前熟悉的快捷键配置，比如 Vim, Atom 或者 sublime。如果是一个新手，下图是我自己日常用到的 VS Code 高频快捷键，供参考。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200513182305.png" alt="img"/></p>

<p>如果需要查看所有快捷键，可以通过 ctrl+K ctrl+s 进入快捷键设置界面或者直接查看官方文档。</p>

<ul>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">windows 快捷键</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf">macOS 快捷键</a></li>
</ul>

<p>以上就是 VS Code 编辑器入门指南上篇的内容，介绍了什么是代码编辑器、为什么选择 VS Code 、从 0 到 1 开始使用 VS Code 以及上手 VS Code 需要了解的核心概念与组件。有了这些知识储备，在下篇中将会介绍 5 个 VS Code 实际应用场景，进而更好的了解 VS Code 的特性和插件。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631155.html">
                
                  <h1>Python之platform模块</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>该模块用来访问平台相关属性。常见属性和方法</p>

<p><strong>平台架构</strong></p>

<pre class="line-numbers"><code class="language-text">platform.machine()
</code></pre>

<p>返回平台架构。若无法确定，则返回空字符串。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; platform.machine()
&#39;AMD64&#39;
&gt;&gt;&gt; platform.machine()
&#39;x86_64&#39;
</code></pre>

<p><strong>网络名称（主机名）</strong></p>

<pre class="line-numbers"><code class="language-text">platform.node()
</code></pre>

<p>返回计算机的网络名称(可能未被完全限定！)。如果无法确定该值,则返回空字符串。</p>

<pre class="line-numbers"><code class="language-text">#windows
&gt;&gt;&gt; platform.node()
&#39;office&#39;

#linux
&gt;&gt;&gt; platform.node()
&#39;abcxx&#39;
</code></pre>

<p><strong>系统版本</strong></p>

<pre class="line-numbers"><code class="language-text">platform.platform(aliased = 0,terse = 0)
</code></pre>

<p>如果aliased为True,则该函数将使用不同平台的别名来报告与其常用名称不同的系统名称,例如SunOS将被报告为Solaris。 system_alias()函数用于实现。<br/>
将terse设置为True会导致该功能仅返回识别平台所需的绝对最小信息。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; platform.platform()
&#39;Windows-8.1-6.3.9600-SP0&#39;

&gt;&gt;&gt; platform.platform(aliased=True)
&#39;Windows-8.1-6.3.9600-SP0&#39;

&gt;&gt;&gt; platform.platform(aliased=True,terse=True)
&#39;Windows-8.1&#39;

&gt;&gt;&gt; platform.platform(aliased=True,terse=False)
&#39;Windows-8.1-6.3.9600-SP0&#39;

#linux
&gt;&gt;&gt; platform.platform()
&#39;Linux-2.6.32-642.13.1.el6.x86_64-x86_64-with-centos-6.8-Final&#39;
</code></pre>

<p><strong>处理器名称</strong></p>

<pre class="line-numbers"><code class="language-text">platform.processor()
</code></pre>

<p>返回处理器名称。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; platform.processor()
&#39;Intel64 Family 6 Model 60 Stepping 3, GenuineIntel&#39;` 

#linux
&gt;&gt;&gt; platform.processor()
&#39;x86_64&#39;
</code></pre>

<p><strong>系统名称</strong></p>

<pre class="line-numbers"><code class="language-text">platform.system()
</code></pre>

<p>返回系统/操作系统名称,例如“Linux”,“Windows”或“Java”。如果无法确定该值,则返回空字符串。</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; platform.system()
&#39;Windows&#39;

#linux
&gt;&gt;&gt; platform.system()
&#39;Linux&#39;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631194.html">
                
                  <h1>**Pycharm的调试功能**</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><strong>前言</strong></h2>

<p>​   <strong>Debug调试，是一项学习编程人员的重要技能。只有当你学会 debug 了以后，才可以正确的知道程序的走向流程是如何的，今天就来给大家介绍一下 pycharm 中的 debug 功能！</strong></p>

<h2 id="toc_1"><strong>debug的前世</strong></h2>

<p>​   在正式讲解之前，先来了解下 debug 这个词的由来，就像我们初学Python 时，先要了解下它历史的由来。</p>

<blockquote>
<p>​ 1937年，美国青年霍华德·艾肯找到IBM公司为其投资200万美元研制计算机，第一台成品艾肯把它取名为：马克1号（mark1），又叫“自动序列受控计算机”，从这时起IBM公司由生产制表机，肉铺磅秤，咖啡研磨机等乱七八糟玩意儿行业，正式跨进“计算机”领地。为马克1号编制程序的是哈佛的一位女数学家葛丽斯·莫雷·霍波，有一天，她在调试程序时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍波诙谐的把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，后来成为计算机领域的专业行话。从而debug意为排除程序故障的意思。<br/>
--百度百科</p>
</blockquote>

<p>​   看了上面的小故事，debug 一词的由来，是由 bug 词得来的，bug 是臭虫的意思，debug 就是解决臭虫。</p>

<p>​   在如今的互联网时代，多少你肯定听说过 bug 这个词，比如什么什么软件又出 bug 了！说的就是软件在使用的过程中，程序出现了一些错误。故称之为 bug。</p>

<p>​   <strong>而 debug 则是通过工具来对代码进行调试，一步步找出程序中出现 bug 的位置，也就是程序中具体错误代码的位置。</strong>就像故事中所说，debug过程就是在解决虫子一样。。</p>

<h2 id="toc_2"><strong>pycharm 中的 debug 模式</strong></h2>

<p>​   来步入今天的正题。首先，还是用示例说话，我们书写一段简短的代码，来帮我们完成今天要讲的内容。</p>

<pre class="line-numbers"><code class="language-python">def sum_demo(x, y):
    for _ in range(2):
    x += 1
    y += 1
    result = x + y

if __name__ == &#39;__main__&#39;:
    result = sum_demo(1, 1)
    print(result)
</code></pre>

<p>​   肉眼识别下，猜猜结果是多少呢？初学者可能没见过 for 循环中的下划线，在 Python 中是占位符的意思，因为单纯的循环两次而已，并不用到它的循环结果。最终 result 会输出 6 。</p>

<p>在 pycharm 中，如何开启 debug 调试，一共有三种进入的方法，如下（下图均可点开放大观看）：</p>

<p>​   方法一：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assets384a2c7fcbba4fa192559fe11f9ffa91.jpg" alt="img"/></p>

<p>​   方法二：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assetsbe9f690ed0144dd394a3b901a574a6de.jpg" alt="img"/></p>

<p>​   方法三：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assets5362d3b132944103b3ce4ee9d9a8e898.jpg" alt="img"/></p>

<p>​   有一种方法，就是 pycharm 导航栏处，有个run，点开以后即可看到 debug ，这里就不截图演示了。</p>

<p>​   单纯的进入 debug 模式，你会发现，与正常的 run 去运行程序没有差异。差异就是 pycharm 的控制台部分，从 run 跑到了 debug 显示。</p>

<p><img src="media/15998025631194/f57c00a5578e438b99186977063ef45c.jpg" alt="img"/></p>

<p>​   接下来要讲的，才是 debug 中的重中之重，即断点调试！</p>

<h2 id="toc_3"><strong>debug 的断点调试</strong></h2>

<p>​   断点调试，英文 breakpoint。用大白话来解释下，断点调试其实就是在程序自动运行的过程中，你在代码某一处打上了断点，当程序跑到你设置的断点位置处，则会中断下来，此时你可以看到之前运行过的所有程序变量。来继续刚才的演示，pycharm 中如何设置断点。点击前：</p>

<p><img src="media/15998025631194/2b69c23f3d5540b3b2aad1019c92eb7b.jpg" alt="img"/></p>

<p>​   点击后，每行代码都设置上断点：</p>

<p><img src="media/15998025631194/2eeda84be72d4050afc1b53b8b4019f5.jpg" alt="img"/></p>

<p>​   设置完断点后，开启 debug 调试模式运行下，看到结果：</p>

<p><img src="media/15998025631194/eb7efb81a4f74431813e45c35cabfc2d.jpg" alt="img"/></p>

<p>​   看到了这么多新摆设，是不是有点怕了！不怕，咱们先来从控制台每个按钮讲起：</p>

<p><img src="media/15998025631194/89109f6c373e4f1f8207489bd6ba1d8c.jpg" alt="img"/></p>

<p>​   如果要是忘记中文意思的话，没有关系，鼠标指到按钮处，悬浮一会儿，会有英文提示的。继续再来说横排按钮：</p>

<p><img src="media/15998025631194/643e7919e4404d378ad981b91a478a60.jpg" alt="img"/></p>

<p>​   其中，横排最重要，经常用到的按钮，来解释一下，自己鼠标悬浮去看英文即可：</p>

<p>​   <code>step over（F8快捷键）</code>：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，<strong>程序代码越过子函数，但子函数会执行，且不进入。</strong></p>

<p>​   <code>step into（F7快捷键）</code>：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。</p>

<p>​   <code>step into my code（Alt+Shift+F7快捷键）</code>：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。</p>

<p>​   <code>step out（Shift+F8快捷键）</code>：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</p>

<p>​   <code>Resume program(F9快捷键)</code>：继续恢复程序，直接运行到下一断点处。以上四个功能，就是最常用的功能，一般操作步骤就是，<strong>设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。</strong></p>

<h2 id="toc_4"><strong>示例演示</strong></h2>

<p>​   上面的基础概念明白了以后，直接用图片示例演示下：</p>

<p><strong>1.设置初步断点</strong></p>

<p><img src="media/15998025631194/48887ceff1ee4320a9cfcbc29a687725.jpg" alt="img"/></p>

<p><strong>2.F7 进入函数</strong></p>

<p><img src="media/15998025631194/047e27bba8064e088a8e35664b542ffb.jpg" alt="img"/></p>

<p><strong>3.F8 单步调试，往下执行代码</strong></p>

<p><img src="media/15998025631194/cfd7dba081484ab5a4cfdfde6667c06a.jpg" alt="img"/></p>

<p>继续 F8 单步调试，往下执行代码：</p>

<p><img src="media/15998025631194/836459703944478982352b097cf37f40.jpg" alt="img"/></p>

<p>继续 F8 单步调试：</p>

<p><img src="media/15998025631194/8c19393661834869bb354569522e1e5f.jpg" alt="img"/></p>

<p>继续 F8 单步调试：</p>

<p><img src="media/15998025631194/973b3367e75e42fe83a85e790b691cd8.jpg" alt="img"/></p>

<p><img src="media/15998025631194/2b5e2461a0d14e33b8345c2b85831c6b.jpg" alt="img"/></p>

<p><strong>4.看够了循环，想直接看最终 result 加完的结果，结果处打断点，直接 F9</strong></p>

<p><img src="media/15998025631194/801f24e8285d4452b9e15100a166aa33.jpg" alt="img"/></p>

<p>​   以上就是断点调试的全过程。看完之后，理解了吗~是不是顿时明白了断点调试的重要性，使用断点可以快速帮助我们理解程序中的各处逻辑！</p>

<h2 id="toc_5"><strong>结语</strong></h2>

<p>​   <strong>看到这里，基本的调试，相信你认真看完的话，已经可以上手使用了！但是要拓展的点还有很多，比如 pycharm 为什么在工程性的程序中颇受欢迎，因为它实在是太强大了。。。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631328.html">
                
                  <h1>PyCharm使用技巧与常见错误</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>​ Pycharm是我们日常进行python开发常用的集成工具，如果我们能够熟练的掌握它，可以大幅提高我们程序的开发效率。下面由勇哥会结合图文形式给大家分享pycharm的实用技巧和常见的错误。</p>
</blockquote>

<ol>
<li><strong>如何快速给指定的代码块添加注释，如何取消指定代码块的注释？</strong></li>
</ol>

<p>​       如果要注释前6行代码，首先需要鼠标选中前6行，如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212821.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       然后在英文输入状态下，按下CTRL+ / 快捷键给选中的代码块添加注释,如下图所示。显示灰色的语句块已经成功实现注释了。如果要取消已经注释的块，直接用鼠标选中已经注释的块，然后再按一次CTRL+ /快捷键即可取消注释。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212827.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>如何快速对指定的代码块进行整体缩进和取消缩进</strong></li>
</ol>

<p>​       整体缩进：</p>

<p>​       选中要缩进的代码块，然后按下tab键就实现缩进4个空格。</p>

<p>​       取消缩进：</p>

<p>​       选中要取消缩进的代码块，然后按shift+tab组合键可以实现</p>

<p>​       取消缩进。如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212837.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>设置pycharm代码编辑器的背景风格</strong></li>
</ol>

<p>​       对于经常编写代码的人，设置合理的背景色有助于保护我们的眼睛，给人愉悦的心情。</p>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》》选择Color Scheme》》选择python如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212842.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       在下图红色框中选择代码编辑器显示风格，选择完成点击OK按钮。就会看到我们的代码编辑器背景已经变了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212939.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>改变代码编辑器的字体大小与字体类型</strong></li>
</ol>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》》选择Font如下图所示。修改完成单机OK按钮。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212950.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>给工程配置解释器</strong></li>
</ol>

<p>​       第一次使用pycharm后，创建工程后，需要给当前的工程设置解释器，如果不配置会报如下错误：</p>

<p>​       No Python interpreter configured for the project。这个错误也是初学者最常见遇到的错误。</p>

<p>​       解决办法：</p>

<p>​       点击File-&gt;Setting-&gt;Project:your project name-&gt;Project Interpreter-&gt;右上角齿轮-&gt;Add Local，找到python解释器添加进来就可以了。如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212957.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>快速搜索代码区和输出区的目标内容</strong></li>
</ol>

<p>​       将关闭定位在代码区，然后按ctrl+f 组合键实现内容搜索，如下图所示，可以使用精确搜索，也支持利用正则表达式去搜索。使用正则规则搜索内容，需要在图中将Regex前的框打勾。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213002.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       代码的输出结果区也可以进行搜索，如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213007.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>代码比对</strong></li>
</ol>

<p>​       在日常的开发中，经常会碰到当前代码和历史的某个版本代码进行比对修改和查看。</p>

<p>​       首先将光标定位在当前的代码区，然后点击view菜单》》选择compare with…菜单，在弹出的窗口中选择历史的某个代码文件，点击确定如下图所示</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213011.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>设置代码模板</strong></li>
</ol>

<p>​       pycharm 支持代码模板功能，这是一个比较实用的功能。它可以在你新建一个文件时，按照你预设的模板给你生成一段内容，比如解释器路径，编码方法，作者有关信息等。操作方法如下：</p>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》选择File and Code Template 如下图所示，选择python Script，然后在图中右侧区域书写模板信息。创建完成，点击确定按钮。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213015.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       在工程中，新建一个python源码文件，名为111，如下图所示，就可以看到刚添加的模板信息。</p>

<p><img src="http://p3.pstatp.com/large/pgc-image/71f85071d47c44d8b6618540fb805549" alt="PyCharm使用技巧与常见错误"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631366.html">
                
                  <h1>MWeb + Github Pages 搭建个人博客/静态网站</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1、打开GitHub Pages</h2>

<p>链接<a href="https://pages.github.com/">https://pages.github.com/</a> ，可以直接按照上面的操作指引来操作</p>

<p>(1)创建 github repository</p>

<p>官网说明如下图，需要先注册登录GitHub，然后创建repository，命名方式为<a href="http://username.github.io/">http://username.github.io</a>，注意用户名(前后两个输入框)保持一致。</p>

<p><img src="media/15998025631366/v2-2a7bdd7a71db76912f5c70db4b8e042e_720w.jpg" alt="img"/></p>

<p>（2）git client</p>

<p>我使用了桌面客户端（下载链接 <a href="https://desktop.github.com/">https://desktop.github.com</a> ）</p>

<p><img src="media/15998025631366/v2-9029512a20bea6a74ff6e661b1ed554c_720w.jpg" alt="img"/></p>

<p>（3）下载 GitHub desktop 并登录，选择你创建的repository，并点击clone按钮。然后就可以看到本地的克隆文件的路径。</p>

<p><img src="media/15998025631366/v2-416a3d6414b387d21ea3dcc584960298_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-02f99763a4d07e5120d6b16e0943756b_720w.jpg" alt="img"/></p>

<h2 id="toc_1">2、下面先转到MWeb这里，下载并使用MWeb创建静态网页</h2>

<p>MWeb是一个简单易用的markdown工具，还可以生成静态网站，不过要付费。</p>

<p>（1）首先左下角新增静态网站分类</p>

<p><img src="media/15998025631366/v2-f0d346f5cce89cfc883f55608ce7d9e5_720w.jpg" alt="img"/></p>

<p>（2）对这个站点的名称、模版等进行设置</p>

<p><img src="media/15998025631366/v2-f802de2a62db871c817d2e8206ff095e_720w.jpg" alt="img"/></p>

<p>（3）在里面写一篇文章，然后选择生成网站</p>

<p><img src="media/15998025631366/v2-47cbf01ada99ca1f078774154bef5dc5_720w.jpg" alt="img"/></p>

<p>(4)生成网站后，还是在这个下拉菜单中选择“在finder中显示网站生成位置”，就会定位到本地文稿所在位置。</p>

<p><img src="media/15998025631366/v2-186318f6b291d3874d16b8da45b575a1_720w.jpg" alt="img"/></p>

<p>(5)将这里的所有文件复制到 github在本地的克隆文件中</p>

<h2 id="toc_2">3、最后一步，文件上传与同步</h2>

<p>打开GitHub desktop，左边栏中就是我们要同步的新增文件。点击左下的commit，然后点击右上角的push按钮。这样就OK了，你可以访问一下你的网站（<a href="http://username.github.io/">http://username.github.io</a>）看看效果了～</p>

<p><img src="media/15998025631366/v2-89721201dd82fec5937c581099a43303_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-d2dede1032356af70fa032dd52076aa3_720w.jpg" alt="img"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631446.html">
                
                  <h1>Git 常用技巧 （高级用法）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><strong>git 的一些「高级」用法</strong></h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312211952.jpg" alt=""/></p>

<h2 id="toc_1"><strong>导航 —— 跳到之前的分支</strong></h2>

<pre class="line-numbers"><code class="language-text">git checkout -
</code></pre>

<h2 id="toc_2"><strong>查看历史</strong></h2>

<pre class="line-numbers"><code class="language-text"># 每个提交在一行内显示
git log --oneline

# 在所有提交日志中搜索包含「homepage」的提交
git log --all --grep=&#39;homepage&#39;

# 获取某人的提交日志
git log --author=&quot;Maxence&quot;
</code></pre>

<h2 id="toc_3"><strong>之前重置了一个不想保留的提交，但是现在又想要回滚？</strong></h2>

<pre class="line-numbers"><code class="language-text"># 获取所有操作历史
git reflog

# 重置到相应提交
git reset HEAD@{4}
# ……或者……
git reset --hard &lt;提交的哈希值&gt;
</code></pre>

<h2 id="toc_4"><strong>我把本地仓库搞得一团糟，应该怎么清理？</strong></h2>

<pre class="line-numbers"><code class="language-text">git fetch origin
git checkout master
git reset --hard origin/master
</code></pre>

<h2 id="toc_5"><strong>查看我的分支和 master 的不同</strong></h2>

<pre class="line-numbers"><code class="language-text">git diff master..my-branch
</code></pre>

<h2 id="toc_6"><strong>定制提交</strong></h2>

<pre class="line-numbers"><code class="language-text"># 编辑上次提交
git commit --amend -m &quot;更好的提交日志&quot;

# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit

# 空提交 —— 可以用来重新触发 CI 构建
git commit --allow-empty -m &quot;chore: re-trigger build&quot;
</code></pre>

<p>​   <strong>squash 提交</strong></p>

<p>​   比方说我想要 rebase 最近 3 个提交：</p>

<p>​   - git rebase -i HEAD~3<br/>
​   - 保留第一行的 pick，剩余提交替换为 squash 或 s<br/>
​   - 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）</p>

<pre class="line-numbers"><code class="language-text">pick 64d26a1 feat: add index.js
s 45f0259 fix: update index.js
s 8b15b0a fix: typo in index.js
</code></pre>

<h2 id="toc_7"><strong>修正</strong></h2>

<p>比方说想在提交 fed14a4c 加上一些内容。</p>

<p><img src="Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7(%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95).assets/4a407484dfb44ea0ad31738ddf673099.jpg" alt=""/></p>

<p><strong>git 提交分支</strong></p>

<pre class="line-numbers"><code class="language-text">git add .
git commit --fixup HEAD~1
# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1

git rebase -i HEAD~3 --autosquash
# 保存并退出文件（VI 中输入 `:wq`）
</code></pre>

<h2 id="toc_8"><strong>rebase 的时候在每个提交上执行命令</strong></h2>

<p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase --exec 命令在每个提交上执行命令。</p>

<pre class="line-numbers"><code class="language-text"># 在最近 3 个提交上运行 `npm test` 命令
git rebase HEAD~3 --exec &quot;npm test&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212414.jpg" alt=""/></p>

<h2 id="toc_9"><strong>暂存</strong></h2>

<p>​   暂存不止是 git stash 和 git stash pop ;)</p>

<pre class="line-numbers"><code class="language-text"># 保存所有正在追踪的文件
git stash save &quot;日志信息&quot;

# 列出所有的暂存项
git stash list

# 获取并删除暂存项
git stash apply stash@{1}
git stash drop stash@{1}
# ……或使用一条命令……
git stash pop stash@{1}
</code></pre>

<h2 id="toc_10"><strong>清理</strong></h2>

<pre class="line-numbers"><code class="language-text"># 移除远程仓库上不存在的分支
git fetch -p

# 移除所有包含 `greenkeeper` 的分支
git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &#39;s/^.\{9\}//&#39; | xargs git push origin --delete
</code></pre>

<h2 id="toc_11"><strong>GitHub = Git + Hub</strong></h2>

<p>我把 Hub 当成 git 的一个封装来用。你如果也想这么做，可以设置一个别名：alias git=&#39;hub&#39;</p>

<pre class="line-numbers"><code class="language-text"># 打开浏览器访问仓库 url（仅限 GitHub 仓库）git browse
</code></pre>

<hr/>

<h2 id="toc_12"><strong>额外福利：我最喜爱的 git 别名</strong></h2>

<pre class="line-numbers"><code class="language-text">alias g=&#39;git&#39;
alias glog=&#39;git log --oneline --decorate --graph&#39;
alias gst=&#39;git status&#39;
alias gp=&#39;git push&#39;
alias ga=&#39;git add&#39;alias gc=&#39;git commit -v&#39;

# 
alias yolo=&#39;git push --force&#39;

# 每周站会汇报工作时用
git-standup() {
    AUTHOR=${AUTHOR:=&quot;`git config user.name`&quot;}

    since=yesterday
    if [[ $(date +%u) == 1 ]] ; then
        since=&quot;2 days ago&quot;
    fi

    git log --all --since &quot;$since&quot; --oneline --author=&quot;$AUTHOR&quot;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631488.html">
                
                  <h1>Docker 必备可视化工具 Portainer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>​   推荐使用 Portainer 作为 docker 容器的 GUI 管理方案。</p>

<blockquote>
<p>Portainer 是一个开源、轻量级 Docker 管理用户界面，基于 Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm 集群和服务等集中管理和操作、登录用户管理和控制等功能。</p>
</blockquote>

<p>​   官方地址：<a href="https://portainer.io/install.html">https://portainer.io/install.html</a></p>

<h3 id="toc_0"><strong>安装命令：</strong></h3>

<pre class="line-numbers"><code class="language-text">docker volume create portainer_data
docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>

<p>访问你的 IP:9000 即可进入容器管理页面。如果是本机的话访问地址就是: http:localhost:9000</p>

<h3 id="toc_1"><strong>运行效果:</strong></h3>

<p><img src="media/15998025631488/993a4e5a14f245afa3db02f346af568a.jpg" alt="Docker 必备可视化工具 Portainer"/></p>

<p><img src="media/15998025631488/817906ae46094355bba1950ee0230f25.jpg" alt="Docker 必备可视化工具 Portainer"/></p>

<h3 id="toc_2">参考资料：</h3>

<p>​   docker：轻量级图形页面管理之 Portainer: <a href="https://blog.51cto.com/ganbing/2083051">https://blog.51cto.com/ganbing/2083051</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628475.html">
                
                  <h1>Anaconda + VSCode 最详细教程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，同时也是为了让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<p>现在 Python 的广告可谓铺天盖地，文章、朋友圈、各种网页基本都能看到，虽然有些广告确实夸大了 Python 的作用，标题很雷人，但是无论如何也反映了一种趋势，未来编程思维很重要。而我们看待 Python 等编程语言应保持客观，能够帮到自己那就值得花点时间学习，入门之后才知道是不是自己的菜。</p>

<h2 id="toc_1">「戏」说 Python</h2>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225635.png" alt="img"/></p>

<h2 id="toc_2">写在前面</h2>

<p>为了录制这篇教程，我又把电脑上的 Python 卸载了🕹，重新安装 Anaconda 和 VSCode ，并录制动图。文章每个步骤介绍的很详细，只要跟着GIF动图一步一步操作就可以，适合零基础的朋友，通过这篇文章可以让你学会自己运行 Py 文件、以及一些发布出来的 Py 代码段，因为封装成 EXE 不方便调试和更新，同时也是让更多人迈出学习 Python 的第一个门槛，后续也会写一些 Python 爬虫案例，用于工商信息查询、地址查询、快递查询等，所以为了这些工具，赶紧学起来吧📘。</p>

<h2 id="toc_3">一、Anaconda 下载</h2>

<p>Anaconda 可以看做Python的一个集成安装，安装它后就默认安装了python、IPython、集成开发环境Spyder和众多的包和模块，让你在管理环境和包时更加方便。</p>

<p>可以选择从官网或清华源下载 Anaconda 安装包，<strong>清华源</strong>下载速度相对较快。</p>

<p>安装的位数推荐32位，兼容性最强，也可以根据自己的系统位数选择安装。</p>

<p>官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.anaconda.com%2Fproducts%2Findividual">https://www.anaconda.com/products/individual</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225643.png" alt="img"/></p>

<p>清华源：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fanaconda%2Farchive%2F">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225646.png" alt="img"/></p>

<h2 id="toc_4">二、Anaconda 安装</h2>

<p>安装过程中三个注意的地方：</p>

<ul>
<li>勾选 <code>Alls Users</code></li>
<li>勾选 <code>Add Anaconda to the system PATH environment variable</code></li>
<li>如果之前没有安装 VSCode，可以在 Anaconda 安装过程中选择安装</li>
</ul>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225654.gif" alt="img"/></p>

<h2 id="toc_5">三、VSCode 下载安装</h2>

<p>Anaconda 安装过程中 VSCode 有时候可能会出错，导致安装失败，这种情况下可以选择从 VSCode 官网下载安装。</p>

<p>VSCode官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com%2FDownload%23">https://code.visualstudio.com/Download#</a></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225658.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225700.gif" alt="img"/></p>

<h2 id="toc_6">四、管理 conda</h2>

<h3 id="toc_7">1. 查看 conda 版本</h3>

<p>安装完成后按<code>Win+R</code>打开<code>cmd</code>终端，输入<code>conda --version</code></p>

<p>如果正常输出了 conda 的版本，说明 Anaconda 成功安装了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225704.gif" alt="img"/></p>

<h3 id="toc_8">2. 添加国内源</h3>

<ul>
<li>查看现有源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --show-sources
</code></pre>

<ul>
<li>添加国内清华源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</code></pre>

<ul>
<li>删除默认源</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --remove channels defaults
</code></pre>

<ul>
<li>设置搜索时显示通道地址</li>
</ul>

<pre class="line-numbers"><code class="language-text">conda config --set show_channel_urls yes
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225707.gif" alt="img"/></p>

<h3 id="toc_9">3. 升级 conda</h3>

<p>设置完国内源后，升级 conda 的速度会快很多，之后安装包时也会从国内源下载。</p>

<pre class="line-numbers"><code class="language-text">conda update conda
</code></pre>

<p>升级时弹出<code>Proceed ([y]/n)?</code>时，选择<code>y</code>，确认升级。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225711.gif" alt="img"/></p>

<h2 id="toc_10">五、环境管理</h2>

<p><strong>可跳过，直接用默认环境</strong></p>

<h3 id="toc_11">1. 查看 Python 版本</h3>

<pre class="line-numbers"><code class="language-text">python --version
</code></pre>

<h3 id="toc_12">2. 创建环境</h3>

<p>上一步查到我电脑上的 Python 版本为 3.7.0 ，我想在这个版本基础上创建一个名为 [虚拟环境名] 的虚拟环境。</p>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] python=3.7.0
</code></pre>

<p>新的开发环境会被默认安装在你 conda 目录下的 envs 文件目录下。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225714.gif" alt="img"/></p>

<h3 id="toc_13">3. 激活环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_14">4. 列出所有的环境</h3>

<pre class="line-numbers"><code class="language-text">conda info -e
</code></pre>

<p>当前激活的环境会标<code>*</code>。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225718.png" alt="img"/></p>

<h3 id="toc_15">5. 切换到另一个环境</h3>

<pre class="line-numbers"><code class="language-text">activate [虚拟环境名]
</code></pre>

<h3 id="toc_16">6. 注销当前环境（默认的环境是base）</h3>

<pre class="line-numbers"><code class="language-text">deactivate
虚拟环境激活后，在cmd中输入python，显示的就是一个新的环境。
</code></pre>

<h3 id="toc_17">7. 复制环境</h3>

<pre class="line-numbers"><code class="language-text">conda create -n [虚拟环境名] --clone [参考环境名]

---常用 
conda env --help    #查看帮助
conda env list  #列出所有的虚拟环境
conda list --name [虚拟环境名]   #查看指定虚拟环境下的package

#创建
conda create --name [虚拟环境名] [python的版本] [需要的包]
conda create --name myenv
conda create --name myenv python=2.7
conda create --name myenv pytohon=2.7 numpy scipy

#克隆
conda create --name [虚拟环境名] -- clone [clone的环境]

#创建一个和原python环境一样的虚拟环境
conda create --name mybase --clone base



</code></pre>

<h3 id="toc_18">8. 删除环境</h3>

<pre class="line-numbers"><code class="language-text">conda remove --name [虚拟环境名] -all
</code></pre>

<h2 id="toc_19">六、包管理</h2>

<h3 id="toc_20">1. 查看已安装包</h3>

<pre class="line-numbers"><code class="language-text">conda list
</code></pre>

<h3 id="toc_21">2. 使用 Conda 命令安装包</h3>

<pre class="line-numbers"><code class="language-text">conda install beautifulsoup4
</code></pre>

<h3 id="toc_22">3. 通过 pip 命令来安装包</h3>

<p>如果无法通过conda安装，可以用pip命令来安装包。</p>

<pre class="line-numbers"><code class="language-text">pip install beautifulsoup4
</code></pre>

<h3 id="toc_23">4. 移除包</h3>

<pre class="line-numbers"><code class="language-text">conda remove beautifulsoup4
</code></pre>

<h2 id="toc_24">七、VSCode 配置</h2>

<h3 id="toc_25">1. 安装 Python 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225724.png" alt="img"/></p>

<h3 id="toc_26">2. 安装 Code Runner 插件</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225727.png" alt="img"/></p>

<h3 id="toc_27">3. 安装中文插件（可选）</h3>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225729.png" alt="img"/></p>

<h3 id="toc_28">4. 指定路径（可跳过）</h3>

<p>确定当前激活环境所在路径</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225732.png" alt="img"/></p>

<p>然后在<code>File--&gt;Preferences--&gt;Settings--&gt;Extensions--&gt;Python--&gt;setting.json</code>添加下面的 Python 路径，这个路径和你设置的环境名称有关。</p>

<pre class="line-numbers"><code class="language-text">&quot;python.pythonPath&quot; :&quot;D:\\anaconda3\\envs\\xiaolvshijie\\python.exe&quot;
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225734.png" alt="img"/></p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225741.png" alt="img"/></p>

<h2 id="toc_29">八、开始运行 Py 文件</h2>

<p>运行代码前一定要按<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>或者用快捷键<code>Ctrl + Alt + N</code>执行代码。</p>

<h3 id="toc_30">1. 运行简单代码测试</h3>

<pre class="line-numbers"><code class="language-text">print(&#39;hello xiaolvshijie&#39;)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225744.gif" alt="img"/></p>

<h3 id="toc_31">2. 运行 Py 文件</h3>

<p>复制下面这段代码到编辑器中，<code>Ctrl + S</code>保存，再右键选择<code>Run Code</code>执行代码。</p>

<pre class="line-numbers"><code class="language-python">import prettytable as pt

tb = pt.PrettyTable()
tb.field_names = [&#39;Author&#39;, &#39;wwcheng&#39;]
tb.add_row([&#39;ID&#39;, &#39;xiaolvshijie&#39;])

print(tb)
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200824225753.gif" alt="img"/></p>

<p>会出现报错提示：<code>ModuleNotFoundError: No module named &#39;prettytable&#39;</code></p>

<p>意思是当前环境中缺少<code>prettytable</code>的包，你需要安装这个包。。</p>

<p>我们可以用<code>conda install prettytable</code>或者<code>pip install prettytable</code>来安装这个包。</p>

<p>如果不知道报错提示的意思，可以利用<strong>搜索引擎</strong>，百度一下你就知道，Python编程相关的问题网络上基本都能搜索到。</p>

<h2 id="toc_32">结语</h2>

<p>成功安装 Anaconda 和 VSCode 并运行上面测试代码后，你可以正常加入码农行业。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628522.html">
                
                  <h1>Linux系统/etc目录和文件的介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Linux目录结构特点</strong></p>

<ol>
<li>linux系统的所有目录是一个有层次的倒着的梳妆目录结构。根是所有目录的顶点，linux目录一切从根开始。</li>
<li>不听目录下的数据可以跨越不同的磁盘分区火不同的磁盘设备，设备可以随意挂载到任意目录上使用。</li>
<li>所有的目录的是安装一定类型有龟裂的组织和命名的。</li>
<li>没有挂载到目录上的磁盘，相当于没有门和串户的监狱，不能被使用。磁盘等设备de需要挂载菜能正常使用。</li>
<li>盖章点是磁盘访问的人口，是一个目录</li>
<li>相对路径与绝对路径</li>
</ol>

<p><strong>Linux目录结构</strong></p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# tree -L 1 /
/
├── bin             #普通用户的二进制命令
├── boot            #系统内核及引导程序目录
├── dev             #设备文件目录
├── etc             #软件配置和启动程序目录
├── home            #普通用户家目录
├── lib             #库文件目录(命令、软件)
├── lib64           #64位库文件目录(命令、软件)
├── lost+found      #系统崩溃数据存放的目录
├── media
├── mnt             #设备临时挂载目录
├── opt             #第三方程序
├── proc            #操作系统进程和内核信息目录
├── root            #root家目录
├── sbin            #系统管理员命令
├── selinux         
├── srv
├── sys
├── tmp             #文件临时存放目录(回收站)
├── usr             #应用程序目录
└── var             #日志目录
#查看命令的路径
[root@test ~]# which ls
alias ls=&#39;ls --color=auto&#39;
    /bin/ls
</code></pre>

<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>/bin</td>
<td>该目录为binaries,是常用二进制命令所在的目录。列入：ls、cp、mkdir、rm等命令；/bin目录和/usr/bin类似</td>
</tr>
<tr>
<td>/boot</td>
<td>Linux的内核级系统引导程序所需的文件目录，安装系统分区的时候一般单独分一个boot分区。</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件目录，比如声卡、磁盘、光驱等等外接设备。</td>
</tr>
<tr>
<td>/etc</td>
<td>(1)二进制软件安装包(yum,rpm)等的配置文件默认路径，例如:/etc/exports、/etc/fstab、/etc/resolv.conf (2)服务启动命令存放的目录，主要在/etc/init.d/下。例如：/etc/init.d/sshd、/etc/init.d/iptables</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录默认数据库存放目录</td>
</tr>
<tr>
<td>/lib</td>
<td>启动系统和运行命令所需要的共享库文件和内核模块存放目录，分为/lib和/lib64两种。</td>
</tr>
<tr>
<td>/lost+found</td>
<td>在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题，可能会有文件被移到这个目录中，可能需要手工方式修复，移到文件到原来的位置上。</td>
</tr>
<tr>
<td>/mnt</td>
<td>一般是用于临时挂载存储设备的挂载点，比如有cdrom，u盘等目录。直接插入光驱无法使用，需要先挂载后使用。</td>
</tr>
<tr>
<td>/opt</td>
<td>表示的是可选择的意思，有邪软件包会被安装在这里，也就是自定义软件包。我们自己编译的软件包，就可以安装在这个目录；通过源码包安装的软件，可以通过./configure --prefix=/opt/指定目录。</td>
</tr>
<tr>
<td>/proc</td>
<td>操作系统运行时，进程信息及内核信息(cpu、硬盘信息、内存信息)存放在这里。/proc目录是虚拟文件系统的挂载点，proc并不是真正的文件系统，它的定义可以参见/etc/fstab。系统运行很多信息都在这个目录下。 /proc/loadavg #系统负载信息 /proc/meminfo #系统内存信息 /proc/cpuinfo #系统CPU信息 /proc/mounts #系统挂载信息</td>
</tr>
<tr>
<td>/root</td>
<td>Linux超级权限用户root的加目录:root类似win32管理员admininstrator</td>
</tr>
<tr>
<td>/sbin</td>
<td>大多是涉及系统管理的命令存放，是超级权限用户root的可执行命令存放地，这个目录和/usr/X11R6/sbin或/usr/loacl/sbin目录是相似的;系统级命令，一般最好要通过sudo让普通用户执行这些命令，常见命令有fdisk、reboot、fsck、halt</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录，有时用户运行程序时候，会产生临时文件。/tmp就用来存放临时文件的，权限比较特殊。/var/tmp目录和这个目录相似，这个目录可以被用作Linux系统的回收站使用。</td>
</tr>
<tr>
<td>/usr</td>
<td>这是系统存放程序的目录，比如命令，帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux官方提供的软件包时，安装在这里。 /user/local：默认软件安装目录 /usr/src:长袖源码目录</td>
</tr>
<tr>
<td>/var</td>
<td>日志目录</td>
</tr>
</tbody>
</table>

<hr/>

<p><strong>Linux系统重要文件</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align: center">网卡配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0 #第一块网卡逻辑设备名，第二块为eth1
HWADDR=00:0c:29:6a:a3:b4 #以太网硬件地址MAC地址
TYPE=Ethernet #上网类型，目前基本上是以太网
UUID=282f8f61-2b18-4cdb-8ba5-62c8131abd20 #通用唯一识别码
ONBOOT=yes  #开机启动激活网卡设备yes(启动) no(不启动)
NM_CONTROLLED=yes #是否通过networkmanager管理网卡设备
BOOTPROTO=none  #启动协议，获取配置方式，有none|bootp|dhcp 三个选项
IPADDR=10.0.0.7 #IP地址
NETMASK=255.255.255.0 #子网掩码
DNS2=202.106.0.20   #DNS2
GATEWAY=10.0.0.2    #网关
DNS1=10.0.0.2       #DNS1
USERCTL=no          #是否支持用户控制
PEERDNS=yes         #网卡配置DNS 会覆盖/etc/resolv.conf文件的DNS
IPV6INIT=no         #是否支持IPv6
</code></pre>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/resolv.conf</td>
<td style="text-align: center">系统DNS客户端配置文件</td>
</tr>
</tbody>
</table>

<p>DNS,全称Domain Name System，一个网站运行中起到至关重要的作用，它的主要作用是负责吧网站域名解析为对应的IP地址。</p>

<p>DNS系统解析功能：</p>

<ul>
<li> (1)DNS 系统负责A记录解析，就是域名到IP。</li>
<li> (2)设置CNAME别名记录，这别名解析功能常被CDN加速服务商应用</li>
<li> (3)设置MX邮件记录，这个记录功能，在购买或搭建邮件服务时会经常被用到</li>
<li> (4)设置PTR 记录，反向解析，即吧IP地址解析为对应域名和A记录的解析相反，邮寄服务等业务会用到</li>
</ul>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/resolv.conf

nameserver 10.0.0.2
nameserver 202.106.0.20
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th style="text-align: left">文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">/etc/sysconfig/network</td>
<td style="text-align: center">主机名配置文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test
</code></pre>

<p>修改方法：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=test1 #永久修改
[root@test ~]# hostname test1 临时修改
#企业环境永久修改生效需要重启服务器基本的是永久加上临时二个方法配合使用需要操作两次，为了不重启
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.local</td>
<td style="text-align: center">存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>/etc/rc.local是用于存放开机自启动程序命令的文件(chkconfig常用来管理yum/rpm安装的程序服务的开机自启动)如果是开发的自己程序需要开机启动命令放入/etc/rc.local来实现开机自启动，Linux开机会吧/etc/rc.local里面的内容全部执行一遍。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th style="text-align: center">文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/hosts</td>
<td style="text-align: center">局域网或者本地DNS解析工具</td>
</tr>
</tbody>
</table>

<p>应用场景：</p>

<ol>
<li>域名对应服务所在的服务器出现IP变化时候</li>
<li>进行本地测试</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/fstab</td>
<td>配置开机实现设备自动挂载程序命令的文件</td>
</tr>
</tbody>
</table>

<p>添加新的磁盘后实现开机自动挂载设备：cat /etc/fstab共六列如下：</p>

<p>例：sysfs /sys sysfs defaults 0 0</p>

<ol>
<li>第一列sysfs (挂载的设备名称)</li>
<li>第二列/sys(挂载的目录)</li>
<li>第三列sysfs(挂载的文件系统格式)</li>
<li>第四列defaults(挂载参数)</li>
<li>第五列0(是否备份:0为不备份，1为备份)</li>
<li>第六列0(是否开机做磁盘检测，0为不检测数字1,2的为检测磁盘)，工作场景通常的设为了，为了避免重启无法启动。</li>
</ol>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/rc.loacl</td>
<td>存放开机自启动程序命令文件</td>
</tr>
</tbody>
</table>

<p>企业中主要应用：脚本和自主开发程序启动命令存放处，实现开机程序自动启动和运行。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/inittab</td>
<td>系统运行级别的配置文件</td>
</tr>
</tbody>
</table>

<p>0 - halt (Do NOT set initdefault to this)： (<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%85%B3%E6%9C%BA%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{关机模式}"/>)</p>

<p>1 - Single user mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{单用户模式}"/>)</p>

<p>2 - Multiuser, without NFS (The same as 3, if you do not have networking):(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FNFS%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{没有网络文件系统NFS的多用户模式}"/>)</p>

<p>3 - Full multiuser mode：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{完整的多用户模式}"/>)</p>

<p>4 - unused：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%9C%AA%E4%BD%BF%E7%94%A8%7D" alt="\color{green}{未使用}"/>)</p>

<p>5 - X11：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{桌面模式}"/>)</p>

<p>6 - reboot (Do NOT set initdefault to this)：(<img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E9%87%8D%E5%90%AF%E6%A8%A1%E5%BC%8F%7D" alt="\color{green}{重启模式}"/>)</p>

<p>查看当前的运行级别：runlevel</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# runlevel 
N 3
#N是上一次运行级别，3是当前运行级别
</code></pre>

<p>切换运行级别：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# init 5
[root@test ~]# runlevel 
3 5
#init 命令接后面的数字级别
</code></pre>

<p>开机启动流程图：</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234025.png" alt="img"/></p>

<p>Linux系统启动配置文件：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/grub.conf 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/sda3
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.32-754.30.2.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-754.30.2.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-754.30.2.el6.x86_64.img
title CentOS 6 (2.6.32-696.el6.x86_64)
    root (hd0,0)
    kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=UUID=24219a66-7b4f-477e-b8c4-a008809c45f5 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /initramfs-2.6.32-696.el6.x86_64.img
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile及/etc/bashrc(~/.bashrc)</td>
<td>配置系统的环境变量/别名文件</td>
</tr>
</tbody>
</table>

<p>企业环境设置案例：</p>

<pre class="line-numbers"><code class="language-shell">#环境变量设置：
vim /etc/profile

#set java environment
JAVA_HOME=/usr/local/java/jdk1.8.0_161
JRE_HOME=$JAVA_HOME/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
#重新加载/etc/profile文件，让配置生效
source /etc/profile
#测试安装是否成功
java -version

#系统别名设置:
# User specific aliases and functions

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
#让系统别名永久生效，需要配置到的文件
</code></pre>

<p>环境变量文件生效顺序图：/etc/bashrc &gt; ~/.bashrc &gt; ~/bash_profile &gt; /etc/profile</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234032.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/profile.d</td>
<td>用户登录后执行的脚本所在目录</td>
</tr>
</tbody>
</table>

<ol>
<li>在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，而这些脚本文件是用来设置一些变量和运行一些初始化过程的。其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</li>
<li>/etc/profile.d 下的脚本之所以能自动执行，是因为在/etc/profile 中有一个for循环语句来调用这些脚本。</li>
</ol>

<pre class="line-numbers"><code class="language-shell">vi /etc/profile
# /etc/profile
 
for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r &quot;$i&quot; ]; then
        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then
            . &quot;$i&quot;
        else
            . &quot;$i&quot; &gt;/dev/null
        fi
    fi
done
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/issue和/etc/issue.net</td>
<td>配置在用户登录终端前显示信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
.............................................................................
[root@test ~]# cat /etc/issue.net 
CentOS release 6.10 (Final)
Kernel \r on an \m
</code></pre>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/init.d</td>
<td>软件启动和程序所在的目录</td>
</tr>
</tbody>
</table>

<p>/etc/init.d目录在Linux系统中可是大名鼎鼎。它只负责一件事情，但却涉及到全系统。它包含系统中各种服务的start/stop脚本，从acpid到x11-common，其重要性可见一斑。在/etc/init.d的可执行程序的优先级会高于/etc/systemd/system/下的service文件，如果同时存在的话。</p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/motd</td>
<td>配置用户登录系统之后显示提示内容的文件</td>
</tr>
</tbody>
</table>

<p>配置案例：</p>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/motd 
[root@test ~]# vim /etc/motd
test computer
</code></pre>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200909234041.png" alt="img"/></p>

<hr/>

<table>
<thead>
<tr>
<th>文件路径</th>
<th>文件功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>/etc/redhat-release</td>
<td>声明Red Hat版本和名称信息的文件</td>
</tr>
</tbody>
</table>

<pre class="line-numbers"><code class="language-shell">[root@test ~]# cat /etc/redhat-release 
CentOS release 6.10 (Final)
</code></pre>

<p>禁止转载，如需转载请通过简信或评论联系作者。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628569.html">
                
                  <h1>Python核心技术与实战：学习笔记(一)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">03|列表和元组，到底用哪一个？</h3>

<p>列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。</p>

<p>count(item) 表示统计列表 / 元组中 item 出现的次数。</p>

<p>index(item) 表示返回列表 / 元组中 item 第一次出现的索引。</p>

<p>list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个 函数)。</p>

<p>reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后 或者排好序的新的列表 / 元组。</p>

<pre class="line-numbers"><code class="language-python">l = [1, 2, 3]
l.__sizeof__()
#64
tup = (1, 2, 3)
tup.__sizeof__()
#48
</code></pre>

<pre class="line-numbers"><code class="language-python">l = []
l.__sizeof__() // 空列表的存储空间为 40 字节
40
l.append(1)
l.__sizeof__()
72 // 加入了元素 1 之后，列表为其分配了可以存储 4 个元素的空间 (72 - 40)/8 = 4
l.append(2)
l.__sizeof__()
72 // 由于之前分配了空间，所以加入元素 2，列表空间不变
l.append(3)
l.__sizeof__()
72 // 同上
l.append(4)
l.__sizeof__()
72 // 同上
l.append(5)
l.__sizeof__()
104 // 加入元素 5 之后，列表的空间不足，所以又额外分配了可以存储 4 个元素的空间
</code></pre>

<pre class="line-numbers"><code class="language-python">python3 -m timeit &#39;x=(1,2,3,4,5,6)&#39;
20000000 loops, best of 5: 9.97 nsec per loop
python3 -m timeit &#39;x=[1,2,3,4,5,6]&#39;
5000000 loops, best of 5: 50.1 nsec per loop
</code></pre>

<h3 id="toc_1">04 | 字典、集合，你真的了解吗？</h3>

<p>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一 样。</p>

<pre class="line-numbers"><code class="language-python">#字典和集合的创建方式
d1 = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}
d2 = dict({&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;})
d3 = dict([(&#39;name&#39;, &#39;jason&#39;), (&#39;age&#39;, 20), (&#39;gender&#39;, &#39;male&#39;)])
d4 = dict(name=&#39;jason&#39;, age=20, gender=&#39;male&#39;)
print(d1 == d2 == d3 ==d4)
# True
s1 = {1, 2, 3}
s2 = set([1, 2, 3])
print(s2)
# {1, 2, 3}
print(s1 == s2)
# True
</code></pre>

<p>字典访问可以直接索引键，如果不存在，就会抛出异常；也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回 一个默认值。</p>

<p>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一 样。</p>

<p>想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。</p>

<p>插入操作</p>

<p>每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。 而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两 个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。</p>

<p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始， 挨个往后寻找空位。当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣 可以查看源码，我就不再赘述），让这个步骤更加高效。 查找操作 和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希 表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如 果不等，则继续查找，直到找到空位或者抛出异常为止。</p>

<p>删除操作</p>

<p>对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希 表的大小时，再将其删除。 不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效 性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插 入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这 种情况下，表内所有的元素位置都会被重新排放。 虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所 以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。</p>

<h3 id="toc_2">05 | 深入浅出字符串</h3>

<p>常见的的转义字符</p>

<p>Python 的字符串是不可变的（immutable），Python 中字符串的改变，通常只能通过创建新的字符串来完成。</p>

<pre class="line-numbers"><code class="language-python">s=&#39;HKSIHh&#39;
s = &#39;H&#39; + s[1:]
s = s.replace(&#39;h&#39;, &#39;H&#39;
</code></pre>

<p>你可能了解到，在其他语言中，如 Java，有可变的字符串类型，比如 StringBuilder，每次 添加、改变或删除字符（串），无需创建新的字符串，时间复杂度仅为 O(1)。这样就大大 提高了程序的运行效率。 但可惜的是，Python 中并没有相关的数据类型，我们还是得老老实实创建新的字符串。因 此，每次想要改变字符串，往往需要 O(n) 的时间复杂度，其中，n 为新字符串的长度。</p>

<pre class="line-numbers"><code class="language-python">s = &#39;&#39;
for n in range(0, 100000):
 s += str(n)
</code></pre>

<p>自从 Python2.5 开始，每次处理字符串的拼接操作时（str1 += str2），Python 首先会检 测 str1 还有没有其他的引用。如果没有的话，就会尝试原地扩充字符串 buffer 的大小，而 不是重新分配一块内存来创建新的字符串并拷贝。</p>

<p>这样的话，上述例子中的时间复杂度就仅 为 O(n) 了。</p>

<p>因此，以后你在写程序遇到字符串拼接时，如果使用’+=&#39;更方便，就放心地去用吧，不用 过分担心效率问题了。 另外，对于字符串拼接问题，除了使用加法操作符，我们还可以使用字符串内置的 join 函 数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来。</p>

<pre class="line-numbers"><code class="language-python">l = []
for n in range(0, 100000):
 l.append(str(n))
l = &#39; &#39;.join(l) 

#由于列表的 append 操作是 O(1) 复杂度，字符串同理。因此，这个含有 for 循环例子的时
间复杂度为 n*O(1)=O(n)。
</code></pre>

<p>string.strip(str)，表示去掉首尾的 str 字符串； string.lstrip(str)，表示只去掉开头的 str 字符串； string.rstrip(str)，表示只去掉尾部的 str 字符串。</p>

<h3 id="toc_3">06 | Python “黑箱”：输入与输出</h3>

<p>让我们来做一个简单的 NLP（自然语言处理）任务。如果你对此不太了解也没有影 响，我会带你一步步完成这个任务。</p>

<p>首先，我们要清楚 NLP 任务的基本步骤，也就是下面的四步： 1. 读取文件； 2. 去除所有标点符号和换行符，并把所有大写变成小写； 3. 合并相同的词，统计每个词出现的频率，并按照词频从大到小排序； 4. 将结果按行输出到文件 out.txt。 你可以自己先思考一下，用 Python 如何解决这个问题。这里，我也给出了我的代码，并附 有详细的注释。我们一起来看下这段代码。</p>

<pre class="line-numbers"><code class="language-python">import re
# 你不用太关心这个函数
def parse(text):
 # 使用正则表达式去除标点符号和换行符
     text = re.sub(r&#39;[^\w ]&#39;, &#39; &#39;, text)
     # 转为小写
     text = text.lower()

     # 生成所有单词的列表
     word_list = text.split(&#39; &#39;)

     # 去除空白单词
     word_list = filter(None, word_list)

     # 生成单词和词频的字典
     word_cnt = {}
     for word in word_list:
         if word not in word_cnt:
            word_cnt[word] = 0
            word_cnt[word] += 1

     # 按照词频排序
     sorted_word_cnt = sorted(word_cnt.items(), key=lambda kv: kv[1], reverse=True)

     return sorted_word_cnt
with open(&#39;in.txt&#39;, &#39;r&#39;) as fin:
    text = fin.read()
word_and_freq = parse(text)
with open(&#39;out.txt&#39;, &#39;w&#39;) as fout:
   for word, freq in word_and_freq:
       fout.write(&#39;{} {}\n&#39;.format(word, freq))
</code></pre>

<h3 id="toc_4">07 | 修炼基本功：条件与循环</h3>

<p>不过，切记，在实际写代码时，我们鼓励，除了 boolean 类型的数据，条件判断最好是显 性的。比如，在判断一个整型数是否为 0 时，我们最好写出判断的条件：</p>

<pre class="line-numbers"><code class="language-pass">if i != 0:
 ...
 
#不推荐的写法：
if i:
...
</code></pre>

<pre class="line-numbers"><code class="language-swift">l = [1, 2, 3, 4, 5, 6, 7]
for index, item in enumerate(l):
    if index &lt; 5:
        print(item) 
</code></pre>

<p>在循环语句中，我们还常常搭配 continue 和 break 一起使用。所谓 continue，就是让程 序跳过当前这层循环，继续执行下面的循环；而 break 则是指完全跳出所在的整个循环 体。在循环中适当加入 continue 和 break，往往能使程序更加简洁、易读。</p>

<p>range() 函数是直接由 C 语言写的，调用它速度非常快。而 while 循环中的“i += 1”这个操作，得通过 Python 的解释器间接调用底层的 C 语言；并且这个简单的操 作，又涉及到了对象的创建和删除（因为 i 是整型，是 immutable，i += 1 相当于 i = new int(i + 1)）。所以，显然，for 循环的效率更胜一筹。</p>

<h3 id="toc_5">08 | 异常处理：如何提高程序的稳定性？</h3>

<pre class="line-numbers"><code class="language-python">class MyInputError(Exception):
 &quot;&quot;&quot;Exception raised when there&#39;re errors in input&quot;&quot;&quot;
     def __init__(self, value): # 自定义异常类型的初始化
        self.value = value
     def __str__(self): # 自定义异常类型的 string 表达形式
        return (&quot;{} is invalid input&quot;.format(repr(self.value)))

try:
    raise MyInputError(1) # 抛出 MyInputError 这个异常
except MyInputError as err:
    print(&#39;error: {}&#39;.format(err))
</code></pre>

<p>异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用 try except 语句去处理异常，这样程序就不会被终止，仍能继续执行。 处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在 finally block 中。 异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数 据库的连接、读取等等。正常的 flow-control 逻辑，不要使用异常处理，直接用条件语 句解决就可以了。</p>

<h3 id="toc_6">09 | 不可或缺的自定义函数</h3>

<pre class="line-numbers"><code class="language-python">def find_largest_element(l):
    if not isinstance(l, list):
        print(&#39;input is not type of list&#39;)
    return

if len(l) == 0:
    print(&#39;empty input&#39;)
    return
    largest_element = l[0]
    for item in l:
        if item &gt; largest_element:
            largest_element = item
    print(&#39;largest element is: {}&#39;.format(largest_element))

find_largest_element([8, 1, -3, 2, 0])
# 输出
# largest
# element is: 8
</code></pre>

<pre class="line-numbers"><code class="language-python">def outer():
    x = &quot;local&quot;

    def inner():

        nonlocal x  # nonlocal 关键字表示这里的 x 就是外部函数 outer 定义的变量 x
    x = &#39;nonlocal&#39;
    print(&quot;inner:&quot;, x)
    inner()
    print(&quot;outer:&quot;, x)

outer()
# 输出
inner:
nonlocal
outer:
nonlocal
</code></pre>

<pre class="line-numbers"><code class="language-python">def nth_power(exponent):
    def exponent_of(base):
        return base ** exponent

    return exponent_of  # 返回值是 exponent_of 函数


square = nth_power(2)  # 计算一个数的平方
cube = nth_power(3)  # 计算一个数的立方
# square
# # 输出
# &lt; function
# __main__.nth_power. &lt; locals &gt;.exponent(base) &gt;
# cube
# # 输出
# &lt; function
# __main__.nth_power. &lt; locals &gt;.exponent(base) &gt;
# print(square(2))  # 计算 2 的平方
# print(cube(2))  # 计算 2 的立方
# # 输出
# 4  # 2^2
# 8  # 2^3
</code></pre>

<ol>
<li>Python 中函数的参数可以接受任意的数据类型，使用起来需要注意，必要时请在函数开 头加入数据类型的检查；</li>
<li>.和其他语言不同，Python 中函数的参数可以设定默认值；</li>
<li>嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；</li>
<li>合理地使用闭包，则可以简化程序的复杂度，提高可读性。</li>
</ol>

<h3 id="toc_7">10 | 简约不简单的匿名函数</h3>

<p>函数 map(function, iterable) 的第一个参数是函数对象，第二个参 数是一个可以遍历的集合，它表示对 iterable 的每一个元素，都运用 function 这个函数。</p>

<pre class="line-numbers"><code class="language-bash">python3 -mtimeit -s&#39;xs=range(1000000)&#39; &#39;map(lambda x: x*2, xs)&#39;
# 2000000 loops, best of 5: 171 nsec per loop
python3 -mtimeit -s&#39;xs=range(1000000)&#39; &#39;[x * 2 for x in xs]&#39;
# 5 loops, best of 5: 62.9 msec per loop
python3 -mtimeit -s&#39;xs=range(1000000)&#39; &#39;l = []&#39; &#39;for i in xs: l.append(i * 2)&#39;
# 5 loops, best of 5: 92.7 msec per loop
</code></pre>

<p>filter(function, iterable) 函数，它和 map 函数类似，function 同样表示一个 函数对象。filter() 函数表示对 iterable 中的每个元素，都使用 function 判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。</p>

<pre class="line-numbers"><code class="language-python">l = [1, 2, 3, 4, 5]
new_list = filter(lambda x: x % 2 == 0, l) # [2, 4]
</code></pre>

<p>最后我们来看 reduce(function, iterable) 函数，它通常用来对一个集合做一些累积操作。 function 同样是一个函数对象，规定它有两个参数，表示对 iterable 中的每个元素以及上 一次调用后的结果，运用 function 进行计算，所以最后返回的是一个单独的数值。</p>

<pre class="line-numbers"><code class="language-python">l = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, l) # 1*2*3*4*5 = 120
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15998025630555.html">高效 PyCharm 使用技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630642.html">群晖NAS安装配置typecho博客教程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630684.html">Linux vim 编辑器的神级配置 vimrc</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630725.html">正则表达式工具 RegexBuddy 使用指南</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025630768.html">使用Docker搭建MySQL服务</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
