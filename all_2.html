<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16177587144617.html">
                
                  <h1>MAC上Homebrew常用命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">一、官方网址</h3>

<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbrew.sh%2F">Homebrew</a></p>

<h3 id="toc_1">二、目录</h3>

<ul>
<li>  安装</li>
<li>  查看帮助信息</li>
<li>  查看版本</li>
<li>  更新Homebrew自己</li>
<li>  安装软件包</li>
<li>  查询可更新的包</li>
<li>  更新包 (formula)</li>
<li>  清理旧版本</li>
<li>  锁定不想更新的包</li>
<li>  卸载安装包</li>
<li>  查看包信息</li>
<li>  查看安装列表</li>
<li>  查询可用包</li>
<li>  卸载Homebrew</li>
</ul>

<h3 id="toc_2">三、常用命令</h3>

<ul>
<li>  安装</li>
</ul>

<pre class="line-numbers"><code class="language-csharp">//安装依赖工具
xcode-select --install

/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<ul>
<li>  查看帮助信息</li>
</ul>

<pre class="line-numbers"><code class="language-bash">brew help
</code></pre>

<ul>
<li>  查看版本</li>
</ul>

<pre class="line-numbers"><code class="language-undefined">brew -v
</code></pre>

<ul>
<li>  更新Homebrew自己</li>
</ul>

<pre class="line-numbers"><code class="language-undefined">brew update
</code></pre>

<ul>
<li>  安装软件包</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">brew install [包名]

//安装git
brew install git

//安装git-lfs
brew install git-lfs

//安装wget
brew install wget

//安装openssl
brew install openssl
</code></pre>

<ul>
<li>  查询可更新的包</li>
</ul>

<pre class="line-numbers"><code class="language-undefined">brew outdated
</code></pre>

<ul>
<li>  更新包 (formula)</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">//更新所有
brew upgrade

//更新指定包
brew upgrade [包名]
</code></pre>

<ul>
<li>  清理旧版本</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">//清理所有包的旧版本
brew cleanup 

//清理指定包的旧版本
brew cleanup [包名]

//查看可清理的旧版本包，不执行实际操作
brew cleanup -n 
</code></pre>

<ul>
<li>  锁定不想更新的包</li>
</ul>

<pre class="line-numbers"><code class="language-php">//锁定某个包
brew pin $FORMULA  
//取消锁定
brew unpin $FORMULA     
</code></pre>

<ul>
<li>  卸载安装包</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">brew uninstall [包名]

//例：卸载git
brew uninstall git
</code></pre>

<ul>
<li>  查看包信息</li>
</ul>

<pre class="line-numbers"><code class="language-css">brew info [包名]
</code></pre>

<ul>
<li>  查看安装列表</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">brew list
</code></pre>

<ul>
<li>  查询可用包</li>
</ul>

<pre class="line-numbers"><code class="language-css">brew search [包名]
</code></pre>

<ul>
<li>  卸载Homebrew</li>
</ul>

<pre class="line-numbers"><code class="language-jsx">cd `brew --prefix`
rm -rf Cellar
brew prune
rm `git ls-files`
rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions
rm -rf .git
rm -rf ~/Library/Caches/Homebrew
</code></pre>

<h3 id="toc_3">四、参考文章</h3>

<ul>
<li>  1、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004353419">你应该定期更新 Homebrew</a></li>
<li>  2、<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fandanlan%2Farticle%2Fdetails%2F51589800">Homebrew简介和基本使用</a></li>
<li>  3、<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fdelphiwcdj%2Farticle%2Fdetails%2F19679891">Mac上Homebrew的使用 (Homebrew 使 OS X 更完整)</a></li>
<li>  4、<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fazhou_hui%2Farticle%2Fdetails%2F49718511">HomeBrew的安装和简单使用</a></li>
<li>  5、<a href="https://www.jianshu.com/p/d229ac7fe77d">Mac OS下包管理器Homebrew的安装与使用</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15845003776446.html">
                
                  <h1>Mac下find命令常用语法总结</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Mac的文件管理是很难用，所以有些时候搜索东西我宁愿用命令的方式，便在此总结一下常用的。<br/>
首先，可以用</p>

<pre class="line-numbers"><code class="language-text">man find
</code></pre>

<p>查看find命令的种种选项和用法。全英文的，我知道绝大多数人肯定不爱看。于是我看了这个之后，结合自己的一些实践，总结了一些常用的方法。并且把全文附在了本文末尾。</p>

<h4 id="toc_0">概述：</h4>

<p>find命令递归地为列出的每个路径下拉目录树，根据树中的每个文件计算表达式(由下面列出的&#39;&#39; primary &#39;和&#39;&#39; operands&#39;组成)。</p>

<h4 id="toc_1">基本操作：</h4>

<pre class="line-numbers"><code class="language-text">find 文件路径 参数
</code></pre>

<h4 id="toc_2">例子：</h4>

<ol>
<li> 在当前目录下(包含子目录)搜索文件名包含cynthia的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -name &quot;cynthia&quot;
</code></pre>

<ol>
<li> 搜索文件后缀不是.py的文件并打印出来。注意这里!的用法，用了转义符\</li>
</ol>

<pre class="line-numbers"><code class="language-text">find ~/Cynthia/ \! -name &quot;*.py&quot; -print
</code></pre>

<ol>
<li> 类似的，上面是搜索文件后缀是.py的文件</li>
</ol>

<pre class="line-numbers"><code class="language-text">find ~/Cynthia/ -name &quot;*.py&quot; -print
</code></pre>

<ol>
<li> 在当前目录下，搜索属于用户cynthia，且比文件190505demo的时间新的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -newer 190505demo -user cynthia -print
</code></pre>

<ol>
<li> 类似的，下面这个命令就是搜索既不属于用户cynthia也不比文件190505demo的时间新的文件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . \! \( -newer 190505demo -user cynthia \) -print
</code></pre>

<ol>
<li> 打印出当前目录下的所有文件</li>
</ol>

<pre class="line-numbers"><code class="language-text">find . -type f -exec echo {} \;
</code></pre>

<h4 id="toc_3">附录</h4>

<p>man find命令给出的全文。</p>

<pre class="line-numbers"><code class="language-text">Cynthias-MacBook-Pro:/ cynthia$ man find
NAME
     find -- walk a file hierarchy

SYNOPSIS
     find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]
     find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]

DESCRIPTION
     The find utility recursively descends the directory tree for each path listed, evaluating an expression (composed of the ``primaries&#39;&#39; and ``operands&#39;&#39; listed below) in terms of each file in the tree.

     The options are as follows:

     -E      Interpret regular expressions followed by -regex and -iregex primaries as extended (modern) regular expressions rather than basic regular expressions (BRE&#39;s).  The re_format(7) manual page fully describes both formats.

     -H      Cause the file information and file type (see stat(2)) returned for each symbolic link specified on the command line to be those of the file referenced by the link, not the link itself.  If the referenced file does not exist, the file information and type will be for the link itself.  File information of all symbolic links not on the command line is that of the link itself.

     -L      Cause the file information and file type (see stat(2)) returned for each symbolic link to be those of the file referenced by the link, not the link itself.  If the referenced ile does not exist, the file information and type will be for the link itself.

             This option is equivalent to the deprecated -follow primary.

     -P      Cause the file information and file type (see stat(2)) returned for each symbolic link to be those of the link itself.  This is the default.

     -X      Permit find to be safely used in conjunction with xargs(1).  If a file name contains any of the delimiting characters used by xargs(1), a diagnostic message is displayed on standard error, and the file is skipped.  The delimiting characters include single (`` &#39; &#39;&#39;) and double (`` &quot; &#39;&#39;) quotes, backslash (``\&#39;&#39;), space, tab and newline characters.

             However, you may wish to consider the -print0 primary in conjunction with ``xargs -0&#39;&#39; as an effective alternative.

     -d      Cause find to perform a depth-first traversal, i.e., directories are visited in postorder and all entries in a directory will be acted on before the directory itself.  By default, find visits directories in pre-order, i.e., before their contents.  Note, the default is not a breadth-first traversal.

             This option is equivalent to the -depth primary of IEEE Std 1003.1-2001 (``POSIX.1&#39;&#39;).
             The -d option can be useful when find is used with cpio(1) to process files that are contained in directories with unusual permissions.  It ensures that you have write permission while you are placing files in a directory, then sets the directory&#39;s permissions as the last thing.

     -f      Specify a file hierarchy for find to traverse.  File hierarchies may also be specified as the operands immediately following the options.

     -s      Cause find to traverse the file hierarchies in lexicographical order, i.e., alphabetical order within each directory.  Note: `find -s&#39; and `find | sort&#39; may give different results.

     -x      Prevent find from descending into directories that have a device number different than that of the file from which the descent began.

             This option is equivalent to the deprecated -xdev primary.

PRIMARIES
     All primaries which take a numeric argument allow the number to be preceded by a plus sign (``+&#39;&#39;) or a minus sign (``-&#39;&#39;).  A preceding plus sign means ``more than n&#39;&#39;, a preceding minus sign means ``less than n&#39;&#39; and neither means ``exactly n&#39;&#39;.

     -Bmin n
             True if the difference between the time of a file&#39;s inode creation and the time find was started, rounded up to the next full minute, is n minutes.

     -Bnewer file
             Same as -newerBm.

     -Btime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the time of a file&#39;s inode creation and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the time of a file&#39;s inode creation and the time find was started is exactly n units.
             Please refer to the -atime primary description for information on supported time units.

     -acl    May be used in conjunction with other primaries to locate files with extended ACLs.
             See acl(3) for more information.

     -amin n
             True if the difference between the file last access time and the time find was started, rounded up to the next full minute, is n minutes.

     -anewer file
             Same as -neweram.

     -atime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the file last access time and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the file last access time and the time find was started is exactly n units.  Possible time units are as follows:

             s       second
             m       minute (60 seconds)
             h       hour (60 minutes)
             d       day (24 hours)
             w       week (7 days)

             Any number of units may be combined in one -atime argument, for example, ``-atime -1h30m&#39;&#39;.  Units are probably only useful when used in conjunction with the + or - modfier.

     -cmin n
             True if the difference between the time of last change of file status information and the time find was started, rounded up to the next full minute, is n minutes.

     -cnewer file
             Same as -newercm.

     -ctime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the ime of last change of file status information and the time find was started, rounded up to the next full 24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the time of last change of file status information and the time find was started is exactly n units.  Please refer to the -atime primary description for information on supported time units.

     -d      Same as depth.  GNU find implements this as a primary in mistaken emulation of FreeBSD
             find(1).

     -delete
             Delete found files and/or directories.  Always returns true.  This executes from the current working directory as find recurses down the tree.  It will not attempt to delete a filename with a ``/&#39;&#39; character in its pathname relative to ``.&#39;&#39; for security reasons.  Depth-first traversal processing is implied by this option.  Following syminks is incompatible with this option.

     -depth  Always true; same as the -d option.

     -depth n
             True if the depth of the file relative to the starting point of the traversal is n.

     -empty  True if the current file or directory is empty.

     -exec utility [argument ...] ;
             True if the program named utility returns a zero value as its exit status.  Optional arguments may be passed to the utility.  The expression must be terminated by a semicolon (``;&#39;&#39;).  If you invoke find from a shell you may need to quote the semicolon if
             the shell would otherwise treat it as a control operator.  If the string ``{}&#39;&#39; appears anywhere in the utility name or the arguments it is replaced by the pathname of the current file.  Utility will be executed from the directory from which find was executed.  Utility and arguments are not subject to the further expansion of shell patterns and constructs.

     -exec utility [argument ...] {} +
             Same as -exec, except that ``{}&#39;&#39; is replaced with as many pathnames as possible for each invocation of utility.  This behaviour is similar to that of xargs(1).

     -execdir utility [argument ...] ;
             The -execdir primary is identical to the -exec primary with the exception that utility will be executed from the directory that holds the current file.  The filename substituted for the string ``{}&#39;&#39; is not qualified.

     -execdir utility [argument ...] {} +
             Same as -execdir, except that ``{}&#39;&#39; is replaced with as many pathnames as possible for each invocation of utility.  This behaviour is similar to that of xargs(1).

     -flags [-|+]flags,notflags
             The flags are specified using symbolic names (see chflags(1)).  Those with the &quot;no&quot; refix (except &quot;nodump&quot;) are said to be notflags.  Flags in flags are checked to be set, and flags in notflags are checked to be not set.  Note that this is different from
             -perm, which only allows the user to specify mode bits that are set.

             If flags are preceded by a dash (``-&#39;&#39;), this primary evaluates to true if at least all of the bits in flags and none of the bits in notflags are set in the file&#39;s flags bits.
             If flags are preceded by a plus (``+&#39;&#39;), this primary evaluates to true if any of the bits in flags is set in the file&#39;s flags bits, or any of the bits in notflags is not set in the file&#39;s flags bits.  Otherwise, this primary evaluates to true if the bits in flags exactly match the file&#39;s flags bits, and none of the flags bits match those of
             notflags.

     -fstype type
             True if the file is contained in a file system of type type.  The lsvfs(1) command can
             be used to find out the types of file systems that are available on the system.  In
             addition, there are two pseudo-types, ``local&#39;&#39; and ``rdonly&#39;&#39;.  The former matches any
             file system physically mounted on the system where the find is being executed and the
             latter matches any file system which is mounted read-only.

     -gid gname
             The same thing as -group gname for compatibility with GNU find.  GNU find imposes a
             restriction that gname is numeric, while find(1) does not.

     -group gname
             True if the file belongs to the group gname.  If gname is numeric and there is no such
             group name, then gname is treated as a group ID.

     -ignore_readdir_race
             This option is for GNU find compatibility and is ignored.

     -ilname pattern
             Like -lname, but the match is case insensitive.  This is a GNU find extension.

     -iname pattern
             Like -name, but the match is case insensitive.

     -inum n
             True if the file has inode number n.

     -ipath pattern
             Like -path, but the match is case insensitive.

     -iregex pattern
             Like -regex, but the match is case insensitive.

     -iwholename pattern
             The same thing as -ipath, for GNU find compatibility.

     -links n
             True if the file has n links.

     -lname pattern
             Like -name, but the contents of the symbolic link are matched instead of the file name.
             Note that this only matches broken symbolic links if symbolic links are being followed.
             This is a GNU find extension.

     -ls     This primary always evaluates to true.  The following information for the current file
             is written to standard output: its inode number, size in 512-byte blocks, file permis-
             sions, number of hard links, owner, group, size in bytes, last modification time, and
             pathname.  If the file is a block or character special file, the device number will be
             displayed instead of the size in bytes.  If the file is a symbolic link, the pathname
             of the linked-to file will be displayed preceded by ``-&gt;&#39;&#39;.  The format is identical to
             that produced by ``ls -dgils&#39;&#39;.

     -maxdepth n
             Always true; descend at most n directory levels below the command line arguments.  If
             any -maxdepth primary is specified, it applies to the entire expression even if it
             would not normally be evaluated.  ``-maxdepth 0&#39;&#39; limits the whole search to the com-
             mand line arguments.

     -mindepth n
             Always true; do not apply any tests or actions at levels less than n.  If any -mindepth
             primary is specified, it applies to the entire expression even if it would not normally
             be evaluated.  ``-mindepth 1&#39;&#39; processes all but the command line arguments.

     -mmin n
             True if the difference between the file last modification time and the time find was
             started, rounded up to the next full minute, is n minutes.

     -mnewer file
             Same as -newer.

     -mount  The same thing as -xdev, for GNU find compatibility.

     -mtime n[smhdw]
             If no units are specified, this primary evaluates to true if the difference between the
             file last modification time and the time find was started, rounded up to the next full
             24-hour period, is n 24-hour periods.

             If units are specified, this primary evaluates to true if the difference between the
             file last modification time and the time find was started is exactly n units.  Please
             refer to the -atime primary description for information on supported time units.

     -name pattern
             True if the last component of the pathname being examined matches pattern.  Special
             shell pattern matching characters (``[&#39;&#39;, ``]&#39;&#39;, ``*&#39;&#39;, and ``?&#39;&#39;) may be used as part
             of pattern.  These characters may be matched explicitly by escaping them with a back-
             slash (``\&#39;&#39;).

     -newer file
             True if the current file has a more recent last modification time than file.

     -newerXY file
             True if the current file has a more recent last access time (X=a), inode creation time
             (X=B), change time (X=c), or modification time (X=m) than the last access time (Y=a),
             inode creation time (Y=B), change time (Y=c), or modification time (Y=m) of file.  In
             addition, if Y=t, then file is instead interpreted as a direct date specification of
             the form understood by cvs(1).  Note that -newermm is equivalent to -newer.

     -nogroup
             True if the file belongs to an unknown group.

     -noignore_readdir_race
             This option is for GNU find compatibility and is ignored.

     -noleaf
             This option is for GNU find compatibility.  In GNU find it disables an optimization not
             relevant to find(1), so it is ignored.

     -nouser
             True if the file belongs to an unknown user.

     -ok utility [argument ...] ;
             The -ok primary is identical to the -exec primary with the exception that find requests
             user affirmation for the execution of the utility by printing a message to the terminal
             and reading a response.  If the response is not affirmative (`y&#39; in the ``POSIX&#39;&#39;
             locale), the command is not executed and the value of the -ok expression is false.

     -okdir utility [argument ...] ;
             The -okdir primary is identical to the -execdir primary with the same exception as
             described for the -ok primary.

     -path pattern
             True if the pathname being examined matches pattern.  Special shell pattern matching
             characters (``[&#39;&#39;, ``]&#39;&#39;, ``*&#39;&#39;, and ``?&#39;&#39;) may be used as part of pattern.  These
             characters may be matched explicitly by escaping them with a backslash (``\&#39;&#39;).
             Slashes (``/&#39;&#39;) are treated as normal characters and do not have to be matched explic-
             itly.

     -perm [-|+]mode
             The mode may be either symbolic (see chmod(1)) or an octal number.  If the mode is sym-
             bolic, a starting value of zero is assumed and the mode sets or clears permissions
             without regard to the process&#39; file mode creation mask.  If the mode is octal, only
             bits 07777 (S_ISUID | S_ISGID | S_ISTXT | S_IRWXU | S_IRWXG | S_IRWXO) of the file&#39;s
             mode bits participate in the comparison.  If the mode is preceded by a dash (``-&#39;&#39;),
             this primary evaluates to true if at least all of the bits in the mode are set in the
             file&#39;s mode bits.  If the mode is preceded by a plus (``+&#39;&#39;), this primary evaluates to
             true if any of the bits in the mode are set in the file&#39;s mode bits.  Otherwise, this
             primary evaluates to true if the bits in the mode exactly match the file&#39;s mode bits.
             Note, the first character of a symbolic mode may not be a dash (``-&#39;&#39;).

     -print  This primary always evaluates to true.  It prints the pathname of the current file to
             standard output.  If none of -exec, -ls, -print, -print0, or -ok is specified, the
             given expression shall be effectively replaced by ( given expression ) -print.

     -print0
             This primary always evaluates to true.  It prints the pathname of the current file to
             standard output, followed by an ASCII NUL character (character code 0).

     -prune  This primary always evaluates to true.  It causes find to not descend into the current
             file.  Note, the -prune primary has no effect if the -d option was specified.

     -regex pattern
             True if the whole path of the file matches pattern using regular expression.  To match
             a file named ``./foo/xyzzy&#39;&#39;, you can use the regular expression ``.*/[xyz]*&#39;&#39; or
             ``.*/foo/.*&#39;&#39;, but not ``xyzzy&#39;&#39; or ``/foo/&#39;&#39;.

     -samefile name
             True if the file is a hard link to name.  If the command option -L is specified, it is
             also true if the file is a symbolic link and points to name.

     -size n[ckMGTP]
             True if the file&#39;s size, rounded up, in 512-byte blocks is n.  If n is followed by a c,
             then the primary is true if the file&#39;s size is n bytes (characters).  Similarly if n is
             followed by a scale indicator then the file&#39;s size is compared to n scaled as:

             k       kilobytes (1024 bytes)
             M       megabytes (1024 kilobytes)
             G       gigabytes (1024 megabytes)
             T       terabytes (1024 gigabytes)
             P       petabytes (1024 terabytes)

     -type t
             True if the file is of the specified type.  Possible file types are as follows:

             b       block special
             c       character special
             d       directory
             f       regular file
             l       symbolic link
             p       FIFO
             s       socket

     -uid uname
             The same thing as -user uname for compatibility with GNU find.  GNU find imposes a
             restriction that uname is numeric, while find(1) does not.

     -user uname
             True if the file belongs to the user uname.  If uname is numeric and there is no such
             user name, then uname is treated as a user ID.

     -wholename pattern
             The same thing as -path, for GNU find compatibility.

     -xattr  True if the file has any extended attributes.

     -xattrname name
             True if the file has an extended attribute with the specified name.

OPERATORS
     The primaries may be combined using the following operators.  The operators are listed in order
     of decreasing precedence.

     ( expression )
             This evaluates to true if the parenthesized expression evaluates to true.

     ! expression
     -not expression
             This is the unary NOT operator.  It evaluates to true if the expression is false.

     -false  Always false.
     -true   Always true.

     expression -and expression
     expression expression
             The -and operator is the logical AND operator.  As it is implied by the juxtaposition
             of two expressions it does not have to be specified.  The expression evaluates to true
             if both expressions are true.  The second expression is not evaluated if the first
             expression is false.

     expression -or expression
             The -or operator is the logical OR operator.  The expression evaluates to true if
             either the first or the second expression is true.  The second expression is not evalu-
             ated if the first expression is true.

     All operands and primaries must be separate arguments to find.  Primaries which themselves take
     arguments expect each argument to be a separate argument to find.

ENVIRONMENT
     The LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES and LC_TIME environment variables affect
     the execution of the find utility as described in environ(7).

EXAMPLES
     The following examples are shown as given to the shell:

     find / \! -name &quot;*.c&quot; -print
             Print out a list of all the files whose names do not end in .c.

     find / -newer ttt -user wnj -print
             Print out a list of all the files owned by user ``wnj&#39;&#39; that are newer than the file
             ttt.
     find / \! \( -newer ttt -user wnj \) -print
             Print out a list of all the files which are not both newer than ttt and owned by
             ``wnj&#39;&#39;.

     find / \( -newer ttt -or -user wnj \) -print
             Print out a list of all the files that are either owned by ``wnj&#39;&#39; or that are newer
             than ttt.

     find / -newerct &#39;1 minute ago&#39; -print
             Print out a list of all the files whose inode change time is more recent than the cur-
             rent time minus one minute.

     find / -type f -exec echo {} \;
             Use the echo(1) command to print out a list of all the files.

     find -L /usr/ports/packages -type l -exec rm -- {} +
             Delete all broken symbolic links in /usr/ports/packages.

     find /usr/src -name CVS -prune -o -depth +6 -print
             Find files and directories that are at least seven levels deep in the working directory
             /usr/src.

     find /usr/src -name CVS -prune -o -mindepth 7 -print
             Is not equivalent to the previous example, since -prune is not evaluated below level
             seven.

COMPATIBILITY
     The -follow primary is deprecated; the -L option should be used instead.  See the STANDARDS
     section below for details.

SEE ALSO
     chflags(1), chmod(1), cvs(1), locate(1), lsvfs(1), whereis(1), which(1), xargs(1), stat(2),
     acl(3), fts(3), getgrent(3), getpwent(3), strmode(3), re_format(7), symlink(7)

STANDARDS
     The find utility syntax is a superset of the syntax specified by the IEEE Std 1003.1-2001
     (``POSIX.1&#39;&#39;) standard.

     All the single character options except -H and -L as well as -amin, -anewer, -cmin, -cnewer, -delete, -empty, -fstype, -iname, -inum, -iregex, -ls, -maxdepth, -mindepth, -mmin, -path,
     -print0, -regex and all of the -B* birthtime related primaries are extensions to IEEE Std
     1003.1-2001 (``POSIX.1&#39;&#39;).

     Historically, the -d, -L and -x options were implemented using the primaries -depth, -follow,
     and -xdev.  These primaries always evaluated to true.  As they were really global variables
     that took effect before the traversal began, some legal expressions could have unexpected
     results.  An example is the expression -print -o -depth.  As -print always evaluates to true,
     the standard order of evaluation implies that -depth would never be evaluated.  This is not the
     case.

     The operator -or was implemented as -o, and the operator -and was implemented as -a.

     Historic implementations of the -exec and -ok primaries did not replace the string ``{}&#39;&#39; in
     the utility name or the utility arguments if it had preceding or following non-whitespace char-
     acters.  This version replaces it no matter where in the utility name or arguments it appears.

     The -E option was inspired by the equivalent grep(1) and sed(1) options.

HISTORY
     A find command appeared in Version 1 AT&amp;T UNIX.

BUGS
     The special characters used by find are also special characters to many shell programs.  In
     particular, the characters ``*&#39;&#39;, ``[&#39;&#39;, ``]&#39;&#39;, ``?&#39;&#39;, ``(&#39;&#39;, ``)&#39;&#39;, ``!&#39;&#39;, ``\&#39;&#39; and ``;&#39;&#39; may
     have to be escaped from the shell.

     As there is no delimiter separating options and file names or file names and the expression, it
     is difficult to specify files named -xdev or !.  These problems are handled by the -f option
     and the getopt(3) ``--&#39;&#39; construct.

     The -delete primary does not interact well with other options that cause the file system tree
     traversal options to be changed.

     The -mindepth and -maxdepth primaries are actually global options (as documented above).  They
     should probably be replaced by options which look like options.
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/18</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631366.html">
                
                  <h1>MWeb + Github Pages 搭建个人博客/静态网站</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1、打开GitHub Pages</h2>

<p>链接<a href="https://pages.github.com/">https://pages.github.com/</a> ，可以直接按照上面的操作指引来操作</p>

<p>(1)创建 github repository</p>

<p>官网说明如下图，需要先注册登录GitHub，然后创建repository，命名方式为<a href="http://username.github.io/">http://username.github.io</a>，注意用户名(前后两个输入框)保持一致。</p>

<p><img src="media/15998025631366/v2-2a7bdd7a71db76912f5c70db4b8e042e_720w.jpg" alt="img"/></p>

<p>（2）git client</p>

<p>我使用了桌面客户端（下载链接 <a href="https://desktop.github.com/">https://desktop.github.com</a> ）</p>

<p><img src="media/15998025631366/v2-9029512a20bea6a74ff6e661b1ed554c_720w.jpg" alt="img"/></p>

<p>（3）下载 GitHub desktop 并登录，选择你创建的repository，并点击clone按钮。然后就可以看到本地的克隆文件的路径。</p>

<p><img src="media/15998025631366/v2-416a3d6414b387d21ea3dcc584960298_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-02f99763a4d07e5120d6b16e0943756b_720w.jpg" alt="img"/></p>

<h2 id="toc_1">2、下面先转到MWeb这里，下载并使用MWeb创建静态网页</h2>

<p>MWeb是一个简单易用的markdown工具，还可以生成静态网站，不过要付费。</p>

<p>（1）首先左下角新增静态网站分类</p>

<p><img src="media/15998025631366/v2-f0d346f5cce89cfc883f55608ce7d9e5_720w.jpg" alt="img"/></p>

<p>（2）对这个站点的名称、模版等进行设置</p>

<p><img src="media/15998025631366/v2-f802de2a62db871c817d2e8206ff095e_720w.jpg" alt="img"/></p>

<p>（3）在里面写一篇文章，然后选择生成网站</p>

<p><img src="media/15998025631366/v2-47cbf01ada99ca1f078774154bef5dc5_720w.jpg" alt="img"/></p>

<p>(4)生成网站后，还是在这个下拉菜单中选择“在finder中显示网站生成位置”，就会定位到本地文稿所在位置。</p>

<p><img src="media/15998025631366/v2-186318f6b291d3874d16b8da45b575a1_720w.jpg" alt="img"/></p>

<p>(5)将这里的所有文件复制到 github在本地的克隆文件中</p>

<h2 id="toc_2">3、最后一步，文件上传与同步</h2>

<p>打开GitHub desktop，左边栏中就是我们要同步的新增文件。点击左下的commit，然后点击右上角的push按钮。这样就OK了，你可以访问一下你的网站（<a href="http://username.github.io/">http://username.github.io</a>）看看效果了～</p>

<p><img src="media/15998025631366/v2-89721201dd82fec5937c581099a43303_720w.jpg" alt="img"/></p>

<p><img src="media/15998025631366/v2-d2dede1032356af70fa032dd52076aa3_720w.jpg" alt="img"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025628736.html">
                
                  <h1>Pandas 学习图谱</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在学习 Pandas 的过程中，整理了一份学习图谱，希望也能够帮助到同样想入门 pandas 的同学。</p>

<p>Pandas 是基于 Numpy 的一种工具,该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas 提供了大量快速便捷地处理数据的函数和方法，是使 Python 成为强大而高效的数据分析环境的重要因素之一。</p>

<p>构建和处理两个或更多个维数组是一项繁琐的任务，用户在编写函数时要考虑数据集的方向。 但是使用Pandas数据结构，减少了用户的思考。例如，使用表格数据(DataFrame)，在语义上更有用于考虑索引(行)和列，而不是轴0和轴1。</p>

<p>Pandas 两个重要的数据结构，Seriers 和 DataFrame，多个 Seriers 组成了 DataFrame，就像 ndArray 一样，是我们使用 pandas 操作数据的基本数据结构。我们在掌握了 Pandas 的数据之后，重点关注各种数据分析的方法，以工具的角度来学习 Pandas，将常用的方法整理出来，后面用到时查找即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200902193021.png" alt="img"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177589969343.html">
                
                  <h1>Pandas 学习图谱</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在学习 Pandas 的过程中，整理了一份学习图谱，希望也能够帮助到同样想入门 pandas 的同学。</p>

<p>Pandas 是基于 Numpy 的一种工具,该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas 提供了大量快速便捷地处理数据的函数和方法，是使 Python 成为强大而高效的数据分析环境的重要因素之一。</p>

<p>构建和处理两个或更多个维数组是一项繁琐的任务，用户在编写函数时要考虑数据集的方向。 但是使用Pandas数据结构，减少了用户的思考。例如，使用表格数据(DataFrame)，在语义上更有用于考虑索引(行)和列，而不是轴0和轴1。</p>

<p>Pandas 两个重要的数据结构，Seriers 和 DataFrame，多个 Seriers 组成了 DataFrame，就像 ndArray 一样，是我们使用 pandas 操作数据的基本数据结构。我们在掌握了 Pandas 的数据之后，重点关注各种数据分析的方法，以工具的角度来学习 Pandas，将常用的方法整理出来，后面用到时查找即可。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200902193021.png" alt="img"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144524.html">
                
                  <h1>PyCharm+PyQt5+QtDesigner配置详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>这篇文章主要介绍了PyCharm+PyQt5+QtDesigner配置详解，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧</p>

<p><strong>关于</strong></p>

<p>最近要在python下做可视化界面的设计，想到之前用QtDesigner来画界面很是方便，当时画完之后都要手动在终端输入<br/>
<code>pyuic5 -o 1.py 1.ui</code><br/>
来把.ui文件转换为.py的代码再进行编辑，不是很方便，联想到要是能在PyCharm下完成所有工作就好了，所以就有了这篇博客，简单记录下，不够详细的地方请谅解。</p>

<p><strong>配置前提</strong></p>

<ul>
<li>PyCharm （这个不多说，官网下载安装）</li>
<li>Anaconda 1.8.7（强烈安利，很好的python包管理平台，官网下载安装）</li>
<li>python 3.6.5 （其实装anaconda的时候会自动安装）</li>
</ul>

<p><strong>配置过程</strong></p>

<p>1、首先打开anaconda，environment—&gt;not installed搜索pyqt，会看到pyqt的包，直接勾选后右下角apply就安装好了。安完后可以切换到installed查看是否真正安装成功。<br/>
2、安装完PyQt5之后，可以在anaconda—&gt;Libra—&gt;bin目录下看到designer.exe，这个就是用来画界面的QtDesigner，记住这个目录，一会儿会用到。</p>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940443.jpg" alt="img"/> </p>

<p>3、打开PyCharm，打开File—&gt;Settings—&gt;External Tools,点击加号来添加自己的工具，做如下配置：</p>

<blockquote>
<p>Name:QtDesigner<br/>
Group:Qt<br/>
Programs:F:\anaconda\Library\bin\designer.exe(这里是各位自己的designer路径，之前所看到的)<br/>
Working directory：\(ProjectFileDir\)</p>
</blockquote>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940444.jpg" alt="img"/></p>

<p>完成后点“OK”，现在QtDesigner就配置好了，就可以直接在PyCharm中打开它来画界面了，但是要在PyCharm中把界面的.ui文件转换为.py文件还需要后面的配置。</p>

<p>4、同样在External Tools中点击加号来配置pyuic：</p>

<blockquote>
<p>Name:Pyuic<br/>
Group:Qt<br/>
Program:F:\anaconda\python.exe(各位自己的python路径)<br/>
Arguments：-m PyQt5.uic.pyuic \(FileName\) -o \(FileNameWithoutExtension\).py<br/>
Working directory：\(FileDir\)</p>
</blockquote>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940445.jpg" alt="img"/></p>

<p>5、至此就全部配置好了，接下来是test，回到PyCharm，Tools—&gt;Qt—&gt;QtDesigner，点击即可打开designer：</p>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940446.jpg" alt="img"/> </p>

<p>然后创建一个最简单的界面，把这个界面保存（默认是保存在当前pycharm项目目录下，我这里命名“first.ui”）。</p>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940447.jpg" alt="img"/> </p>

<p>6、回到pycharm，可以看到工程目录下已经产生了first.ui，右键它，Qt—&gt;Pyuic，点击后即可产生first.py文件，OK接下来就可以愉快地写代码了(⊙o⊙)…</p>

<p><img src="https://img.jbzj.com/file_images/article/202008/202008120940448.jpg" alt="img"/></p>

<p>然后就可以不断的修改first.ui文件，每次修改完再转换为.py文件就好了。</p>

<p>到此这篇关于PyCharm+PyQt5+QtDesigner配置详解的文章就介绍到这了,更多相关PyCharm+PyQt5+QtDesigner配置内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631328.html">
                
                  <h1>PyCharm使用技巧与常见错误</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>​ Pycharm是我们日常进行python开发常用的集成工具，如果我们能够熟练的掌握它，可以大幅提高我们程序的开发效率。下面由勇哥会结合图文形式给大家分享pycharm的实用技巧和常见的错误。</p>
</blockquote>

<ol>
<li><strong>如何快速给指定的代码块添加注释，如何取消指定代码块的注释？</strong></li>
</ol>

<p>​       如果要注释前6行代码，首先需要鼠标选中前6行，如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212821.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       然后在英文输入状态下，按下CTRL+ / 快捷键给选中的代码块添加注释,如下图所示。显示灰色的语句块已经成功实现注释了。如果要取消已经注释的块，直接用鼠标选中已经注释的块，然后再按一次CTRL+ /快捷键即可取消注释。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212827.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>如何快速对指定的代码块进行整体缩进和取消缩进</strong></li>
</ol>

<p>​       整体缩进：</p>

<p>​       选中要缩进的代码块，然后按下tab键就实现缩进4个空格。</p>

<p>​       取消缩进：</p>

<p>​       选中要取消缩进的代码块，然后按shift+tab组合键可以实现</p>

<p>​       取消缩进。如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212837.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>设置pycharm代码编辑器的背景风格</strong></li>
</ol>

<p>​       对于经常编写代码的人，设置合理的背景色有助于保护我们的眼睛，给人愉悦的心情。</p>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》》选择Color Scheme》》选择python如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212842.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       在下图红色框中选择代码编辑器显示风格，选择完成点击OK按钮。就会看到我们的代码编辑器背景已经变了。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212939.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>改变代码编辑器的字体大小与字体类型</strong></li>
</ol>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》》选择Font如下图所示。修改完成单机OK按钮。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212950.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>给工程配置解释器</strong></li>
</ol>

<p>​       第一次使用pycharm后，创建工程后，需要给当前的工程设置解释器，如果不配置会报如下错误：</p>

<p>​       No Python interpreter configured for the project。这个错误也是初学者最常见遇到的错误。</p>

<p>​       解决办法：</p>

<p>​       点击File-&gt;Setting-&gt;Project:your project name-&gt;Project Interpreter-&gt;右上角齿轮-&gt;Add Local，找到python解释器添加进来就可以了。如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312212957.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>快速搜索代码区和输出区的目标内容</strong></li>
</ol>

<p>​       将关闭定位在代码区，然后按ctrl+f 组合键实现内容搜索，如下图所示，可以使用精确搜索，也支持利用正则表达式去搜索。使用正则规则搜索内容，需要在图中将Regex前的框打勾。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213002.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       代码的输出结果区也可以进行搜索，如下图所示。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213007.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>代码比对</strong></li>
</ol>

<p>​       在日常的开发中，经常会碰到当前代码和历史的某个版本代码进行比对修改和查看。</p>

<p>​       首先将光标定位在当前的代码区，然后点击view菜单》》选择compare with…菜单，在弹出的窗口中选择历史的某个代码文件，点击确定如下图所示</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213011.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<ol>
<li><strong>设置代码模板</strong></li>
</ol>

<p>​       pycharm 支持代码模板功能，这是一个比较实用的功能。它可以在你新建一个文件时，按照你预设的模板给你生成一段内容，比如解释器路径，编码方法，作者有关信息等。操作方法如下：</p>

<p>​       点击软件界面左上角的file菜单》》点击Settings菜单》》在弹出界面的左侧列选择Editor项》选择File and Code Template 如下图所示，选择python Script，然后在图中右侧区域书写模板信息。创建完成，点击确定按钮。</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20200312213015.jpg" alt="PyCharm使用技巧与常见错误"/></p>

<p>​       在工程中，新建一个python源码文件，名为111，如下图所示，就可以看到刚添加的模板信息。</p>

<p><img src="http://p3.pstatp.com/large/pgc-image/71f85071d47c44d8b6618540fb805549" alt="PyCharm使用技巧与常见错误"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15998025631194.html">
                
                  <h1>Pycharm的调试功能</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0"><strong>前言</strong></h2>

<p>​   <strong>Debug调试，是一项学习编程人员的重要技能。只有当你学会 debug 了以后，才可以正确的知道程序的走向流程是如何的，今天就来给大家介绍一下 pycharm 中的 debug 功能！</strong></p>

<h2 id="toc_1"><strong>debug的前世</strong></h2>

<p>​   在正式讲解之前，先来了解下 debug 这个词的由来，就像我们初学Python 时，先要了解下它历史的由来。</p>

<blockquote>
<p>​ 1937年，美国青年霍华德·艾肯找到IBM公司为其投资200万美元研制计算机，第一台成品艾肯把它取名为：马克1号（mark1），又叫“自动序列受控计算机”，从这时起IBM公司由生产制表机，肉铺磅秤，咖啡研磨机等乱七八糟玩意儿行业，正式跨进“计算机”领地。为马克1号编制程序的是哈佛的一位女数学家葛丽斯·莫雷·霍波，有一天，她在调试程序时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍波诙谐的把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，后来成为计算机领域的专业行话。从而debug意为排除程序故障的意思。<br/>
--百度百科</p>
</blockquote>

<p>​   看了上面的小故事，debug 一词的由来，是由 bug 词得来的，bug 是臭虫的意思，debug 就是解决臭虫。</p>

<p>​   在如今的互联网时代，多少你肯定听说过 bug 这个词，比如什么什么软件又出 bug 了！说的就是软件在使用的过程中，程序出现了一些错误。故称之为 bug。</p>

<p>​   <strong>而 debug 则是通过工具来对代码进行调试，一步步找出程序中出现 bug 的位置，也就是程序中具体错误代码的位置。</strong>就像故事中所说，debug过程就是在解决虫子一样。。</p>

<h2 id="toc_2"><strong>pycharm 中的 debug 模式</strong></h2>

<p>​   来步入今天的正题。首先，还是用示例说话，我们书写一段简短的代码，来帮我们完成今天要讲的内容。</p>

<pre class="line-numbers"><code class="language-python">def sum_demo(x, y):
    for _ in range(2):
    x += 1
    y += 1
    result = x + y

if __name__ == &#39;__main__&#39;:
    result = sum_demo(1, 1)
    print(result)
</code></pre>

<p>​   肉眼识别下，猜猜结果是多少呢？初学者可能没见过 for 循环中的下划线，在 Python 中是占位符的意思，因为单纯的循环两次而已，并不用到它的循环结果。最终 result 会输出 6 。</p>

<p>在 pycharm 中，如何开启 debug 调试，一共有三种进入的方法，如下（下图均可点开放大观看）：</p>

<p>​   方法一：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assets384a2c7fcbba4fa192559fe11f9ffa91.jpg" alt="img"/></p>

<p>​   方法二：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assetsbe9f690ed0144dd394a3b901a574a6de.jpg" alt="img"/></p>

<p>​   方法三：</p>

<p><img src="Pycharm%E7%9A%84%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD.assets5362d3b132944103b3ce4ee9d9a8e898.jpg" alt="img"/></p>

<p>​   有一种方法，就是 pycharm 导航栏处，有个run，点开以后即可看到 debug ，这里就不截图演示了。</p>

<p>​   单纯的进入 debug 模式，你会发现，与正常的 run 去运行程序没有差异。差异就是 pycharm 的控制台部分，从 run 跑到了 debug 显示。</p>

<p><img src="media/15998025631194/f57c00a5578e438b99186977063ef45c.jpg" alt="img"/></p>

<p>​   接下来要讲的，才是 debug 中的重中之重，即断点调试！</p>

<h2 id="toc_3"><strong>debug 的断点调试</strong></h2>

<p>​   断点调试，英文 breakpoint。用大白话来解释下，断点调试其实就是在程序自动运行的过程中，你在代码某一处打上了断点，当程序跑到你设置的断点位置处，则会中断下来，此时你可以看到之前运行过的所有程序变量。来继续刚才的演示，pycharm 中如何设置断点。点击前：</p>

<p><img src="media/15998025631194/2b69c23f3d5540b3b2aad1019c92eb7b.jpg" alt="img"/></p>

<p>​   点击后，每行代码都设置上断点：</p>

<p><img src="media/15998025631194/2eeda84be72d4050afc1b53b8b4019f5.jpg" alt="img"/></p>

<p>​   设置完断点后，开启 debug 调试模式运行下，看到结果：</p>

<p><img src="media/15998025631194/eb7efb81a4f74431813e45c35cabfc2d.jpg" alt="img"/></p>

<p>​   看到了这么多新摆设，是不是有点怕了！不怕，咱们先来从控制台每个按钮讲起：</p>

<p><img src="media/15998025631194/89109f6c373e4f1f8207489bd6ba1d8c.jpg" alt="img"/></p>

<p>​   如果要是忘记中文意思的话，没有关系，鼠标指到按钮处，悬浮一会儿，会有英文提示的。继续再来说横排按钮：</p>

<p><img src="media/15998025631194/643e7919e4404d378ad981b91a478a60.jpg" alt="img"/></p>

<p>​   其中，横排最重要，经常用到的按钮，来解释一下，自己鼠标悬浮去看英文即可：</p>

<p>​   <code>step over（F8快捷键）</code>：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，<strong>程序代码越过子函数，但子函数会执行，且不进入。</strong></p>

<p>​   <code>step into（F7快捷键）</code>：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。</p>

<p>​   <code>step into my code（Alt+Shift+F7快捷键）</code>：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。</p>

<p>​   <code>step out（Shift+F8快捷键）</code>：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</p>

<p>​   <code>Resume program(F9快捷键)</code>：继续恢复程序，直接运行到下一断点处。以上四个功能，就是最常用的功能，一般操作步骤就是，<strong>设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。</strong></p>

<h2 id="toc_4"><strong>示例演示</strong></h2>

<p>​   上面的基础概念明白了以后，直接用图片示例演示下：</p>

<p><strong>1.设置初步断点</strong></p>

<p><img src="media/15998025631194/48887ceff1ee4320a9cfcbc29a687725.jpg" alt="img"/></p>

<p><strong>2.F7 进入函数</strong></p>

<p><img src="media/15998025631194/047e27bba8064e088a8e35664b542ffb.jpg" alt="img"/></p>

<p><strong>3.F8 单步调试，往下执行代码</strong></p>

<p><img src="media/15998025631194/cfd7dba081484ab5a4cfdfde6667c06a.jpg" alt="img"/></p>

<p>继续 F8 单步调试，往下执行代码：</p>

<p><img src="media/15998025631194/836459703944478982352b097cf37f40.jpg" alt="img"/></p>

<p>继续 F8 单步调试：</p>

<p><img src="media/15998025631194/8c19393661834869bb354569522e1e5f.jpg" alt="img"/></p>

<p>继续 F8 单步调试：</p>

<p><img src="media/15998025631194/973b3367e75e42fe83a85e790b691cd8.jpg" alt="img"/></p>

<p><img src="media/15998025631194/2b5e2461a0d14e33b8345c2b85831c6b.jpg" alt="img"/></p>

<p><strong>4.看够了循环，想直接看最终 result 加完的结果，结果处打断点，直接 F9</strong></p>

<p><img src="media/15998025631194/801f24e8285d4452b9e15100a166aa33.jpg" alt="img"/></p>

<p>​   以上就是断点调试的全过程。看完之后，理解了吗~是不是顿时明白了断点调试的重要性，使用断点可以快速帮助我们理解程序中的各处逻辑！</p>

<h2 id="toc_5"><strong>结语</strong></h2>

<p>​   <strong>看到这里，基本的调试，相信你认真看完的话，已经可以上手使用了！但是要拓展的点还有很多，比如 pycharm 为什么在工程性的程序中颇受欢迎，因为它实在是太强大了。。。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/09/11</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144555.html">
                
                  <h1>PyQuery常用用法总结</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>什么是PyQuery</strong></p>

<p>PyQuery是一个类似于jQuery的解析网页工具，使用lxml操作xml和html文档，它的语法和jQuery很像。和XPATH，Beautiful Soup比起来，PyQuery更加灵活，提供增加节点的class信息，移除某个节点，提取文本信息等功能。</p>

<p><strong>初始化PyQuery对象</strong></p>

<p>html文档的所有操作都需要PyQuery对象来完成，初始化PyQuery对象主要有三种方式，分别是通过网址、字符串和文件名创建。</p>

<p><strong>方式一：通过网址初始化PyQyery对象</strong><br/>
先看一段代码：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
s = &#39;&lt;html&gt;&lt;title&gt;PyQuery用法总结&lt;title&gt;&lt;/html&gt;&#39;
doc = pq(s)
print(doc(&#39;title&#39;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;title&gt;PyQuery用法总结&lt;/title&gt;
</code></pre>

<p>首先要import PyQuery类，然后将字符串传递给PyQuery类，这样就生成了一个PyQuery对象，通过该对象就可以访问字符串中的title节点。<br/>
PyQuery还会将残缺的html文档补全。看下面的代码：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
s = &#39;&lt;html&gt;&lt;title&gt;PyQuery用法总结&lt;/title&gt;&#39;
doc = pq(s)
print(doc(&#39;html&#39;))
</code></pre>

<p>运行的结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;html&gt;&lt;head&gt;&lt;title&gt;PyQuery用法总结&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;
</code></pre>

<p>可以我们的字符串的html节点是没有闭合的，并且缺少head节点。初始化PyQuery对象之后，会把html文档补全，并且自动加上head节点。</p>

<p><strong>方式二：URL网址初始化PyQyery对象</strong><br/>
将要解析的URL网址当做参数传递给PyQuery类：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq

url = &#39;http://www.bigdata17.com&#39;
doc = pq(url=url,encoding=&#39;utf-8&#39;)
print(doc(&#39;title&#39;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;title&gt;Home - Summer哥的自留地&lt;/title&gt;
</code></pre>

<p><strong>方式三：通过文件初始化PyQyery对象</strong><br/>
这个方式也比较常用，很多时候我们会将网站爬取下来然后保存在本地磁盘：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq

doc = pq(filename=&#39;test_pyquery.html&#39;,encoding=&#39;utf-8&#39;)
print(doc(&#39;title&#39;))
</code></pre>

<p><strong>访问节点属性：</strong><br/>
使用attr()方法访问节点的属性:</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
li = pq(&#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&lt;li id=&quot;test2&quot; class=&quot;test2&quot;&gt;&lt;/li&gt;&#39;)(&#39;li&#39;)
print(li.attr(&quot;id&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">test1
</code></pre>

<p>上面的代码中有两个id不同的li节点，但是attr()方法只取第一个li节点的id属性值，而不取第二个，我们把上面的代码修改下，把第一个li节点的id属性去掉，attr方法是否只取第一个复合条件节点的属性值：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
li = pq(&#39;&lt;li class=&quot;test1&quot;&gt;&lt;/li&gt;&lt;li id=&quot;test2&quot; class=&quot;test2&quot;&gt;&lt;/li&gt;&#39;)(&#39;li&#39;)
print(li.attr(&quot;id&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">None
</code></pre>

<p>第一个li节点没有id属性，因此返回结果为None，所以可见，attr()方法返回的是第一个节点的属性值。</p>

<p>那要取多个li节点的属性值，要怎么做呢？这就要结合items()方法来实现。items()方法是返回的节点的生成器<code>generator object PyQuery.items</code>：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
li = pq(&#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&lt;li id=&quot;test2&quot; class=&quot;test2&quot;&gt;&lt;/li&gt;&#39;)(&#39;li&#39;)
print(li.items())
for item in li.items():
    print(item.attr(&quot;id&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;generator object PyQuery.items at 0x0000027F26082728&gt;
test1
test2
</code></pre>

<p><strong>动态添加节点属性</strong><br/>
PyQuery有很多方法动态添加节点的属性，我们挑选几个比较常用的方法介绍个大伙。<br/>
<strong>addClass()</strong>,动态添加节点class属性：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
html = &#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&#39;
li = pq(html)(&#39;li&#39;)
li.addClass(&quot;addClass&quot;)
print(li)
</code></pre>

<p>运行结果：<br/>
<code>&lt;li id=&quot;test1&quot; class=&quot;test1 addClass&quot;/&gt;</code><br/>
可见li节点的calss属性值有test1变为test1 addclass。</p>

<p>addClass()方法只能动态添加节点class属性的值，能不能动态添加其他属性呢？答案是当然可以，attr()方法就可以实现：</p>

<pre class="line-numbers"><code class="language-text">
 


from pyquery import PyQuery as pq
html = &#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&#39;
li = pq(html)(&#39;li&#39;)
li.attr(&quot;name&quot;,&quot;li name&quot;)
print(li)
li.attr(&quot;type&quot;,&quot;li&quot;)
print(li)
print(li.attr(&quot;type&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li id=&quot;test1&quot; class=&quot;test1&quot; name=&quot;li name&quot;/&gt;
&lt;li id=&quot;test1&quot; class=&quot;test1&quot; name=&quot;li name&quot; type=&quot;li&quot;/&gt;
li
</code></pre>

<p>上面的代码一共执行了3次attr()方法，执行第一次attr()方法时，有两个参数，分别是name和li name。这是给li节点添加name属性及属性值。执行第二次attr()方法也有两个参数，分别是type和li，这是给li几点添加type属性及type属性值。执行第三次方法attr()方法只有一个type参数，根据前面介绍的attr()方法的用法可知，是获取li节点type属性的值。</p>

<p><strong>小结：</strong> attr()方法只有一个参数时，是获取节点的属性值，有两个参数时，是给节点添加属性及属性值，第一个参数时属性，第二个参数时属性值。</p>

<p>removeClass(),动态移除节点的class属性：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
html = &#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&#39;
li = pq(html)(&#39;li&#39;)
li.removeClass(&quot;test1&quot;)
print(li)
</code></pre>

<p>运行结果：<br/>
<code>&lt;li id=&quot;test1&quot; class=&quot;&quot;/&gt;</code><br/>
将class节点的属性值有test1变为“”。</p>

<p><strong>动态添加/修改文本值</strong><br/>
PyQuery支持动态给节点添加文本值：</p>

<pre class="line-numbers"><code class="language-text">
 


from pyquery import PyQuery as pq
html = &#39;&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;&lt;/li&gt;&#39;
li = pq(html)(&#39;li&#39;)
li.html(&quot;use html() dynamic add text&quot;)
print(li)
li.text(&quot;use text() dynamic add text&quot;)
print(li)
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;use html() dynamic add text&lt;/li&gt;
&lt;li id=&quot;test1&quot; class=&quot;test1&quot;&gt;use text() dynamic add text&lt;/li&gt;
</code></pre>

<p>可见使用html()和text()方法都可以动态的给节点添加或修改节点的文本值。</p>

<p><strong>获取节点文本值</strong><br/>
PyQuery提供text()和html()方法获取节点的文本属性值：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
html = &#39;&lt;li id = &quot;test_id&quot;&gt;li text value&lt;/li&gt;&#39;
li = pq(html)(&#39;li&#39;)
print(li.text())
print(li.html())
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">li text value
li text value
</code></pre>

<p><strong>小结：</strong> html()和text()如果没参数，则是获取属性的文本值，如果有参数，则是改变或者添加节点的属性值。</p>

<p><strong>移除节点：</strong><br/>
remove()方法可以动态移除节点：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
html = 
&lt;ul&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;/li&gt;
&lt;/ul&gt;

ul = pq(html)(&#39;ul&#39;)
print(ul.text())
print(&#39;执行remove()移除节点&#39;)
ul.find(&#39;li&#39;).remove()
print(ul.text())
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">hello I am ul tag
hello I am li tag
执行remove()移除节点
hello I am ul tag
</code></pre>

<p>上述代码的ul节点中有个li节点，执行ul.text()方法会返回包括li节点的文本信息，如果我们不想返回li节点的文本信息，仅仅只需要ul节点的文本信息“hell I am ul tag”，要怎么做呢？这时候remove()方法就派上用场了，它删除掉ul节点内的li节点。</p>

<p><strong>查找节点</strong><br/>
PyQuery支持使用css的.和#来查找节点：</p>

<pre class="line-numbers"><code class="language-text">from pyquery import PyQuery as pq
html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag li&#39;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li&gt;hello I am li tag&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
</code></pre>

<p>上述代码是通过.div_tag获取class为div_tag的节点，然后通过#ul_tag获取id为ul_tag的节点，最后返回所有的li节点。</p>

<p>find()方法查找节点：</p>

<pre class="line-numbers"><code class="language-text">html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag&#39;).find(&quot;li&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
</code></pre>

<p>可见find(“li”)是把所有li节点及子节点都查找出来。</p>

<p>还有一个children()方法，是获取当前节点的所有子节点。该方法可以传入css选择器：children(’.ul_tag’)。</p>

<pre class="line-numbers"><code class="language-text">html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag&#39;).find(&quot;li&quot;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
</code></pre>

<p>使用parent()方法获取当前节点的父亲节点：</p>

<pre class="line-numbers"><code class="language-text">html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag li&#39;).parent())
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;ul id=&quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>上述代码通过.div_tag #ul_tag li css选择器定位到li节点，然后调用parent()方法获取li节点的父节点ul。</p>

<p>parents()返回当前节点的所有祖宗节点：</p>

<pre class="line-numbers"><code class="language-text">html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag li&#39;).parents())
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;html&gt;&lt;body&gt;&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id=&quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;/html&gt;&lt;body&gt;&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id=&quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id=&quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ul id=&quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello I am li tag too&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>上面代码返回li节点的所有祖宗节点：html，body,div,ul。</p>

<p>siblings()方法返回当前节点的兄弟节点：</p>

<pre class="line-numbers"><code class="language-text">html = 
&lt;div class=&quot;div_tag&quot;&gt;
&lt;ul id = &quot;ul_tag&quot;&gt;
hello I am ul tag
&lt;li class=&quot;li_class1&quot;&gt;hello I am li tag&lt;a&gt;www.bigdata17.com&lt;/li&gt;
&lt;li class=&quot;li_class2&quot;&gt;hello I am li tag too&lt;/li&gt;
&lt;li class=&quot;li_class3&quot;&gt;hello I am the third li tag&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

doc = pq(html)
print(doc(&#39;.div_tag #ul_tag .li_class1&#39;).siblings())
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li class=&quot;li_class2&quot;&gt;hello I am li tag too&lt;/li&gt;
&lt;li class=&quot;li_class3&quot;&gt;hello I am the third li tag&lt;/li&gt;
</code></pre>

<p>使用.div_tag #ul_tag .li_class1 CSS节点选择器获取到class为liclassq1的li节点，就是第一个li节点，然后调用siblings()方法获取到子节点，分别是<br/>
第二和第三个li节点。</p>

<p>sibligs()还支持传入css选择器筛选符合条件的li节点：</p>

<pre class="line-numbers"><code class="language-text">print(doc(&#39;.div_tag #ul_tag .li_class1&#39;).siblings(&#39;.li_class3&#39;))
</code></pre>

<p>运行结果：</p>

<pre class="line-numbers"><code class="language-text">&lt;li class=&quot;li_class3&quot;&gt;hello I am the third li tag&lt;/li&gt;
</code></pre>

<p>总结：本文讲述了如何使用PyQuery获取网页节点，节点的文本信息，改变节点属性，删除节点属性，增加节点属性等知识点。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16177587144466.html">
                
                  <h1>Python 操作OS、Json（内含技巧） 模块</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">引言</h2>

<blockquote>
<p>Python中 json和os模块经常使用。尤其在自动化测试中接口返回Json文件、如何转换json文件,读取字段值,本次集中学习。</p>
</blockquote>

<h2 id="toc_1">Json</h2>

<ul>
<li><p>知识点：JSon转换字典</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203147.jpg" alt="img"/></p>
<p>json转dict.jpg</p></li>
<li><p>知识点： 遍历字典查看</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203201.jpg" alt="img"/></p>
<p>遍历字典.jpg</p></li>
<li><p>知识点： 字典转Json串</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203217.jpg" alt="img"/></p>
<p>字典转Json.jpg</p></li>
<li><p>知识点： 高级解析--遍历字典</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203234.jpg" alt="img"/></p>
<p>多层嵌套Json文件.jpg</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203516.jpg" alt="img"/></p>
<p>多层嵌套遍历字典.jpg</p></li>
</ul>

<pre class="line-numbers"><code class="language-ruby"># -*- coding: utf-8 -*-
# @Time : 2021/3/1 19:08
# @File : 03_json_高级解析.py
# @Author : Yvon_早安阳光
import json

json_demo = &quot;&quot;&quot; {
&quot;weixin&quot;:[
   {
    &quot;name&quot;: &quot;木青子&quot;,
    &quot;uid&quot;: &quot;8888&quot;,
    &quot;desc&quot;: &quot;Python&quot;
   },
   {
    &quot;name&quot;: &quot;千叶&quot;,
    &quot;uid&quot;: &quot;6666&quot;,
    &quot;desc&quot;: &quot;Appium&quot;
   }

  ],

&quot;web&quot;:[
   {
    &quot;name&quot;: &quot;忘忧草&quot;,
    &quot;url&quot;: &quot;www.baidu.com&quot;,
    &quot;desc&quot;: &quot;Selenium&quot;
   },
   {
    &quot;name&quot;: &quot;花狐&quot;,
    &quot;url&quot;: &quot;www.huahu.com&quot;,
    &quot;desc&quot;: &quot;Django&quot;
   }

  ]

}&quot;&quot;&quot;

if __name__ == &quot;__main__&quot;:

    #将jSON串转换成字典
    json_dict = json.loads(json_demo)

    # print(&quot;原类型: %s&quot; % type(json_demo))
    # print(&quot;转换后的类型:&quot;, type(json_dict))

    # 遍历字典
    for (k, v) in json_dict.items():
        # 输出第一层 K为weixin,web  V为其对应的列表[]串的数据
        print(k, &quot;:&quot;, v)
        for date in v:
            #             #遍历列表,v为[]
            for (data_k, data_v) in date.items():
                print(&quot; &quot;, data_k, &quot; &quot;, data_v)
</code></pre>

<h2 id="toc_2">高阶操作--简化遍历字典代码</h2>

<blockquote>
<p>遍历字典可以获取所有元素,如果我只想获取到所有的name字段值,遍历字典方法很显然不友好,代码繁琐,神操作来啦! 哈哈!!</p>

<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203308.jpg" alt="img"/></p>

<p>技巧获取嵌套元素.jpg</p>
</blockquote>

<pre class="line-numbers"><code class="language-bash">import json

from jsonpath import jsonpath

json_demo = &quot;&quot;&quot; {
&quot;weixin&quot;:[
   {
    &quot;name&quot;: &quot;木青子&quot;,
    &quot;uid&quot;: &quot;8888&quot;,
    &quot;desc&quot;: &quot;Python&quot;
   },
   {
    &quot;name&quot;: &quot;千叶&quot;,
    &quot;uid&quot;: &quot;6666&quot;,
    &quot;desc&quot;: &quot;Appium&quot;
   }

  ],

&quot;web&quot;:[
   {
    &quot;name&quot;: &quot;忘忧草&quot;,
    &quot;url&quot;: &quot;www.baidu.com&quot;,
    &quot;desc&quot;: &quot;Selenium&quot;
   },
   {
    &quot;name&quot;: &quot;花狐&quot;,
    &quot;url&quot;: &quot;www.huahu.com&quot;,
    &quot;desc&quot;: &quot;Django&quot;
   }

  ]

}&quot;&quot;&quot;

if __name__ == &quot;__main__&quot;:

    #将jSON串转换成字典
    json_dict = json.loads(json_demo)
    # print(&quot;原类型: %s&quot; % type(json_demo))
    # print(&quot;转换后的类型:&quot;, type(json_dict))
    A = jsonpath(json_dict, &#39;$..name&#39;)[0]
    print(&quot;查询第一个name: %s&quot; % A)
    names = jsonpath(json_dict, &#39;$..name&#39;)
    for name in names:
        print(&quot;查询所有name: %s&quot; %name)
</code></pre>

<h2 id="toc_3">OS模块</h2>

<ul>
<li><p>知识点：获取当前的工作目录</p></li>
<li><p>知识点：返回当前目录</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203336.jpg" alt="img"/></p>
<p>获取目录.jpg</p></li>
<li><p>知识点：创建新的文件目录--当文件已存在时，无法创建该文件</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203343.jpg" alt="img"/></p>
<p>创建文件.jpg</p></li>
<li><p>知识点：重命名目录</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203401.jpg" alt="img"/></p>
<p>重命名文件.jpg</p></li>
<li><p>知识点：删除指定目录,要注意删除的目录必须无子目录、子文件</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203433.jpg" alt="img"/></p>
<p>删除目录.jpg</p></li>
<li><p>知识点：改变工作目录</p>
<p><img src="https://picbed001.oss-cn-shanghai.aliyuncs.com/img/20210403203537.jpg" alt="img"/></p>
<p>改变工作目录.jpg</p></li>
</ul>

<pre class="line-numbers"><code class="language-python"># -*- coding: utf-8 -*-
# @Time : 2021/3/1 17:31
# @File : duqu.py
# @Author : Yvon_早安阳光

import  os
if __name__ == &quot;__main__&quot;:
    #获取当前的工作目录
    print(&#39;获取当前的工作目录: %s&#39;% os.getcwd())
    # 返回当前目录
    print(&#39;返回当前目录: %s&#39;%os.curdir)
    # 创建新的文件目录--当文件已存在时，无法创建该文件
    os.mkdir(&#39;test_mk5&#39;)
    #重命名目录
    os.rename(&#39;test_mk3&#39;,&#39;test_mk1&#39;)
    #删除指定目录,要注意删除的目录必须无子目录、子文件
    #目标删除目录必须存在，否则抛出异常
    os.removedirs(&#39;test_mk2&#39;)
    # 将改变至C盘
    os.chdir(&quot;c:&quot;)
    print(&#39;获取当前的工作目录: %s&#39; % os.getcwd())
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/04/07</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16177589969532.html">**用好VSCode这13款插件和8个快捷键**</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025628955.html">1000行MySQL学习笔记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144586.html">[Chrome浏览器F12开发者工具简单使用]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15998025629001.html">[Pycharm 常用快捷键]</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16177587144704.html">[如何在 Linux 中减少/缩小 LVM 大小（逻辑卷调整）]</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
